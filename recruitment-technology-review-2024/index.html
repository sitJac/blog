<!DOCTYPE html>
<html lang="en">
<head>

  <script type="text/javascript" src="https://unpkg.com/minigrid@3.1.1/dist/minigrid.min.js"></script>
  <link rel="stylesheet" href="/photos/photos.css">
  <script type="text/javascript" src="/photos/photo.js"></script>

  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">


<link rel="stylesheet" href="/blog/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"sitjac.github.io","root":"/blog/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="掌握计科五大件：编译原理、计网、计组、操作系统、数据结构和算法，常见面试题. 具有一定的代码框架设计能力，熟悉常用设计模式, 有面向对象开发经验。 熟练掌握网络编程、熟悉TCP&#x2F;UDP、HTTP协议及Socket，以及其他以太网通信协议。 熟练掌握C++11之后的语言特性，保证代码的可维护性和可扩展性。 掌握系统构建、调试、异常分析和性能优化的基本方法。 掌握多线程、异步编程等并发编程开发必">
<meta property="og:type" content="article">
<meta property="og:title" content="近期技术面试问题回顾与总结">
<meta property="og:url" content="https://sitjac.github.io/recruitment-technology-review-2024/index.html">
<meta property="og:site_name" content="sitJac&#39;s Blog">
<meta property="og:description" content="掌握计科五大件：编译原理、计网、计组、操作系统、数据结构和算法，常见面试题. 具有一定的代码框架设计能力，熟悉常用设计模式, 有面向对象开发经验。 熟练掌握网络编程、熟悉TCP&#x2F;UDP、HTTP协议及Socket，以及其他以太网通信协议。 熟练掌握C++11之后的语言特性，保证代码的可维护性和可扩展性。 掌握系统构建、调试、异常分析和性能优化的基本方法。 掌握多线程、异步编程等并发编程开发必">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2024-02-29T12:33:38.000Z">
<meta property="article:modified_time" content="2024-05-08T14:53:20.323Z">
<meta property="article:author" content="sitJac">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://sitjac.github.io/recruitment-technology-review-2024/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>近期技术面试问题回顾与总结 | sitJac's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">sitJac's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/blog/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://sitjac.github.io/recruitment-technology-review-2024/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="sitJac">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="sitJac's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          近期技术面试问题回顾与总结
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-02-29 20:33:38" itemprop="dateCreated datePublished" datetime="2024-02-29T20:33:38+08:00">2024-02-29</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Offer/" itemprop="url" rel="index"><span itemprop="name">Offer</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <div class="note info">

<ul>
<li>掌握计科五大件：<code>编译原理</code>、<code>计网</code>、<code>计组</code>、<code>操作系统</code>、<code>数据结构和算法</code>，<a target="_blank" rel="noopener" href="https://imageslr.com/2020/07/08/tech-interview">常见面试题</a>.</li>
<li>具有一定的代码框架设计能力，熟悉常用<code>设计模式</code>, 有面向对象开发经验。</li>
<li>熟练掌握<code>网络编程</code>、熟悉<code>TCP/UDP</code>、<code>HTTP</code>协议及<code>Socket</code>，以及其他以太网通信协议。</li>
<li>熟练掌握<code>C++11</code>之后的语言特性，保证代码的可维护性和可扩展性。</li>
<li>掌握<code>系统构建</code>、<code>调试</code>、<code>异常分析</code>和<code>性能优化</code>的基本方法。</li>
<li>掌握<code>多线程</code>、<code>异步编程</code>等<code>并发编程</code>开发必要方法、框架和组件，掌握性能优化方法。</li>
<li>理解并能够应用各种数据<code>序列化和反序列化</code>技术，如JSON, XML, Protocol Buffers等。</li>
<li>具备较强的逻辑思维和代码阅读能力；能持续学习，钻研问题，不断提升质量和效率。</li>
</ul>
</div>

<span id="more"></span>

<h2 id="C-语言特性"><a href="#C-语言特性" class="headerlink" title="C++语言特性"></a><center>C++语言特性</center></h2><h3 id="编译链接"><a href="#编译链接" class="headerlink" title="编译链接"></a>编译链接</h3><details>
    <summary>
        点击展开
    </summary>

<p>C++的编译链接过程主要包括四个步骤：预处理、编译、汇编和链接。</p>
<ol>
<li><p><strong>预处理（Preprocessing）</strong>：这是编译过程的第一步，主要处理源代码中的预处理指令，如<code>#include</code>、<code>#define</code>等。预处理器会将所有的<code>#include</code>指令替换为对应文件的内容，处理所有的宏定义，处理条件编译指令等。预处理后的文件通常以<code>.i</code>或<code>.ii</code>为扩展名。</p>
</li>
<li><p><strong>编译（Compilation）</strong>：编译器将预处理后的代码（也就是C++源代码）转换为汇编语言。在这个过程中，编译器会检查语法错误，进行词法分析、语法分析、语义分析和优化等操作。编译后的文件通常以<code>.s</code>为扩展名。</p>
</li>
<li><p><strong>汇编（Assembly）</strong>：汇编器将编译器生成的汇编代码转换为机器语言代码，也就是目标代码。这个过程主要是将汇编指令转换为机器指令。汇编后的文件通常以<code>.o</code>或<code>.obj</code>为扩展名，这些文件被称为目标文件。</p>
</li>
<li><p><strong>链接（Linking）</strong>：链接器将一个或多个目标文件以及所需的库文件链接为一个可执行文件。在这个过程中，链接器会解析所有的符号引用，确保每个符号都有一个定义，然后将所有的目标文件和库文件合并为一个文件。链接后的文件就是我们可以执行的程序。</p>
</li>
</ol>
<p>使用GCC编译器，可以通过以下命令执行C++编译过程的每一步：</p>
<ol>
<li>预处理：使用<code>-E</code>选项进行预处理。这将只执行预处理并将结果输出到标准输出。如果你想将结果保存到文件，可以重定向输出到一个文件。例如：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -E myfile.cpp &gt; myfile.i</span><br></pre></td></tr></table></figure></li>
<li>编译：使用<code>-S</code>选项进行编译。这将执行预处理和编译，但不进行汇编，生成的汇编代码将保存到一个.s文件。例如：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -S myfile.i</span><br></pre></td></tr></table></figure></li>
<li>汇编：使用<code>-c</code>选项进行汇编。这将执行预处理、编译和汇编，但不进行链接，生成的目标代码将保存到一个.o文件。例如：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -c myfile.s</span><br></pre></td></tr></table></figure></li>
<li>链接：如果没有指定任何选项，GCC将执行所有步骤，包括链接，生成的可执行文件默认名为a.out。如果你想指定输出文件的名字，可以使用<code>-o</code>选项。例如:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ myfile.o -o myfile</span><br></pre></td></tr></table></figure></li>
</ol>
<p>拓展阅读：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://taifua.com/psst-compile-link.html">《程序员的自我修养》阅读笔记 - 编译和链接</a></li>
<li><a target="_blank" rel="noopener" href="https://chyyuu.gitee.io/compiler-toolbox/">《清华大学编译原理在线实验》</a></li>
</ul>
</details>



<h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><details>
    <summary>
        点击展开
    </summary>

<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>Lambda表达式是C++11引入的一个新特性，它允许定义一个匿名函数并立即使用。以下是一些常见的应用场景：</p>
<ol>
<li><strong>排序</strong>：可以使用lambda表达式定义自定义的排序规则。例如，可以使用lambda表达式对一个vector的元素进行降序排序：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">std::<span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), [](<span class="type">int</span> a, <span class="type">int</span> b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li><strong>算法</strong>：许多C++的STL算法，如std::for_each，std::transform等，都可以接受lambda表达式作为参数。例如，可以使用lambda表达式将一个vector的所有元素都增加1：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">std::for_each(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), [](<span class="type">int</span>&amp; n) &#123;</span><br><span class="line">    n++;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li><strong>线程</strong>：可以使用lambda表达式创建新的线程。例如，使用lambda表达式在一个新的线程中打印一条消息：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">([]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    std::cout &lt;&lt; <span class="string">&quot;Hello from a new thread!&quot;</span> &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;</span><br><span class="line">t.<span class="built_in">join</span>();</span><br></pre></td></tr></table></figure></li>
<li><strong>函数对象</strong>：可以使用lambda表达式创建函数对象，这对于需要回调函数的场景非常有用。例如，可以使用lambda表达式定义一个函数，该函数接受一个函数对象作为参数，并在函数内部调用这个函数对象：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> print = [](<span class="type">const</span> std::string&amp; message) &#123;</span><br><span class="line">    std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>由于匿名函数没有名字，可以直接在代码中定义和使用，因此可以更加<code>灵活地组织代码结构</code>、<code>使代码更加简洁清晰</code>、<code>实现更加精细的控制流程</code>。具体来说使用 lambda 表达式有几个主要的优点：</p>
<ol>
<li><p><strong>简洁性</strong>：lambda 表达式通常比完整的函数定义更简洁，尤其是在函数体很小的情况下。这可以使代码更易于阅读和理解。</p>
</li>
<li><p><strong>局部性</strong>：lambda 表达式定义在使用它的地方，这可以增强代码的局部性，使得读者不需要在文件中跳来跳去来查找函数的定义。</p>
</li>
<li><p><strong>闭包</strong>：lambda 表达式可以捕获其外部作用域中的变量，这使得它们可以访问和操作这些变量，即使在 lambda 表达式的定义之外。这是普通函数无法做到的。</p>
</li>
<li><p><strong>匿名性</strong>：lambda 表达式是匿名的，这意味着你不需要为它们想一个名字。这在你只需要在一个地方使用函数的情况下非常有用。</p>
</li>
<li><p><strong>兼容STL</strong>：许多标准模板库（STL）的算法，如 std::sort，std::for_each 等，都接受函数对象作为参数。使用 lambda 表达式可以方便地创建这样的函数对象。</p>
</li>
</ol>
<p>这并不意味着在工作中总是使用 lambda 表达式。在某些情况下，使用普通的函数可能更合适，例如<em>当函数体很大，或者需要在多个地方重用同一个函数时</em>。</p>
<p>拓展阅读：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/cpp/lambda-expressions-in-cpp">C++ 中的 Lambda 表达式 - Microsoft Learn</a></li>
<li><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/lambda">Lambda expressions (since C++11) - cppreference</a></li>
</ul>
</details>




<h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><details>
    <summary>
        点击展开
    </summary>

<ol>
<li><p><strong>基本概念</strong>：</p>
<p> 智能指针是C++中的一种对象，它像原始指针一样可以指向动态分配的内存，但当它们离开作用域或被显式删除时，它们会自动删除所指向的内存，从而防止内存泄漏。</p>
</li>
<li><p><strong>分类特点</strong>：</p>
<p> C++中有三种类型的智能指针：</p>
<p> <code>std::unique_ptr</code>：这是一种独占所有权的智能指针，同一时间只能有一个std::unique_ptr指向给定的对象。当std::unique_ptr被销毁时，它所指向的对象也会被自动销毁。</p>
<p> <code>std::shared_ptr</code>：这是一种共享所有权的智能指针。多个std::shared_ptr可以指向同一个对象，该对象只有在最后一个指向它的std::shared_ptr被销毁时才会被自动销毁。</p>
<p> <code>std::weak_ptr</code>：这是一种不拥有所有权的智能指针。它是为了解决std::shared_ptr可能会引起的循环引用问题而设计的。std::weak_ptr可以从一个std::shared_ptr或者另一个std::weak_ptr中构造，但是它不会增加引用计数。</p>
</li>
<li><p><strong>使用场景</strong>：</p>
<p> <code>std::unique_ptr</code>：当你需要确保一个对象在任何时候都只有一个所有者时，或者需要在堆上分配一个对象并确保它在不再需要时被删除时，可以使用std::unique_ptr。</p>
<p> <code>std::shared_ptr</code>：当你需要在多个所有者之间共享一个对象时，可以使用std::shared_ptr。</p>
<p> <code>std::weak_ptr</code>：当你需要一个指向对象的指针，但不需要拥有该对象时，可以使用std::weak_ptr。这通常用于解决std::shared_ptr的循环引用问题。</p>
</li>
<li><p><strong>内存管理</strong>：</p>
<p> 智能指针在C++中是一种对象，它们可以像原始指针一样指向动态分配的内存，但是它们有一个额外的特性：当智能指针离开作用域或被显式删除时，它们会自动删除所指向的内存。这就是智能指针如何帮助管理内存的方式。例如，考虑以下代码：</p>
<p> 例如，考虑以下代码：</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>* raw_ptr = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">42</span>); <span class="comment">// Allocate memory with new.</span></span><br><span class="line">    <span class="comment">// ... use raw_ptr ...</span></span><br><span class="line">&#125; <span class="comment">// Memory leak! We didn&#x27;t delete raw_ptr.</span></span><br></pre></td></tr></table></figure>
<p> 在这上面个例子中，我们在foo函数中使用new分配了一块内存，但是我们忘记了在函数结束时使用delete释放这块内存，所以发生了内存泄漏。如果如下使用智能指针，这个问题将得到结局。</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">smart_ptr</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">42</span>))</span></span>; <span class="comment">// Allocate memory with new.</span></span><br><span class="line">    <span class="comment">// ... use smart_ptr ...</span></span><br><span class="line">&#125; <span class="comment">// No memory leak! smart_ptr automatically deletes the memory.</span></span><br></pre></td></tr></table></figure>
<p> 当smart_ptr在foo函数结束时离开作用域，它会自动删除所指向的内存，从而防止内存泄漏。</p>
</li>
<li><p><strong>循环引用</strong>：</p>
<p> 循环引用是指两个或更多的对象互相引用，形成一个闭环。在这种情况下，即使没有外部引用，这些对象也无法被垃圾收集器回收，因为它们互相引用，看起来都是“活跃”的。</p>
<p> 在C++中，<code>std::shared_ptr</code>可能会导致循环引用。例如，如果你有两个类A和B，它们互相包含对方的std::shared_ptr，那么就会形成一个循环引用。即使没有任何其他对象引用这两个对象，它们也不会被销毁，因为它们互相引用。</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::shared_ptr&lt;B&gt; b_ptr;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;A deleted\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::shared_ptr&lt;A&gt; a_ptr;</span><br><span class="line">    ~<span class="built_in">B</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;B deleted\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;A&gt; a = std::<span class="built_in">make_shared</span>&lt;A&gt;();</span><br><span class="line">    std::shared_ptr&lt;B&gt; b = std::<span class="built_in">make_shared</span>&lt;B&gt;();</span><br><span class="line">    a-&gt;b_ptr = b;</span><br><span class="line">    b-&gt;a_ptr = a;</span><br><span class="line">&#125; <span class="comment">// a and b are not deleted here due to circular reference</span></span><br></pre></td></tr></table></figure>

<p> <code>std::weak_ptr</code>可以帮助解决这个问题。std::weak_ptr是一种不控制所指向对象生存期的智能指针，它指向一个由std::shared_ptr管理的对象。将上述代码中的std::shared_ptr替换为std::weak_ptr，就可以解决循环引用的问题。</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::weak_ptr&lt;B&gt; b_ptr; <span class="comment">// change shared_ptr to weak_ptr</span></span><br><span class="line">    ~<span class="built_in">A</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;A deleted\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::weak_ptr&lt;A&gt; a_ptr; <span class="comment">// change shared_ptr to weak_ptr</span></span><br><span class="line">    ~<span class="built_in">B</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;B deleted\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;A&gt; a = std::<span class="built_in">make_shared</span>&lt;A&gt;();</span><br><span class="line">    std::shared_ptr&lt;B&gt; b = std::<span class="built_in">make_shared</span>&lt;B&gt;();</span><br><span class="line">    a-&gt;b_ptr = b;</span><br><span class="line">    b-&gt;a_ptr = a;</span><br><span class="line">&#125; <span class="comment">// a and b are deleted here as expected</span></span><br></pre></td></tr></table></figure>
<p> 在上面这个例子中，当a和b离开作用域时，它们会被正确地销毁，因为没有std::shared_ptr指向它们。</p>
</li>
<li><p><strong>实际代码</strong>：</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Test created\n&quot;</span>; &#125;</span><br><span class="line">    ~<span class="built_in">Test</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Test deleted\n&quot;</span>; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">testFunc</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Test function\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Using unique_ptr</span></span><br><span class="line">    std::unique_ptr&lt;Test&gt; uPtr = std::<span class="built_in">make_unique</span>&lt;Test&gt;();</span><br><span class="line">    uPtr-&gt;<span class="built_in">testFunc</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Using shared_ptr</span></span><br><span class="line">    std::shared_ptr&lt;Test&gt; sPtr = std::<span class="built_in">make_shared</span>&lt;Test&gt;();</span><br><span class="line">    &#123;</span><br><span class="line">        std::shared_ptr&lt;Test&gt; sPtr1 = sPtr;</span><br><span class="line">        sPtr1-&gt;<span class="built_in">testFunc</span>();</span><br><span class="line">        std::cout &lt;&lt; sPtr.<span class="built_in">use_count</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// prints: 2</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; sPtr.<span class="built_in">use_count</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// prints: 1</span></span><br><span class="line">    sPtr-&gt;<span class="built_in">testFunc</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Using weak_ptr</span></span><br><span class="line">    std::weak_ptr&lt;Test&gt; wPtr = sPtr;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> sPtr2 = wPtr.<span class="built_in">lock</span>(); <span class="comment">// lock() returns a shared_ptr</span></span><br><span class="line">        <span class="keyword">if</span> (sPtr2) &#123;</span><br><span class="line">            sPtr2-&gt;<span class="built_in">testFunc</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(wPtr.<span class="built_in">expired</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Object has been deleted\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Object still exists\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>底层实现</strong>：</p>
<p>C++智能指针的底层实现通常依赖于原始指针和RAII（Resource Acquisition Is Initialization）机制。</p>
<p><code>std::unique_ptr</code>的底层实现通常是一个包装了原始指针的类，通过重载析构函数来释放资源。</p>
<p><code>std::shared_ptr</code>的底层实现通常包含一个引用计数器，记录资源被共享的次数，以及一个原始指针指向资源。</p>
<p><code>std::weak_ptr</code>的底层实现通常包含一个指向资源的原始指针和一个指向引用计数器的弱引用计数器。</p>
</li>
</ol>
<p>拓展阅读：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://en.cppreference.com/book/intro/smart_pointers">Smart Pointers - cppreference</a></li>
<li><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/memory">Dynamic memory management - cppreference</a></li>
</ul>
</details>



<h3 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h3><details>
    <summary>
        点击展开
    </summary>

<h4 id="C-11-STL"><a href="#C-11-STL" class="headerlink" title="C++11 STL"></a>C++11 STL</h4><table>
<thead>
<tr>
<th align="center">特性</th>
<th align="center">API</th>
</tr>
</thead>
<tbody><tr>
<td align="center">thread</td>
<td align="center"><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/thread/thread">std::thread</a></td>
</tr>
<tr>
<td align="center">mutex</td>
<td align="center"><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/thread/mutex">std::mutex</a>、<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/thread/lock_guard">std::lock_guard</a>、<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/thread/unique_lock">std::unique_lock</a></td>
</tr>
<tr>
<td align="center">condition variable</td>
<td align="center"><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/thread/condition_variable">std::condition_variable</a>、<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/thread/condition_variable_any">std::condition_variable_any</a></td>
</tr>
<tr>
<td align="center">atomic</td>
<td align="center"><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/atomic/atomic">std::atomic</a>、<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/atomic/atomic_thread_fence">std::atomic_thread_fence</a></td>
</tr>
<tr>
<td align="center">future</td>
<td align="center"><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/thread/future">std::future</a>、<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/thread/shared_future">std::shared_future</a></td>
</tr>
<tr>
<td align="center">interruption</td>
<td align="center">无</td>
</tr>
</tbody></table>
<hr>
<h4 id="Concurrency"><a href="#Concurrency" class="headerlink" title="Concurrency"></a>Concurrency</h4><p><strong>并发编程</strong>是指在程序中同时执行多个任务的编程方式。这些任务可以是同时执行的、交替执行的，或者同时进行的。并发编程的目标是有效地利用计算资源，提高程序的性能、响应速度以及资源利用率。</p>
<p>在并发编程中，可以采用多种方式实现任务的并发执行，包括<code>多线程</code>、<code>异步编程</code>、<code>并行计算</code>等。这些方式可以根据任务的性质、程序的需求以及硬件平台的特性来选择。并发编程通常涉及到<code>线程间的同步与通信</code>、<code>资源共享</code>与<code>竞态条件</code>等问题，需要合理地设计和管理，以确保程序的正确性和性能。</p>
<p>并发编程在现代计算机系统中广泛应用，比如<strong>网络服务器、多线程GUI应用程序、并行计算、分布式系统</strong>等领域。通过并发编程，可以充分利用多核处理器、提高程序的并发性能，同时也可以满足用户对于快速响应和高吞吐量的需求。</p>
<hr>
<h4 id="Asynchronous"><a href="#Asynchronous" class="headerlink" title="Asynchronous"></a>Asynchronous</h4><p><strong>异步编程</strong>是一种编程模式，允许程序在<strong>执行某些耗时操作时不会被阻塞，而是可以继续执行其他任务</strong>。在C++中，异步编程通常通过<code>多线程</code>或<code>异步IO</code>来实现。</p>
<p>一种常见的实现异步编程的方式是使用C++11引入的<code>std::async</code>和<code>std::future</code>。<code>std::async函数</code>允许我们在一个新的线程或者线程池中执行一个函数，并返回一个<code>std::future对象</code>，用于获取函数的执行结果。通过std::future对象，我们可以等待异步操作的完成，也可以获取异步操作的结果。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 耗时操作函数，模拟一个耗时操作，比如网络请求或者文件IO</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">performTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">3</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span>; <span class="comment">// 返回一个结果</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 启动一个异步任务，并获取 future 对象</span></span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; futureResult = std::<span class="built_in">async</span>(std::launch::async, performTask);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行一些其他任务</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;正在执行其他任务...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待异步任务完成并获取结果</span></span><br><span class="line">    <span class="type">int</span> result = futureResult.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出异步任务的结果</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;异步任务的结果是: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一种实现异步编程的方式是使用C++标准库中的<code>std::thread</code>和<code>std::condition_variable</code>等<strong>多线程工具</strong>，或者使用一些第三方库，比如Boost.Asio等，来处理异步IO操作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量，用于存储异步任务的结果</span></span><br><span class="line"><span class="type">int</span> asyncResult;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 耗时操作函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">performTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 模拟一个耗时操作，比如网络请求或者文件IO</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将结果存储在全局变量中</span></span><br><span class="line">    asyncResult = <span class="number">42</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个互斥量和条件变量</span></span><br><span class="line">    std::mutex mtx;</span><br><span class="line">    std::condition_variable cv;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动一个新线程执行异步任务</span></span><br><span class="line">    <span class="function">std::thread <span class="title">asyncThread</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        performTask();</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="comment">// 异步任务完成后，通知主线程</span></span></span></span><br><span class="line"><span class="params"><span class="function">        cv.notify_one();</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行一些其他任务</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;正在执行其他任务...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待异步任务完成</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    cv.<span class="built_in">wait</span>(lock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出异步任务的结果</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;异步任务的结果是: &quot;</span> &lt;&lt; asyncResult &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待异步线程结束并释放资源</span></span><br><span class="line">    asyncThread.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总的来说，异步编程可以提高程序的性能和响应速度，特别是在需要处理大量IO操作或者并发任务的情况下。</p>
<hr>
<h4 id="Multithreading"><a href="#Multithreading" class="headerlink" title="Multithreading"></a>Multithreading</h4><p><strong>多线程编程</strong>是一种并发编程的方式，通过创建多个线程来同时执行多个任务。在多线程编程中，每个线程都可以独立执行任务，同时共享程序的内存空间。<br>多线程够何理利用C多核处理器资源，提高程序的性能和响应速度，避免阻塞，降低每个线程的工作量 ，提高程序的并发性能和执行效率。<br>多线程编程通常涉及到线程的创建、同步、通信和管理等方面的操作，需要注意线程安全性、同步机制等方面的问题，以确保多个线程能够正确地协调工作，避免竞态条件和数据不一致等问题。</p>
<h5 id="ThreadManagement"><a href="#ThreadManagement" class="headerlink" title="ThreadManagement"></a><a target="_blank" rel="noopener" href="https://github.com/downdemo/Cpp-Concurrency-in-Action-2ed/blob/master/docs/01_managing_thread.md">ThreadManagement</a></h5><p>下面的demo演示了如何用<code>std::thread</code>创建四个线程，分别演示了四种不同的创建方式和参数传递方式。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span> <span class="comment">// 引入 std::ref</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程函数，无参数版本</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunctionNoParam</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread with no parameter.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程函数，有参数版本</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunctionWithParam</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread with parameter: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程函数，使用引用类型参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunctionWithRef</span><span class="params">(<span class="type">int</span>&amp; value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在线程中修改引用参数</span></span><br><span class="line">    value += <span class="number">50</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread with reference parameter: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建线程1：无参数版本</span></span><br><span class="line">    <span class="function">std::thread <span class="title">thread1</span><span class="params">(threadFunctionNoParam)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程2：有参数版本，传递整数参数</span></span><br><span class="line">    <span class="type">int</span> param = <span class="number">42</span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">thread2</span><span class="params">(threadFunctionWithParam, param)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程3：匿名函数版本</span></span><br><span class="line">    <span class="function">std::thread <span class="title">thread3</span><span class="params">([] &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        std::cout &lt;&lt; <span class="string">&quot;Thread with anonymous function.&quot;</span> &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程4：传递引用类型的参数</span></span><br><span class="line">    <span class="type">int</span> data = <span class="number">100</span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">thread4</span><span class="params">([&amp;data] &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="comment">// 在线程中修改引用参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">        data += <span class="number">50</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">        std::cout &lt;&lt; <span class="string">&quot;Thread with reference parameter: &quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line">    <span class="comment">// std::thread thread4(threadFunctionWithRef, std::ref(data)); // 使用 std::ref 来传递引用类型参数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程等待线程1执行完成</span></span><br><span class="line">    thread1.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分离线程2，主线程不再等待其执行完成</span></span><br><span class="line">    thread2.<span class="built_in">detach</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程等待线程3执行完成</span></span><br><span class="line">    thread3.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分离线程4，主线程不再等待其执行完成</span></span><br><span class="line">    thread4.<span class="built_in">detach</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出引用参数被修改后的值</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Modified data in main thread: &quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="ThreadPool"><a href="#ThreadPool" class="headerlink" title="ThreadPool"></a>ThreadPool</h5><p><strong>线程池</strong>是一种有效管理和复用线程的机制，能够减少线程创建和销毁的开销、控制并发线程数量、提高响应速度、平衡系统负载、同时简化线程的管理和调度。</p>
<p>下面的demo演示了如何使用C++的标准库<code>std::thread</code>创建多线程，并利用线程池的概念管理多个线程执行任务的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ThreadPool</span>(<span class="type">size_t</span> numThreads) : <span class="built_in">stop</span>(<span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; numThreads; ++i) &#123;</span><br><span class="line">            threads.<span class="built_in">emplace_back</span>([<span class="keyword">this</span>] &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    std::function&lt;<span class="built_in">void</span>()&gt; task;</span><br><span class="line">                    &#123;</span><br><span class="line">                        std::unique_lock&lt;std::mutex&gt; <span class="built_in">lock</span>(queueMutex);</span><br><span class="line">                        condition.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>] &#123; <span class="keyword">return</span> stop || !tasks.<span class="built_in">empty</span>(); &#125;);</span><br><span class="line">                        <span class="keyword">if</span> (stop &amp;&amp; tasks.<span class="built_in">empty</span>()) <span class="keyword">return</span>;</span><br><span class="line">                        task = std::<span class="built_in">move</span>(tasks.<span class="built_in">front</span>());</span><br><span class="line">                        tasks.<span class="built_in">pop</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">task</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">ThreadPool</span>() &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(queueMutex)</span></span>;</span><br><span class="line">            stop = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        condition.<span class="built_in">notify_all</span>();</span><br><span class="line">        <span class="keyword">for</span> (std::thread &amp;thread : threads) &#123;</span><br><span class="line">            thread.<span class="built_in">join</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> F, <span class="keyword">class</span>... Args&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">enqueue</span><span class="params">(F&amp;&amp; f, Args&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(queueMutex)</span></span>;</span><br><span class="line">            tasks.<span class="built_in">emplace</span>(std::<span class="built_in">bind</span>(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...));</span><br><span class="line">        &#125;</span><br><span class="line">        condition.<span class="built_in">notify_one</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;std::thread&gt; threads;</span><br><span class="line">    std::queue&lt;std::function&lt;<span class="type">void</span>()&gt;&gt; tasks;</span><br><span class="line"></span><br><span class="line">    std::mutex queueMutex;</span><br><span class="line">    std::condition_variable condition;</span><br><span class="line">    <span class="type">bool</span> stop;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 演示任务函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">taskFunction</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Task &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; is being executed.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 模拟任务执行时间</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Task &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; execution completed.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建线程池，包含3个线程</span></span><br><span class="line">    <span class="function">ThreadPool <span class="title">pool</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向线程池添加任务</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        pool.<span class="built_in">enqueue</span>(taskFunction, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程等待任务完成</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Thread-Synchronization"><a href="#Thread-Synchronization" class="headerlink" title="Thread Synchronization"></a>Thread Synchronization</h5><p><strong>线程同步</strong>是一种控制多个线程在共享资源上的访问顺序和时机的机制。在多线程环境中，当多个线程同时访问共享资源时，可能会出现竞态条件（Race Condition）和数据不一致等问题，线程同步就是为了解决这些问题而引入的一种手段。</p>
<p>保证线程同步的方法有多种，其中一些常见的方法包括：</p>
<h6 id="Mutex"><a href="#Mutex" class="headerlink" title="Mutex"></a><strong>Mutex</strong></h6><p><strong>互斥锁（Mutex）</strong>是一种最常见的线程同步机制，它可以确保在任意时刻只有一个线程能够访问共享资源。线程在访问共享资源之前会先获取互斥锁，访问完成后再释放互斥锁，从而确保了线程的互斥访问。</p>
<p>互斥量的概念可以用一个比喻来理解：假设有一个房间（共享资源），只有拿到房间的钥匙（互斥量的锁）的人才能进入房间（访问共享资源），其他人需要等待拿到钥匙后才能进入。当一个线程拿到了互斥量的锁时，其他线程就无法再拿到该锁，只能等待锁的释放。</p>
<p>用法示例如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 共享资源</span></span><br><span class="line"><span class="type">int</span> sharedData = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 互斥量</span></span><br><span class="line">std::mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程函数，向共享资源添加值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addValue</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 加锁，保护共享资源</span></span><br><span class="line">    mtx.<span class="built_in">lock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问共享资源</span></span><br><span class="line">    sharedData += value;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; adds value &quot;</span> &lt;&lt; value &lt;&lt; <span class="string">&quot;, sharedData is now &quot;</span> &lt;&lt; sharedData &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解锁，释放互斥量</span></span><br><span class="line">    mtx.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建两个线程</span></span><br><span class="line">    <span class="function">std::thread <span class="title">thread1</span><span class="params">(addValue, <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">thread2</span><span class="params">(addValue, <span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程执行完成</span></span><br><span class="line">    thread1.<span class="built_in">join</span>();</span><br><span class="line">    thread2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出最终共享资源的值</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Final sharedData value: &quot;</span> &lt;&lt; sharedData &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按照锁的具体类型来分类：</p>
<ul>
<li><p><code>互斥锁（Mutex)</code>：互斥锁是最基本的锁类型，用于保护共享资源的互斥访问。互斥锁适用于对共享资源的长时间操作，因为它会阻塞其他试图获取锁的线程，直到拥有锁的线程释放锁。<code>std::mutex</code>是C++标准库中提供的递归锁类。</p>
</li>
<li><p><code>递归锁（Recursive Mutex）</code>：递归锁是一种特殊的互斥锁，允许同一个线程多次获得锁。递归锁可以在同一线程内对共享资源进行递归调用，避免死锁的问题。<code>std::recursive_mutex</code>是C++标准库提供的递归锁类。</p>
</li>
<li><p><code>自旋锁（Spinlock）</code>：自旋锁是一种特殊类型的互斥锁，当一个线程试图获取一个已经被其他线程持有的自旋锁时，它会在一个循环中不断地尝试获取锁，而不是被阻塞。自旋锁适用于对共享资源的短时间操作，因为它可以避免线程切换的开销。C++标准库中没有提供原生的自旋锁，但可以通过原子操作等机制实现自旋锁的功能。</p>
</li>
<li><p><code>读写锁（Read-Write Lock）</code>：读写锁允许多个线程同时读取共享资源，但在任何时候只允许一个线程写入。读写锁可以提高读取操作的并发性能，适用于读取操作频繁、写入操作较少的场景。C++标准库中没有提供原生的读写锁，但可以通过互斥锁和条件变量等组合实现读写锁的功能。</p>
</li>
</ul>
<p>按照对并发控制的思想进行划分：</p>
<ul>
<li><p><code>乐观锁（Optimistic Locking）</code>：乐观锁是一种并发控制的策略，它假设多个线程在访问共享资源时不会发生冲突，因此在访问资源时不会立即加锁，而是在更新资源时才检查是否有冲突。如果发现冲突，就放弃更新，通常配合重试机制使用。乐观锁适用于冲突少的情况。</p>
</li>
<li><p><code>悲观锁（Pessimistic Locking）</code>：悲观锁是一种并发控制的策略，它假设多个线程在访问共享资源时会发生冲突，因此在访问资源时就立即加锁。悲观锁适用于冲突多的情况。</p>
</li>
</ul>
<h6 id="Condition-Variable"><a href="#Condition-Variable" class="headerlink" title="Condition Variable"></a><strong>Condition Variable</strong></h6><p><strong>条件变量（Condition Variable）</strong>是一种用于线程间通信和同步的机制，它允许线程在等待某个条件满足时进入阻塞状态，直到其他线程通知条件变量并唤醒它们。条件变量通常与互斥锁一起使用，<code>std::condition_variable</code>用于等待某个条件的发生，而<code>std::mutex</code>用于保护共享资源，确保在访问共享资源时的线程安全性。</p>
<p>最典型的使用场景是生产者和消费者问题：</p>
<ul>
<li>生产者线程负责生成产品，并将产品放入共享队列中。</li>
<li>消费者线程负责从共享队列中取出产品，并进行消费。</li>
<li>当共享队列为空时，消费者线程需要等待，直到有新的产品放入队列中。</li>
<li>当共享队列已满时，生产者线程需要等待，直到有消费者取出产品。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::queue&lt;<span class="type">int</span>&gt; sharedQueue; <span class="comment">// 共享队列</span></span><br><span class="line">std::mutex mtx; <span class="comment">// 互斥量</span></span><br><span class="line">std::condition_variable cv; <span class="comment">// 条件变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">500</span>)); <span class="comment">// 模拟生产过程</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">            sharedQueue.<span class="built_in">push</span>(i); <span class="comment">// 将产品放入队列中</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Produced: &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        cv.<span class="built_in">notify_one</span>(); <span class="comment">// 通知消费者线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        cv.<span class="built_in">wait</span>(lock, []&#123; <span class="keyword">return</span> !sharedQueue.<span class="built_in">empty</span>(); &#125;); <span class="comment">// 等待直到队列不为空</span></span><br><span class="line">        <span class="type">int</span> value = sharedQueue.<span class="built_in">front</span>(); <span class="comment">// 取出产品</span></span><br><span class="line">        sharedQueue.<span class="built_in">pop</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Consumed: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建生产者和消费者线程</span></span><br><span class="line">    <span class="function">std::thread <span class="title">producerThread</span><span class="params">(producer)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">consumerThread</span><span class="params">(consumer)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程执行完成</span></span><br><span class="line">    producerThread.<span class="built_in">join</span>();</span><br><span class="line">    consumerThread.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h6 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a><strong>Semaphore</strong></h6><p><strong>信号量（Semaphore）</strong>是一种计数器，用于控制对共享资源的访问权限。它允许多个线程同时访问共享资源，但可以限制同时访问的线程数量。通过对信号量的增加和减少操作，可以实现对共享资源的访问控制和线程同步。</p>
<p>C++标准库（C++11及更新版本）本身并没有提供信号量的实现，但是在POSIX系统中，可以使用<code>semaphore.h</code>头文件提供的函数来操作信号量。这些函数包括：</p>
<ul>
<li><p><strong>sem_init()：</strong> 初始化信号量。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_init</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> pshared, <span class="type">unsigned</span> <span class="type">int</span> value)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>sem_destroy()：</strong> 销毁信号量。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_destroy</span><span class="params">(<span class="type">sem_t</span> *sem)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>sem_wait()：</strong> 等待信号量。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_wait</span><span class="params">(<span class="type">sem_t</span> *sem)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>sem_trywait()：</strong> 尝试等待信号量，如果无法立即获取则立即返回。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_trywait</span><span class="params">(<span class="type">sem_t</span> *sem)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>sem_post()：</strong> 发送信号量。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_post</span><span class="params">(<span class="type">sem_t</span> *sem)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>sem_getvalue()：</strong> 获取信号量的当前值。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_getvalue</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> *sval)</span></span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>以上函数用于创建、销毁、等待和发送信号量，并可以获取当前信号量的值。需要注意的是，这些函数是在POSIX标准中定义的，因此在非POSIX系统上可能不适用，或者需要额外的库支持。</p>
<p>下面是使用信号量解决生产者-消费者问题的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::queue&lt;<span class="type">int</span>&gt; sharedQueue; <span class="comment">// 共享队列</span></span><br><span class="line">std::mutex mtx; <span class="comment">// 互斥量</span></span><br><span class="line"><span class="type">sem_t</span> empty; <span class="comment">// 空闲信号量，表示空闲的缓冲区数量</span></span><br><span class="line"><span class="type">sem_t</span> full; <span class="comment">// 满信号量，表示已填充的缓冲区数量</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> BUFFER_SIZE = <span class="number">5</span>; <span class="comment">// 缓冲区大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">500</span>)); <span class="comment">// 模拟生产过程</span></span><br><span class="line">        <span class="built_in">sem_wait</span>(&amp;empty); <span class="comment">// 等待空闲信号量</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">            sharedQueue.<span class="built_in">push</span>(i); <span class="comment">// 将产品放入队列中</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Produced: &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sem_post</span>(&amp;full); <span class="comment">// 发送满信号量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">sem_wait</span>(&amp;full); <span class="comment">// 等待满信号量</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">            <span class="type">int</span> value = sharedQueue.<span class="built_in">front</span>(); <span class="comment">// 取出产品</span></span><br><span class="line">            sharedQueue.<span class="built_in">pop</span>();</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Consumed: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sem_post</span>(&amp;empty); <span class="comment">// 发送空闲信号量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化信号量</span></span><br><span class="line">    <span class="built_in">sem_init</span>(&amp;empty, <span class="number">0</span>, BUFFER_SIZE);</span><br><span class="line">    <span class="built_in">sem_init</span>(&amp;full, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建生产者和消费者线程</span></span><br><span class="line">    <span class="function">std::thread <span class="title">producerThread</span><span class="params">(producer)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">consumerThread</span><span class="params">(consumer)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程执行完成</span></span><br><span class="line">    producerThread.<span class="built_in">join</span>();</span><br><span class="line">    consumerThread.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁信号量</span></span><br><span class="line">    <span class="built_in">sem_destroy</span>(&amp;empty);</span><br><span class="line">    <span class="built_in">sem_destroy</span>(&amp;full);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h6 id="Atomic-Operation"><a href="#Atomic-Operation" class="headerlink" title="Atomic Operation"></a><strong>Atomic Operation</strong></h6><p><strong>原子操作（Atomic Operation）</strong>是一种不可分割的操作，它要么完全执行，要么完全不执行，不存在中间状态，可以确保在多线程环境中对共享变量的操作是原子性的，不会被其他线程中断。原子操作通常用于实现对共享变量的安全访问和更新，避免了竞态条件和数据不一致等问题。</p>
<p><code>std::atomic</code>是C++标准库提供的模板类，用于执行原子操作，支持各种数据类型的原子操作，包括整数、指针、布尔值等，同时支持包括增加、读取、设置、交换等原子操作。</p>
<p>以下是<code>std::atomic</code>模板类的一些常见成员函数：</p>
<ul>
<li><code>load()</code>：以原子方式读取<code>std::atomic</code>对象的值。</li>
<li><code>store()</code>：以原子方式设置<code>std::atomic</code>对象的值。</li>
<li><code>exchange()</code>：以原子方式交换<code>std::atomic</code>对象的值，并返回之前的值。</li>
<li><code>compare_exchange_strong()</code>和<code>compare_exchange_weak()</code>：以原子方式比较并交换<code>std::atomic</code>对象的值，可以选择强一致性或者弱一致性。</li>
</ul>
<p>用法示例如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">counter</span><span class="params">(<span class="number">0</span>)</span></span>; <span class="comment">// 创建一个原子类型的整数对象，初始值为0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原子操作：增加计数器的值</span></span><br><span class="line">    counter++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原子操作：读取计数器的值</span></span><br><span class="line">    <span class="type">int</span> value = counter.<span class="built_in">load</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原子操作：设置计数器的值</span></span><br><span class="line">    counter.<span class="built_in">store</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原子操作：交换计数器的值，并返回之前的值</span></span><br><span class="line">    <span class="type">int</span> oldValue = counter.<span class="built_in">exchange</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Old Value: &quot;</span> &lt;&lt; oldValue &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们创建了一个<code>std::atomic</code>对象<code>counter</code>，并进行了一系列原子操作，这些操作都是原子性的，不会被其他线程中断，从而确保了对共享资源的操作是安全的。</p>
<h6 id="Barrier"><a href="#Barrier" class="headerlink" title="Barrier"></a><strong>Barrier</strong></h6><p><strong>屏障（Barrier）</strong>是一种同步机制，它可以确保所有线程在达到某个指定点之前都必须等待，然后一起继续执行。屏障通常用于多个线程在某个阶段需要等待其他线程都完成某个操作后再继续执行的场景。</p>
<p>C++标准库并没有提供原生的屏障（Barrier）实现。但是可以使用第三方库（如Boost库）提供的屏障来实现线程同步。以下是一个使用Boost库中的屏障的示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/thread.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/thread/barrier.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> NUM_THREADS = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">boost::barrier <span class="title">bar</span><span class="params">(NUM_THREADS)</span></span>; <span class="comment">// 创建一个屏障，指定线程数量为3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; boost::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; started.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 等待所有线程到达屏障</span></span><br><span class="line">    bar.<span class="built_in">wait</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; boost::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; finished.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建线程</span></span><br><span class="line">    boost::thread_group threads;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_THREADS; ++i) &#123;</span><br><span class="line">        threads.<span class="built_in">create_thread</span>(threadFunction);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待所有线程完成</span></span><br><span class="line">    threads.<span class="built_in">join_all</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，首先创建了一个屏障bar，指定了线程数量为3。然后创建了3个线程，并在每个线程中调用bar.wait()等待所有线程到达屏障。当所有线程都到达屏障后，它们才会继续执行后续的操作。</p>
<p>需要注意的是，上述代码使用了Boost库，需要在编译和链接时指定对应的库文件，并且需要安装Boost库。</p>
<hr>
<h5 id="Optimization"><a href="#Optimization" class="headerlink" title="Optimization"></a>Optimization</h5><p>在并发编程中，如何确保性能？请介绍一下并发编程中的常见性能优化技巧。</p>
<p>并发编程中确保性能的关键在于合理的设计和优化，并发算法和数据结构，以及有效地利用计算资源和系统资源。以下是一些确保性能的常见方法：</p>
<ol>
<li><p><strong>减少锁的使用：</strong> 锁是保护共享资源的关键机制，但过多地使用锁会导致线程之间频繁地竞争锁资源，降低程序的并发性能。因此，可以尽量减少锁的使用，尽量使用细粒度的锁或无锁数据结构来减少锁的竞争。</p>
</li>
<li><p><strong>使用非阻塞算法：</strong> 非阻塞算法可以避免线程之间的锁竞争，提高并发性能。常见的非阻塞算法包括无锁数据结构（如无锁队列、无锁链表等）和无锁算法（如CAS、原子操作等）。</p>
</li>
<li><p><strong>减少线程间的通信：</strong> 线程间的通信会引入额外的开销和延迟，降低程序的性能。因此，可以尽量减少线程间的通信，避免不必要的数据共享和同步操作。</p>
</li>
<li><p><strong>使用线程池：</strong> 使用线程池可以减少线程的创建和销毁开销，提高线程的复用性和效率，从而提高程序的并发性能。</p>
</li>
<li><p><strong>并行化任务：</strong> 将大型任务分解成多个小任务，并行执行可以充分利用多核处理器的计算能力，提高程序的执行效率和性能。</p>
</li>
<li><p><strong>优化数据访问模式：</strong> 合理设计数据结构和访问模式，减少内存访问和数据依赖，优化数据访问性能。</p>
</li>
<li><p><strong>使用高性能并发库：</strong> 使用高性能的并发库可以提供优化过的并发算法和数据结构，提高程序的并发性能。</p>
</li>
<li><p><strong>避免资源争用：</strong> 避免多个线程之间的资源争用，尽量减少共享资源的访问，优化资源的分配和利用，提高程序的并发性能。</p>
</li>
</ol>
<p>综上所述，确保性能的关键在于合理设计并发算法和数据结构，有效地利用计算资源和系统资源，并尽量减少线程间的通信和资源竞争，从而提高程序的并发性能。</p>
<p>拓展阅读：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/goodbigzzz/Cpp_Concurrency_In_Action_2nd-/tree/main">C++并发编程实战</a></li>
<li><a target="_blank" rel="noopener" href="https://www.limerence2017.com/2023/07/31/concpp/">C++并发</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/7292243642000392192">C++性能优化</a></li>
</ul>
</details>



<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><details>
    <summary>
        点击展开
    </summary>

<ol>
<li><p>简述多态实现的原理</p>
<p>多态可以分为<strong>静态多态（编译时多态）</strong>和<strong>动态多态（运行时多态）</strong>，可以理解为<code>函数重载 &amp; 模板</code>和<code>函数重写</code>。</p>
<ul>
<li><code>静态多态</code><ul>
<li>实现方式：<code>函数重载</code>，由编译器确定的</li>
<li>具体实现：<ul>
<li>允许在同一个作用域中声明多个功能类似的同名函数</li>
<li>这些函数的参数列表、参数个数、参数类型、参数顺序不一样</li>
<li>注意不能通过返回值来区别重载</li>
</ul>
</li>
<li>实现原理：<ul>
<li>函数名修饰</li>
<li>编译过程<ul>
<li>预编译：把头文件中的函数声明拷贝到源文件，避免编译过程中语法分析找不到函数定义</li>
<li>编译：语法分析，同时进行符号汇总（函数名）</li>
<li>汇编：生成函数名和函数地址的映射，方便之后通过函数名找到函数定义的位置，从而执行函数</li>
<li>链接：将多个文件中的符号表汇总合并</li>
</ul>
</li>
<li>通过objdump -t *.o : _ZN+类长度+类名+函数名长度+函数名+E+类型首字母</li>
</ul>
</li>
</ul>
</li>
<li><code>动态多态</code><ul>
<li>实现方式：<code>虚函数重写</code>，由运行时确定的</li>
<li>具体实现：<ul>
<li>在基类的函数名前加上virtual关键字，在派生类中重写该函数</li>
<li>运行时将会根据对象的类型来调用相应的函数</li>
<li>如果对象的类型是基类，则调用基类的函数</li>
<li>如果对象的类型是派生类，这调用派生类的函数</li>
</ul>
</li>
<li>实现原理：<ul>
<li>早绑定：编译器编译时已经确定对象调用的函数的地址</li>
<li>晚绑定：若类使用了virtual函数，则编译器会为类生成虚函数表，他是一个一维数组，存放虚函数的地址。</li>
</ul>
</li>
<li>virtual关键字用于声明一个函数为虚函数。<strong>虚函数主要用于实现多态</strong>，即允许在派生类中重写(override)基类中的函数。虚函数表指针在构造函数中初始化。</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<ol start="2">
<li><p>虚函数表和虚函数表指针</p>
<ul>
<li>虚函数表<ul>
<li>what：<code>虚函数表</code>是一个存储类的<strong>虚函数地址</strong>的数组，每个包含虚函数的类或者从这样的类派生的类都有一个虚函数表。</li>
<li>how：虚函数表的内容在编译器编译的时候已经生成，当一个类的对象被创建时一个虚函数表也会被创建并与该对象关联。</li>
<li>why：虚函数表用于实现动态多态性。动态多态性允许我们通过基类指针调用派生类的函数。</li>
<li>where：虚函数表存放在全局数据区中的只读数据段中，每个对象的内存布局中都有一个指向虚函数表的指针。</li>
<li>when：有一个基类指针，并且想调用派生类的函数时，需要使用虚函数表。</li>
</ul>
</li>
<li>虚函数表指针：<ul>
<li>what：<code>虚函数表指针</code>是一个指向虚函数表（vtable）的指针，每个包含虚函数的类或者从这样的类派生的类的对象都有一个虚函数表指针。</li>
<li>when：对象构造的时候，在构造函数，将虚函数表的地址赋值给对象vptr。</li>
<li>how：继承下虚函数表指针赋值过程：<ul>
<li>如果类没有构造函数，则编译器为类生成默认构造函数，从而为类对象初始化vptr。</li>
<li>接着调用子类构造函数的时候，又将子类的虚函数表地址赋值给vptr。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<ol start="3">
<li><p>构造函数能否声明为虚函数？</p>
<p> 在C++中，构造函数不能声明为虚函数。这是因为虚函数的调用需要通过对象的虚函数表（vtable）来实现，而在对象构造期间，虚函数表尚未建立，因此无法通过虚函数表来调用构造函数。</p>
</li>
</ol>
<hr>
</details>



<h3 id="仿函数"><a href="#仿函数" class="headerlink" title="仿函数"></a>仿函数</h3><details>
    <summary>
        点击展开
    </summary>

<p>在C++中，仿函数（Functor）是一个行为类似函数的对象。它是一个类，该类重载了operator()运算符。因此，我们可以像调用函数一样调用这个类的对象。这就是为什么它被称为仿函数。仿函数可以扩展函数的功能，并且可以保存状态信息，具有很高的灵活性和可复用性。</p>
<p>仿函数在C++中有许多应用场景，以下是一些常见的应用场景：</p>
<ol>
<li><p>作为STL算法的参数：STL算法，如sort，transform等，通常接受一个函数或者仿函数作为参数。使用仿函数可以使得代码更加灵活和可重用。</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyComparator</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &gt; b; <span class="comment">// 降序排序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Add</span> &#123;</span><br><span class="line">    <span class="type">int</span> value; <span class="comment">// 保存要加的值</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Add</span>(<span class="type">int</span> val) : <span class="built_in">value</span>(val) &#123;&#125; <span class="comment">// 构造函数，初始化要加的值</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> x)</span> <span class="type">const</span> </span>&#123; <span class="comment">// 重载函数调用运算符</span></span><br><span class="line">        <span class="keyword">return</span> x + value; <span class="comment">// 返回加法操作的结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    std::<span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="built_in">MyComparator</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl; <span class="comment">// 输出：9 6 5 4 3 2 1 1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    std::<span class="built_in">transform</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), vec.<span class="built_in">begin</span>(), <span class="built_in">Add</span>(<span class="number">5</span>));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;vec: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : vec) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl; <span class="comment">// 输出：vec: 6 7 8 9 10</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>作为比较函数：在STL的数据结构，如set，map，priority_queue等，可以接受一个比较函数或者仿函数来自定义元素的排序方式。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Compare</span> : <span class="keyword">public</span> std::binary_function&lt;<span class="type">int</span>, <span class="type">int</span>, <span class="type">bool</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; a, <span class="type">const</span> <span class="type">int</span>&amp; b)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &gt; b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::priority_queue&lt;<span class="type">int</span>, std::vector&lt;<span class="type">int</span>&gt;, Compare&gt; pq;</span><br><span class="line"></span><br><span class="line">    pq.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">    pq.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    pq.<span class="built_in">push</span>(<span class="number">4</span>);</span><br><span class="line">    pq.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    pq.<span class="built_in">push</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Priority Queue: &quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; pq.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl; <span class="comment">// 输出：Priority Queue: 5 4 3 1 1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>在回调函数中：仿函数是类对象，可以包含成员变量，因此可以保存状态信息。这使得仿函数在执行函数调用时可以考虑到之前的状态，实现更复杂的功能。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个仿函数 AddWithState</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddWithState</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> state; <span class="comment">// 保存状态信息</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数，初始化状态信息</span></span><br><span class="line">    <span class="built_in">AddWithState</span>(<span class="type">int</span> initialState) : <span class="built_in">state</span>(initialState) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载函数调用运算符，将输入值与状态信息相加并返回</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> result = x + state;</span><br><span class="line">        state = result; <span class="comment">// 更新状态信息</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> initialState = <span class="number">0</span>; <span class="comment">// 初始状态信息为 0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 AddWithState 对象，将初始状态信息传入构造函数</span></span><br><span class="line">    <span class="function">AddWithState <span class="title">adder</span><span class="params">(initialState)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用仿函数进行加法操作，并将结果保存到 vec 中</span></span><br><span class="line">    std::<span class="built_in">transform</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), vec.<span class="built_in">begin</span>(), adder);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出每次加法操作的结果</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Resulting vector: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : vec) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>作为函数对象适配器的参数： 仿函数可以与函数对象适配器一起使用，实现更复杂的功能。例如，std::bind、std::function等可以与仿函数一起使用，实现函数的组合、筛选等操作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPredicate</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x % <span class="number">2</span> == <span class="number">0</span>; <span class="comment">// 判断是否为偶数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyPredicate predicate;</span><br><span class="line">    std::function&lt;<span class="type">bool</span>(<span class="type">int</span>)&gt; isEven = std::<span class="built_in">bind</span>(predicate, std::placeholders::_1);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">isEven</span>(<span class="number">3</span>) &lt;&lt; std::endl; <span class="comment">// 输出 0</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">isEven</span>(<span class="number">4</span>) &lt;&lt; std::endl; <span class="comment">// 输出 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details></li>
</ol>
<h3 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h3><details>
    <summary>
        点击展开
    </summary>

<p><code>static</code> 关键字在C++中具有多种用途，用于定义静态变量、静态函数和静态常量，实现了在程序运行期间共享状态信息、提高函数的调用效率等功能。</p>
<ol>
<li><strong>静态变量（Static Variables）：</strong> 在函数内部或类内部声明的变量可以使用 <code>static</code> 关键字修饰，表示静态变量。静态变量在程序的整个生命周期内存在，不会因为程序的多次调用而被重复创建和销毁。函数内部的静态变量在函数执行时被初始化，但只会初始化一次，其值在函数调用之间保持不变。类内部的静态成员变量在类的所有对象中共享，也被称为类的静态成员。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// 静态局部变量</span></span><br><span class="line">    count++;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Function called &quot;</span> &lt;&lt; count &lt;&lt; <span class="string">&quot; times.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> instanceCount; <span class="comment">// 类的静态成员变量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> MyClass::instanceCount = <span class="number">0</span>; <span class="comment">// 静态成员变量的初始化</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(); <span class="comment">// 输出：Function called 1 times.</span></span><br><span class="line">    <span class="built_in">func</span>(); <span class="comment">// 输出：Function called 2 times.</span></span><br><span class="line"></span><br><span class="line">    MyClass obj1;</span><br><span class="line">    MyClass obj2;</span><br><span class="line">    MyClass::instanceCount++;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Number of instances: &quot;</span> &lt;&lt; MyClass::instanceCount &lt;&lt; std::endl; <span class="comment">// 输出：Number of instances: 1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>静态函数（Static Functions）：</strong> 在类内部声明的函数可以使用 <code>static</code> 关键字修饰，表示静态函数。静态函数不依赖于任何特定的对象实例，可以直接通过类名来调用。静态函数不能访问类的非静态成员，因为它们不依赖于对象的状态。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">staticFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Static function called.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass::<span class="built_in">staticFunction</span>(); <span class="comment">// 输出：Static function called.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>静态常量（Static Constants）：</strong> 在类内部声明的常量可以使用 <code>static</code> 和 <code>const</code> 关键字修饰，表示静态常量。静态常量在类的所有对象中共享，且不可修改。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> MAX_VALUE = <span class="number">100</span>; <span class="comment">// 静态常量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Max value: &quot;</span> &lt;&lt; MyClass::MAX_VALUE &lt;&lt; std::endl; <span class="comment">// 输出：Max value: 100</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>



<h3 id="左值引用-amp-右值引用"><a href="#左值引用-amp-右值引用" class="headerlink" title="左值引用 &amp; 右值引用"></a>左值引用 &amp; 右值引用</h3><details>
    <summary>
        点击展开
    </summary>

<p>在C++中，左值引用（lvalue reference）和右值引用（rvalue reference）是与变量或表达式的生命周期和使用方式相关联的两种引用类型。</p>
<ol>
<li><strong>左值引用（lvalue reference）：</strong> 左值引用绑定到具有名称的对象（即左值），并且可以延长其生命周期。左值引用通常用于传递可修改的对象，也可以用于函数重载和模板推断等场景。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">5</span>; <span class="comment">// x 是左值</span></span><br><span class="line">    <span class="type">int</span>&amp; lref = x; <span class="comment">// lref 是左值引用，绑定到 x</span></span><br><span class="line">    lref = <span class="number">10</span>; <span class="comment">// 修改 x 的值</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x = &quot;</span> &lt;&lt; x &lt;&lt; std::endl; <span class="comment">// 输出：x = 10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>右值引用（rvalue reference）：</strong> 右值引用绑定到临时对象或表达式（即右值），并且可以延长其生命周期。右值引用通常用于移动语义、完美转发和实现移动构造函数和移动赋值运算符等场景。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Constructor&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Destructor&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">const</span> MyClass&amp;) &#123; std::cout &lt;&lt; <span class="string">&quot;Copy constructor&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="built_in">MyClass</span>(MyClass&amp;&amp;) &#123; std::cout &lt;&lt; <span class="string">&quot;Move constructor&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">MyClass <span class="title">createObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">MyClass</span>(); <span class="comment">// 返回临时对象，是右值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass&amp;&amp; rref = <span class="built_in">createObject</span>(); <span class="comment">// rref 是右值引用，绑定到临时对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>createObject()</code> 函数返回一个临时对象，因此返回值是一个右值。在 <code>main()</code> 函数中，我们使用右值引用 <code>MyClass&amp;&amp; rref</code> 来绑定这个临时对象，延长了它的生命周期，从而使得对象在 <code>main()</code> 函数作用域内仍然有效。右值引用的绑定延长了对象的生命周期，可以用于实现移动语义，避免了临时对象的不必要拷贝。</p>
<ol start="3">
<li><strong>区分左值引用和右值引用：</strong></li>
</ol>
<p>左值引用和右值引用在语义上有很大的差异，左值引用通常用于可修改的对象，右值引用则通常用于临时对象或表达式，并且可以延长其生命周期以实现移动语义。区分左值引用和右值引用的关键在于理解它们绑定到的对象的生命周期和可修改性。</p>
<ul>
<li>左值引用（lvalue reference）绑定到具有名称的对象（即左值），例如变量或对象的名称。</li>
<li>右值引用（rvalue reference）绑定到临时对象或表达式（即右值），例如临时对象、函数返回值、字面量等。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">5</span>; <span class="comment">// x 是左值</span></span><br><span class="line"><span class="type">int</span>&amp; lref = x; <span class="comment">// lref 是左值引用，绑定到 x</span></span><br><span class="line"><span class="type">int</span>&amp;&amp; rref = <span class="number">10</span>; <span class="comment">// rref 是右值引用，绑定到临时对象</span></span><br></pre></td></tr></table></figure>


<ol start="4">
<li><strong>右值引用的使用场景：</strong></li>
</ol>
<ul>
<li><code>移动语义</code>：右值引用常用于实现移动构造函数和移动赋值运算符，从而避免了不必要的深拷贝，提高了效率。</li>
<li><code>完美转发</code>：右值引用还可用于实现完美转发，将参数以原样传递给其他函数，无需进行多余的拷贝或移动操作。</li>
<li><code>临时对象的延长生命周期</code>：通过右值引用，可以延长临时对象的生命周期，使其在函数调用结束后仍然有效。</li>
</ul>
<p>下面是一些右值引用的更多使用场景和示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 移动语义示例：移动构造函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyVector</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; data;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyVector</span>(std::vector&lt;<span class="type">int</span>&gt;&amp;&amp; other) : <span class="built_in">data</span>(std::<span class="built_in">move</span>(other)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Move constructor called.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 完美转发示例：使用右值引用进行完美转发</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">forward</span><span class="params">(T&amp;&amp; t, U&amp;&amp; u)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">process</span>(std::forward&lt;T&gt;(t), std::forward&lt;U&gt;(u));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span>&amp;&amp; x, <span class="type">int</span>&amp;&amp; y)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Processing: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 移动语义示例：移动构造函数</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; temp = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="function">MyVector <span class="title">mv</span><span class="params">(std::move(temp))</span></span>; <span class="comment">// 调用移动构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 完美转发示例：使用右值引用进行完美转发</span></span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line">    forward(std::<span class="built_in">move</span>(a), std::<span class="built_in">move</span>(b)); <span class="comment">// 调用 process 函数并进行完美转发</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拓展阅读：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://modern-cpp.readthedocs.io/zh-cn/latest/rvalue-ref.html">Understanding Modern C++：rvalue reference</a></li>
<li><a target="_blank" rel="noopener" href="https://cntransgroup.github.io/EffectiveModernCppChinese/5.RRefMovSemPerfForw/item24.html">Effective Modern C++ Item 24: Distinguish universal references from rvalue references</a></li>
</ul>
</details>







<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a><center>设计模式</center></h2><h3 id="日常工作中用到了那些设计模式？"><a href="#日常工作中用到了那些设计模式？" class="headerlink" title="日常工作中用到了那些设计模式？"></a>日常工作中用到了那些设计模式？</h3><details>
    <summary>
        点击展开
    </summary>

<ol>
<li><code>单例模式</code>是一种<code>创建型设计模式</code>，它保证一个类只有一个实例，并提供一个全局访问点。单例模式的优点包括：</li>
</ol>
<ul>
<li><p>控制实例数目：单例模式可以确保一个类只有一个实例，避免了因为多次创建实例而导致的资源浪费。</p>
</li>
<li><p>全局访问点：单例模式提供了一个全局访问点，这使得我们可以在任何地方都能访问到这个实例。</p>
</li>
<li><p>共享资源：由于单例模式只有一个实例，所以可以方便地用于共享资源，例如配置信息，缓存等。</p>
</li>
</ul>
<p>注意，虽然单例模式有这些优点，但也有一些缺点，例如它可能导致代码的耦合度增加，且在多线程环境下需要特别注意线程安全问题。因此，在使用单例模式时需要根据具体的需求和场景进行权衡。</p>
<ol start="2">
<li><code>代理模式</code>是一种<code>结构型设计模式</code>，它提供了一个对象来代替另一个对象控制对原对象的访问。代理对象可以在客户端和目标对象之间起到中介的作用，并添加额外的功能。</li>
</ol>
<p>代理模式主要包含以下三种类型：</p>
<ul>
<li><p>虚拟代理：在需要时创建开销很大的对象。通过它来存储实例化需要很长时间的真实对象的一些信息。</p>
</li>
<li><p>保护代理：控制真实对象访问的权限。</p>
</li>
<li><p>远程代理：为一个对象在不同的地址空间提供局部代表。</p>
</li>
</ul>
<p>代理模式通常包含以下几个角色：</p>
<ul>
<li><p>抽象主题（Subject）：定义了 RealSubject 和 Proxy 共用接口，这样在任何使用 RealSubject 的地方都可以使用 Proxy。</p>
</li>
<li><p>真实主题（RealSubject）：定义了 Proxy 所代表的真实实体。</p>
</li>
<li><p>代理（Proxy）：保存一个引用使得代理可以访问实体，并提供一个与 Subject 的接口相同的接口。</p>
</li>
</ul>
<p>以下是一个简单的 C++ 代理模式的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">request</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RealSubject</span> : <span class="keyword">public</span> Subject &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">request</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;RealSubject: Handling request.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Proxy</span> : <span class="keyword">public</span> Subject &#123;</span><br><span class="line">    RealSubject* real_subject_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Proxy</span>(RealSubject* real_subject) : <span class="built_in">real_subject_</span>(<span class="keyword">new</span> <span class="built_in">RealSubject</span>(*real_subject)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">request</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;<span class="built_in">checkAccess</span>()) &#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;real_subject_-&gt;<span class="built_in">request</span>();</span><br><span class="line">            <span class="keyword">this</span>-&gt;<span class="built_in">logAccess</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkAccess</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Some real checks should go here.</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Proxy: Checking access prior to firing a real request.\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">logAccess</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Proxy: Logging the time of request.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<ol start="3">
<li>观察者模式是一种<code>行为型设计模式</code>，定义了对象之间的一对多依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知并自动更新。</li>
</ol>
<p>这种设计模式通常用于需要实现复杂的事件处理或消息传递系统时。例如，GUI库、游戏、实时系统、分布式系统等都可能使用观察者模式。</p>
<p>观察者模式有以下优点：</p>
<ul>
<li><p>解耦：观察者模式可以解耦观察者和被观察者之间的关系，使得它们可以独立变化和复用。</p>
</li>
<li><p>广播通信：被观察者会向所有的观察者广播通知，这是一种一对多的关系。</p>
</li>
<li><p>动态关系：可以在运行时动态地添加和删除观察者，改变观察者与被观察者之间的关系。</p>
</li>
</ul>
<p>然而，观察者模式也有一些缺点：</p>
<ul>
<li><p>过度使用或误用：如果过度使用或误用观察者模式，可能会导致程序难以理解和维护。例如，如果一个观察者的更新操作引发了另一个更新操作，可能会导致复杂的链式更新。</p>
</li>
<li><p>假设同步通知：观察者模式通常假设观察者在接收到通知后能立即进行更新，但在某些情况下，这可能不是可行的。例如，如果观察者的更新操作需要很长时间，或者需要从网络获取数据，那么这种同步通知的方式可能会导致程序阻塞。</p>
</li>
<li><p>可能引发的性能问题：如果有大量的观察者，或者观察者的处理逻辑很复杂，那么通知所有观察者可能会花费很长时间。</p>
</li>
</ul>
<p>拓展阅读：<a target="_blank" rel="noopener" href="https://subingwen.cn/design-patterns/index.html">C++设计模式</a></p>
</details>



<h3 id="如何实现一个线程安全的单例模式？"><a href="#如何实现一个线程安全的单例模式？" class="headerlink" title="如何实现一个线程安全的单例模式？"></a>如何实现一个线程安全的单例模式？</h3><details>
    <summary>
        点击展开
    </summary>

<p><code>线程安全</code>：在拥有共享数据的多条线程并行执行的程序中，线程安全的代码会通过同步机制保证各个线程都可以正常且正确的执行，不会出现数据污染等意外情况。</p>
<p>单例模式指在整个系统生命周期里，保证一个类只能产生一个实例，确保该类的唯一性。</p>
<p>单例模式可以分为<code>懒汉式</code>和<code>饿汉式</code>，两者之间的区别在于创建实例的时间不同：</p>
<p><code>懒汉式</code>：指系统运行中，实例并不存在，只有当需要使用该实例时，才会去创建并使用实例。（这种方式要考虑线程安全）<br><code>饿汉式</code>：指系统一运行，就初始化创建实例，当需要时，直接调用即可。（本身就线程安全，没有多线程的问题）</p>
<p>如何实现线程安全：</p>
<ol>
<li><p><code>普通的懒汉式单例</code>没有加锁，是线程不安全的，当线程并发时会创建多个实例。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> Singleton* instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造函数，防止外部创建实例</span></span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 获取单例对象实例的静态方法</span></span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton* Singleton::instance = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在多线程环境下可能会创建多个实例</span></span><br><span class="line">    Singleton* singleton1 = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line">    Singleton* singleton2 = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Singleton 1 address: &quot;</span> &lt;&lt; singleton1 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Singleton 2 address: &quot;</span> &lt;&lt; singleton2 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p><code>加锁的懒汉式单例</code>，<code>std::unique_lock&lt;std::mutex&gt; lock(m_Mutex);</code> 加了互斥锁的普通懒汉式是线程安全的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> Singleton* instance;</span><br><span class="line">    <span class="type">static</span> std::mutex mutex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造函数，防止外部创建实例</span></span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 获取单例对象实例的静态方法</span></span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton* Singleton::instance = <span class="literal">nullptr</span>;</span><br><span class="line">std::mutex Singleton::mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Singleton* singleton1 = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line">    Singleton* singleton2 = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Singleton 1 address: &quot;</span> &lt;&lt; singleton1 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Singleton 2 address: &quot;</span> &lt;&lt; singleton2 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>双重检查锁定的懒汉单例</code>，通过在实例化单例对象时进行双重检查来避免了不必要的加锁，从而提高了一定的性能。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> Singleton* instance;</span><br><span class="line">    <span class="type">static</span> std::mutex mutex;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 私有构造函数，防止外部创建实例</span></span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 获取单例对象实例的静态方法</span></span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 第一次检查：判断实例是否已经存在，避免不必要的加锁</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="comment">// 加锁，确保只有一个线程可以创建实例</span></span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第二次检查：在获取锁后再次判断实例是否已经存在</span></span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁止拷贝构造函数和赋值运算符，防止通过拷贝创建新实例</span></span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化静态成员变量</span></span><br><span class="line">Singleton* Singleton::instance = <span class="literal">nullptr</span>;</span><br><span class="line">std::mutex Singleton::mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取单例对象实例</span></span><br><span class="line">    Singleton* singleton = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Singleton address: &quot;</span> &lt;&lt; singleton &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>内部静态变量的懒汉单例</code>，利用了局部静态变量的初始化是线程安全的这一特性，因为C++11保证了局部静态变量的初始化在并发情况下只会被执行一次，线程安全，且不需要使用锁，因此性能最好。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 私有构造函数，防止外部创建实例</span></span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 获取单例对象实例的静态方法</span></span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">static</span> Singleton instance;</span><br><span class="line">        <span class="keyword">return</span> &amp;instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Singleton* singleton1 = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line">    Singleton* singleton2 = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Singleton 1 address: &quot;</span> &lt;&lt; singleton1 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Singleton 2 address: &quot;</span> &lt;&lt; singleton2 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>参考链接：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaolincoding/p/11437231.html">C++ 线程安全的单例模式总结 - 小林coding - 博客园</a></li>
</ul>
</details>



<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a><center>操作系统</center></h2><h3 id="死锁的「产生」「预防」「避免」「检测」「解除」"><a href="#死锁的「产生」「预防」「避免」「检测」「解除」" class="headerlink" title="死锁的「产生」「预防」「避免」「检测」「解除」"></a>死锁的「产生」「预防」「避免」「检测」「解除」</h3><details>
    <summary>
        点击展开
    </summary>

<ol>
<li>产生</li>
</ol>
<p>死锁是在多任务环境中，两个或更多的进程无限期地等待资源，而这些资源又被等待的进程所占有。死锁通常是由于多个进程之间的资源竞争和进程间的不恰当同步造成的。</p>
<p>死锁的产生需要满足四个条件，也被称为死锁的四个必要条件：</p>
<ul>
<li><p>互斥条件：一个资源每次只能被一个进程使用。</p>
</li>
<li><p>占有与等待条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</p>
</li>
<li><p>不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺。</p>
</li>
<li><p>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。</p>
</li>
</ul>
<ol start="2">
<li>预防</li>
</ol>
<p>预防死锁就是破坏上面四个条件任意一个，但是实现很难：</p>
<ul>
<li><p>破坏互斥条件：允许某些资源同时被多个进程访问。但是有些资源本身并不具有这种属性，因此这种方案实用性有限。</p>
</li>
<li><p>破坏占有并等待条件：实行资源预先分配策略，当一个进程开始运行之前，必须一次性向系统申请它所需要的全部资源，否则不运行；或者只允许进程在没有占用资源的时候才能申请资源（申请资源前先释放占有的资源）</p>
<p>缺点：很多时候无法预知一个进程所需的全部资源；同时，会降低资源利用率，降低系统的并发性。</p>
</li>
<li><p>破坏非抢占条件：允许进程强行抢占被其它进程占有的资源。会降低系统性能。</p>
</li>
<li><p>破坏循环等待条件：对所有资源统一编号，所有进程对资源的请求必须按照序号递增的顺序提出，即只有占有了编号较小的资源才能申请编号较大的资源。这样避免了占有大号资源的进程去申请小号资源，各个进程申请资源的顺序都是从小到大，就不会有环了</p>
</li>
</ul>
<ol start="3">
<li>避免</li>
</ol>
<p>允许系统中同时存在四个必要条件，但是每当进程提出资源申请时，系统要分析满足该资源请求后，系统是否会发生死锁，若不会发生则实施分配，否则拒绝分配。银行家算法实现了这个过程。</p>
<ol start="4">
<li>检测</li>
</ol>
<p>画出资源分配图，检测是否存在环路。检测环路前要将资源分配图化简，化简的原理是“一个目前占有运行所需的资源的进程，迟早能够执行完成释放资源”。因此，可以从“进程—资源分配图”中找到一个既不阻塞又非孤立的进程，删除所有与该进程相连的有向边，回收资源，使之成为孤立结点，然后将所回收的资源分配给其它进程。循环此过程，直到无法化简。若仍存在环路，则该系统目前处于死锁状态。</p>
<p>检测到死锁后，需要解除死锁。</p>
<ol start="5">
<li>解除</li>
</ol>
<p>破坏除了“互斥条件”之外的其他三个条件：</p>
<ul>
<li><p>回退执行：系统定期对各个进程进行检查，将检查点的有关信息写入文件。死锁时，让某占有必要资源的进程回退到取得资源之前的一个检查点，释放的资源分配给一个死锁进程（破坏“占有且等待”）</p>
</li>
<li><p>抢占资源：剥夺占有进程的资源，分配给另外某些进程，直至死锁环路被打破（破坏“不可抢占”）</p>
</li>
<li><p>杀掉进程：一次终止一个进程，直至消除死锁环路（破坏“循环等待”）</p>
</li>
</ul>
<p>拓展阅读：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://imageslr.com/2020/07/08/tech-interview#%E6%AD%BB%E9%94%81%E7%9A%84%E9%A2%84%E9%98%B2%E6%A3%80%E6%B5%8B%E9%81%BF%E5%85%8D%E8%A7%A3%E9%99%A4">面试题】技术面试题汇总 🔥 死锁的预防检测避免解除</a></li>
</ul>
</details>



<h3 id="如何由虚拟地址映射到物理地址"><a href="#如何由虚拟地址映射到物理地址" class="headerlink" title="如何由虚拟地址映射到物理地址"></a>如何由虚拟地址映射到物理地址</h3><details>
    <summary>
        点击展开
    </summary>

<p>物理地址和虚拟地址是操作系统<code>内存管理</code>中的两个重要概念。</p>
<ol>
<li><p><strong>物理地址：</strong> 物理地址是实际存储在计算机内存芯片上的地址，也称为实际地址或真实地址。它是硬件所理解和处理的地址，用于直接访问计算机的内存单元。</p>
</li>
<li><p><strong>虚拟地址：</strong> 虚拟地址是由处理器（CPU）生成的地址，用于访问计算机内存中的数据。它是相对于程序而言的一种抽象地址，程序只能看到和使用虚拟地址，而不知道实际的物理内存地址。虚拟地址空间通常比物理内存空间大得多，因为它可以包含操作系统和其他应用程序的地址空间。</p>
</li>
</ol>
<hr>
<p>为什么要将虚拟地址映射到物理地址？</p>
<ul>
<li><strong>Why？</strong>：将虚拟地址映射到物理地址的主要目的是实现内存管理和地址空间隔离。通过虚拟地址，操作系统可以为每个程序提供独立的地址空间，使得每个程序都认为自己拥有整个内存空间，从而实现了地址空间的隔离和保护。</li>
</ul>
<hr>
<p>什么时候会发生虚拟地址到物理地址之间的映射？</p>
<ul>
<li><strong>When？</strong>：虚拟地址到物理地址的映射通常发生在计算机执行程序时进行内存访问时。具体来说，当程序访问内存中的数据时，处理器会生成虚拟地址，并通过硬件中的地址转换单元（MMU）将虚拟地址映射到物理地址。</li>
</ul>
<hr>
<p>谁来处理虚拟地址到物理地址的映射？</p>
<ul>
<li><strong>Who？</strong>：虚拟地址到物理地址的映射是由硬件中的地址转换单元（MMU）来处理的。MMU是计算机体系结构中的一个重要组成部分，负责处理内存访问请求，并将虚拟地址映射到物理地址。</li>
</ul>
<hr>
<p>如何处理虚拟地址到物理地址的映射？</p>
<ul>
<li><strong>How？</strong>：虚拟地址到物理地址的映射过程通常包括以下几个步骤：<ol>
<li><strong>页表查找：</strong> MMU根据虚拟地址的高位页号来查找页表。</li>
<li><strong>页表项解析：</strong> 一旦找到了页表中对应的页表项，MMU会解析该项以获取物理地址页面帧号。</li>
<li><strong>偏移量添加：</strong> MMU将虚拟地址中的偏移量与物理地址页面帧号相结合，得到最终的物理地址。</li>
<li><strong>TLB缓存（可选）：</strong> 为了加速地址转换过程，MMU可能会使用一个高速缓存，称为翻译后备缓冲器（TLB）。TLB中存储了最近的一些虚拟地址到物理地址的映射关系，如果TLB中找到了对应的映射，MMU会直接使用它而不必查询页表。</li>
<li><strong>缺页处理（可选）：</strong> 如果在查询页表或TLB时发现对应的页面不在内存中（即缺页），则会触发一个缺页中断。在这种情况下，操作系统会将缺失的页面从磁盘加载到内存中，并更新页表或TLB以反映这个变化。</li>
</ol>
</li>
</ul>
<hr>
<p>总的来说，虚拟地址到物理地址的映射是由硬件中的MMU处理的，它通过页表查找、解析页表项、偏移量添加等步骤完成映射过程。TLB缓存和缺页处理是在这个过程中的一些优化和异常处理机制。</p>
<p>参考文档：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://rcore-os.cn/rCore-Tutorial-deploy/docs/lab-3/guide/part-1.html">从虚拟内存到物理内存</a></li>
</ul>
</details>




<h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a><center>计算机网络</center></h2><h3 id="三次握手和四次挥手的过程"><a href="#三次握手和四次挥手的过程" class="headerlink" title="三次握手和四次挥手的过程"></a>三次握手和四次挥手的过程</h3><details>
    <summary>
        点击展开
    </summary>

<p>TCP&#x2F;IP协议中的三次握手和四次挥手是建立和关闭TCP连接时的重要过程。</p>
<h4 id="三次握手（Three-Way-Handshake）："><a href="#三次握手（Three-Way-Handshake）：" class="headerlink" title="三次握手（Three-Way Handshake）："></a>三次握手（Three-Way Handshake）：</h4><ol>
<li><p><strong>客户端向服务器发送连接请求（SYN）：</strong> 客户端发送一个带有SYN（同步序列编号）标志的TCP数据包给服务器，说明客户端要建立连接，并选择一个初始序列号。</p>
</li>
<li><p><strong>服务器响应连接请求（SYN + ACK）：</strong> 如果服务器同意连接，会发送一个带有SYN和ACK（确认）标志的TCP数据包给客户端，以确认客户端的连接请求，并选择一个初始序列号作为回应。</p>
</li>
<li><p><strong>客户端确认连接（ACK）：</strong> 最后，客户端再发送一个带有ACK标志的数据包给服务器，表示连接请求已收到确认。此时，TCP连接已经建立，双方可以开始进行数据传输。</p>
</li>
</ol>
<h4 id="四次挥手（Four-Way-Handshake）："><a href="#四次挥手（Four-Way-Handshake）：" class="headerlink" title="四次挥手（Four-Way Handshake）："></a>四次挥手（Four-Way Handshake）：</h4><ol>
<li><p><strong>发起关闭连接请求（FIN）：</strong> 当客户端或服务器决定关闭连接时，会发送一个带有FIN（结束）标志的TCP数据包给对方，表示不再向对方发送数据。</p>
</li>
<li><p><strong>对关闭请求进行确认（ACK）：</strong> 收到关闭请求的一方会发送一个带有ACK标志的TCP数据包作为确认，表示收到了关闭请求。</p>
</li>
<li><p><strong>关闭连接（FIN）：</strong> 接收到关闭请求并确认后，对方也会发送一个带有FIN标志的TCP数据包给发起关闭的一方，表示同意关闭连接。</p>
</li>
<li><p><strong>确认关闭（ACK）：</strong> 最后，发起关闭的一方收到对方的确认后，也会发送一个带有ACK标志的TCP数据包给对方，表示确认收到关闭请求。此时，TCP连接彻底关闭，双方不再传输数据。</p>
</li>
</ol>
<p>这些过程确保了在TCP连接的建立和关闭过程中，双方都能够正确地进行通信并进行必要的确认和处理，以保证数据的可靠传输。</p>
<p>参考链接：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904005315854343">https://juejin.cn/post/6844904005315854343</a></li>
<li><a target="_blank" rel="noopener" href="https://imageslr.com/2020/07/07/tcp-shake-wave">https://imageslr.com/2020/07/07/tcp-shake-wave</a></li>
</ul>
</details>


<h3 id="TCP-与-UDP-的对比"><a href="#TCP-与-UDP-的对比" class="headerlink" title="TCP 与 UDP 的对比"></a>TCP 与 UDP 的对比</h3><details>
    <summary>
        点击展开
    </summary>

<table>
<thead>
<tr>
<th>方面</th>
<th>TCP</th>
<th>UDP</th>
</tr>
</thead>
<tbody><tr>
<td>连接性</td>
<td>面向连接</td>
<td>无连接</td>
</tr>
<tr>
<td>可靠性</td>
<td>提供可靠的数据传输</td>
<td>不提供可靠性保证</td>
</tr>
<tr>
<td>传输方式</td>
<td>面向字节流</td>
<td>面向数据报</td>
</tr>
<tr>
<td>传输距离</td>
<td>适用于局域网和广域网</td>
<td>适用于局域网</td>
</tr>
<tr>
<td>双工性</td>
<td>全双工</td>
<td>可以是全双工、半双工或单工</td>
</tr>
<tr>
<td>流量控制&#x2F;拥塞控制</td>
<td>提供流量控制和拥塞控制</td>
<td>不提供流量控制和拥塞控制</td>
</tr>
<tr>
<td>应用场景</td>
<td>网页浏览、文件传输、电子邮件等</td>
<td>音频、视频流媒体、在线游戏等</td>
</tr>
<tr>
<td>应用层协议</td>
<td>HTTP、HTTPS、FTP、SMTP等</td>
<td>DNS、DHCP、TFTP、SNMP等</td>
</tr>
</tbody></table>
</details>




<h3 id="POST和GET的区别"><a href="#POST和GET的区别" class="headerlink" title="POST和GET的区别"></a>POST和GET的区别</h3><details>
    <summary>
        点击展开
    </summary>

<table>
<thead>
<tr>
<th>方面</th>
<th>POST</th>
<th>GET</th>
</tr>
</thead>
<tbody><tr>
<td>数据位置</td>
<td>请求体中发送数据</td>
<td>URL中发送数据</td>
</tr>
<tr>
<td>数据长度限制</td>
<td>无限制</td>
<td>有限制（通常受浏览器或服务器限制 2KB）</td>
</tr>
<tr>
<td>安全性</td>
<td>更安全，数据不会暴露在URL中</td>
<td>较不安全，数据会暴露在URL中</td>
</tr>
<tr>
<td>应用</td>
<td>添加 &#x2F; 修改服务器的数据</td>
<td>获取服务器的指定数据</td>
</tr>
<tr>
<td>历史记录</td>
<td>不可以</td>
<td>可以保存在历史记录中或者收藏为书签</td>
</tr>
<tr>
<td>缓存</td>
<td>不可被缓存</td>
<td>可以被缓存</td>
</tr>
<tr>
<td>数据类型</td>
<td>可以发送多种类型的数据（二进制、文本等）</td>
<td>仅能发送ASCII字符</td>
</tr>
<tr>
<td>请求类型</td>
<td>用于向服务器提交数据，用于创建资源</td>
<td>用于从服务器获取数据，用于读取资源</td>
</tr>
<tr>
<td>幂等性</td>
<td>非幂等，会对服务器资源进行改变</td>
<td>幂等（同样的请求发送多次会产生相同的结果）</td>
</tr>
<tr>
<td>安全性</td>
<td>需要一定的安全性措施</td>
<td>相对较不需要安全性措施</td>
</tr>
<tr>
<td>可见性</td>
<td>数据不会暴露在URL中</td>
<td>数据会暴露在URL中</td>
</tr>
<tr>
<td>后退 &#x2F; 刷新</td>
<td>后退或者刷新的时候，GET是无害的</td>
<td>后退或者刷新的时候，POST会重新提交表单</td>
</tr>
</tbody></table>
</details>




<h2 id="数据结构和算法"><a href="#数据结构和算法" class="headerlink" title="数据结构和算法"></a><center>数据结构和算法</center></h2><h3 id="阐述堆排序中「建堆」「调整」和「删除」的过程。"><a href="#阐述堆排序中「建堆」「调整」和「删除」的过程。" class="headerlink" title="阐述堆排序中「建堆」「调整」和「删除」的过程。"></a>阐述堆排序中「建堆」「调整」和「删除」的过程。</h3><details>
    <summary>
        点击展开
    </summary>

<p>建堆、调整和删除是堆操作的三个主要步骤。以下是这三个步骤的简要描述：</p>
<ul>
<li><p><strong>建堆</strong>：建堆是将一个无序的数组构建成一个堆的过程。对于一个完全二叉树（堆就是一个完全二叉树），从最后一个非叶子节点开始，对每一个非叶子节点进行下沉操作（即调整操作），直到根节点。这个过程是O(n)的复杂度。</p>
</li>
<li><p><strong>调整</strong>：调整是保持堆属性的过程。对于大顶堆，如果某个节点的值小于其子节点，那么就需要将这个节点和它的最大的子节点进行交换，然后继续对交换后的子节点进行调整，直到这个节点的值大于其所有子节点的值。对于小顶堆，调整的过程类似，只是比较和交换的条件相反。</p>
</li>
<li><p><strong>删除</strong>：删除通常是删除堆顶元素。删除堆顶元素后，为了保持堆的属性，通常的做法是将最后一个元素移动到堆顶，然后进行调整。这个过程是O(log n)的复杂度，因为可能需要调整的层数等于堆的高度。</p>
</li>
</ul>
<p>详见<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/kth-largest-element-in-an-array">LeetCode 215.</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinHeap</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; data;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">siftUp</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(i &gt; <span class="number">0</span> &amp;&amp; data[(i - <span class="number">1</span>) / <span class="number">2</span>] &gt; data[i]) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(data[(i - <span class="number">1</span>) / <span class="number">2</span>], data[i]);</span><br><span class="line">            i = (i - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">siftDown</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">2</span> * i + <span class="number">1</span> &lt; data.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> left = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> right = <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> j = left;</span><br><span class="line">            <span class="keyword">if</span>(right &lt; data.<span class="built_in">size</span>() &amp;&amp; data[right] &lt; data[left]) &#123;</span><br><span class="line">                j = right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(data[i] &lt;= data[j]) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">swap</span>(data[i], data[j]);</span><br><span class="line">            i = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        data.<span class="built_in">push_back</span>(val);</span><br><span class="line">        <span class="built_in">siftUp</span>(data.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        data[<span class="number">0</span>] = data.<span class="built_in">back</span>();</span><br><span class="line">        data.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="built_in">siftDown</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findKthLargest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        MinHeap q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num: nums) &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(num);</span><br><span class="line">            <span class="keyword">if</span>(q.<span class="built_in">size</span>() &gt; k) &#123;</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</details>



<h3 id="阐述字典序Trie这种数据类型。"><a href="#阐述字典序Trie这种数据类型。" class="headerlink" title="阐述字典序Trie这种数据类型。"></a>阐述字典序Trie这种数据类型。</h3><details>
    <summary>
        点击展开
    </summary>

<p>What（什么）：字典序，也称为词典序或者字母序，是一种排序方法，它按照字母或者数字的顺序进行排序，就像在字典中查找单词一样。</p>
<p>Who（谁）：程序员和数据科学家经常需要使用字典序，例如在处理字符串或者文本数据时，可能会用到字典序。在数据库查询中，也常常需要按照字典序进行排序。</p>
<p>When（何时）：当需要对字符串或者文本数据进行排序，或者需要在数据库中进行查询时，可能会用到字典序。</p>
<p>Where（何地）：字典序可以在任何需要排序或者查询的地方使用，例如在编程语言中处理字符串，或者在数据库中进行查询。</p>
<p>Why（为什么）：字典序可以帮助我们按照一定的顺序组织和查找数据，使得数据更容易被理解和处理。</p>
<p>How（如何）：在大多数编程语言中，都有内置的字符串比较函数，可以直接用来实现字典序。如果需要自定义字典序，可以使用数据结构（例如Trie）或者算法（例如字典序的下一个排列算法）来实现。</p>
<p>实现方式：用前缀树实现字典序</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TrieNode</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TrieNode* children[<span class="number">26</span>];</span><br><span class="line">    <span class="type">bool</span> isEndOfWord;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">TrieNode</span>() &#123;</span><br><span class="line">        isEndOfWord = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">            children[i] = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TrieNode* root;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Trie</span>() &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        TrieNode* node = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : word) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;children[c - <span class="string">&#x27;a&#x27;</span>] == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                node-&gt;children[c - <span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;children[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;isEndOfWord = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        TrieNode* node = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : word) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;children[c - <span class="string">&#x27;a&#x27;</span>] == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;children[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node != <span class="literal">nullptr</span> &amp;&amp; node-&gt;isEndOfWord;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">startsWith</span><span class="params">(string prefix)</span> </span>&#123;</span><br><span class="line">        TrieNode* node = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : prefix) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;children[c - <span class="string">&#x27;a&#x27;</span>] == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;children[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node != <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面这个Trie实现支持插入、查找和前缀查找操作。每个TrieNode包含一个指向26个子节点的指针数组（对应26个英文字母）和一个标记该节点是否为一个单词的结束的布尔值。插入操作是将一个单词的每个字符按顺序插入到Trie中，查找操作是检查一个单词是否存在于Trie中，前缀查找操作是检查一个前缀是否存在于Trie中。</p>
</details>


<h3 id="位运算拾疑"><a href="#位运算拾疑" class="headerlink" title="位运算拾疑"></a>位运算拾疑</h3><details>
    <summary>
        点击展开
    </summary>

<p>程序中的所有数在计算机内存中都是以二进制的形式储存的。位运算说到底，就是直接对整数在内存中的二进制位进行操作。使用位运算，主要目的是节约内存，使你的程序速度更快，还有就是对内存要求苛刻的地方使用。</p>
<p>位运算在面试中的“初衷”是考察面试者的基本功，但不幸的是，位运算所考察的知识点，大部分属于知道就知道, 不知道不知道的类型。所以有必要先知道一下。</p>
<ol>
<li><p><code>按位与（&amp;）</code>：将两个数的对应位进行与操作，如果两个数的对应位都为1，则结果为1，否则为0。常用于清零特定位、判断某个位是否为1等操作。</p>
</li>
<li><p><code>按位或（|）</code>：将两个数的对应位进行或操作，如果两个数的对应位中有一个为1，则结果为1，否则为0。常用于将特定位设置为1。</p>
</li>
<li><p><code>按位异或（^）</code>：将两个数的对应位进行异或操作，如果两个数的对应位不同，则结果为1，否则为0。常用于交换两个数的值、清除特定位等操作。</p>
</li>
<li><p><code>按位取反（~）</code>：将一个数的所有位取反，即将0变为1，将1变为0。常用于对数的位进行取反操作。</p>
</li>
<li><p><code>左移（&lt;&lt;）</code>：将一个数的所有位向左移动指定的位数，高位丢弃，低位补0。常用于实现乘以2的n次方。</p>
</li>
<li><p><code>右移（&gt;&gt;）</code>：将一个数的所有位向右移动指定的位数，低位丢弃，高位根据情况补0或者补符号位。常用于实现除以2的n次方。</p>
</li>
</ol>
<p>奇技淫巧和常见用途：</p>
<ul>
<li>交换两个数的值：使用按位异或（^）运算，即a ^&#x3D; b; b ^&#x3D; a; a ^&#x3D; b;。</li>
<li>判断奇偶性：使用按位与（&amp;）运算，奇数的最后一位为1，偶数的最后一位为0。</li>
<li>清零特定位：使用按位与（&amp;）运算，将指定位设置为0。</li>
<li>设置特定位：使用按位或（|）运算，将指定位设置为1。</li>
<li>快速计算2的幂：使用左移（&lt;&lt;）运算，将1左移n位得到2的n次方。</li>
<li>判断一个数是否是2的幂：使用按位与（&amp;）运算，2的幂的二进制表示中只有一位为1，其余为0，所以 n &amp; (n - 1) &#x3D;&#x3D; 0 表示 n 是2的幂。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换两个数的值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">    a ^= b;</span><br><span class="line">    b ^= a;</span><br><span class="line">    a ^= b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断奇偶性</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isEven</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (n &amp; <span class="number">1</span>) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清零特定位</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">clearBit</span><span class="params">(<span class="type">int</span> num, <span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num &amp; ~(<span class="number">1</span> &lt;&lt; pos);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置特定位</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setBit</span><span class="params">(<span class="type">int</span> num, <span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num | (<span class="number">1</span> &lt;&lt; pos);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快速计算2的幂</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">powOf2</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断一个数是否是2的幂</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPowerOf2</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (n &amp; (n - <span class="number">1</span>)) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 交换两个数的值</span></span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">swap</span>(a, b);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Swap: a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;, b = &quot;</span> &lt;&lt; b &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断奇偶性</span></span><br><span class="line">    <span class="type">int</span> num = <span class="number">7</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Is &quot;</span> &lt;&lt; num &lt;&lt; <span class="string">&quot; even? &quot;</span> &lt;&lt; <span class="built_in">isEven</span>(num) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清零特定位</span></span><br><span class="line">    <span class="type">int</span> num1 = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> pos1 = <span class="number">2</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Clear bit at position &quot;</span> &lt;&lt; pos1 &lt;&lt; <span class="string">&quot; in &quot;</span> &lt;&lt; num1 &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; <span class="built_in">clearBit</span>(num1, pos1) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置特定位</span></span><br><span class="line">    <span class="type">int</span> num2 = <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> pos2 = <span class="number">1</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Set bit at position &quot;</span> &lt;&lt; pos2 &lt;&lt; <span class="string">&quot; in &quot;</span> &lt;&lt; num2 &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; <span class="built_in">setBit</span>(num2, pos2) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 快速计算2的幂</span></span><br><span class="line">    <span class="type">int</span> n = <span class="number">3</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;2^&quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; <span class="built_in">powOf2</span>(n) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断一个数是否是2的幂</span></span><br><span class="line">    <span class="type">int</span> num3 = <span class="number">16</span>;</span><br><span class="line">    std::cout &lt;&lt; num3 &lt;&lt; <span class="string">&quot; is power of 2? &quot;</span> &lt;&lt; <span class="built_in">isPowerOf2</span>(num3) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拓展阅读：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1YT4y117AH/">https://www.bilibili.com/video/BV1YT4y117AH/</a></li>
</ul>
</details>


<h2 id="业务技能"><a href="#业务技能" class="headerlink" title="业务技能"></a><center>业务技能</center></h2><h3 id="Protobuf和Json有什么区别，车内通信应用领域有何不同？"><a href="#Protobuf和Json有什么区别，车内通信应用领域有何不同？" class="headerlink" title="Protobuf和Json有什么区别，车内通信应用领域有何不同？"></a>Protobuf和Json有什么区别，车内通信应用领域有何不同？</h3><details>
    <summary>
        点击展开
    </summary>

<p>Protocol Buffers (protobuf) 和 JSON 是两种常用的<code>数据序列化格式</code>，它们都可以用于<code>数据存储和通信</code>。然而，它们在设计理念、性能和使用场景上有一些重要的区别：</p>
<ul>
<li><p>数据大小和速度：Protobuf 通常比 JSON 更小，更快。Protobuf 是二进制格式，比 JSON 的文本格式更紧凑，因此在网络传输和数据存储上更有效率。同时，Protobuf 的解析和序列化速度也通常比 JSON 更快。</p>
</li>
<li><p>类型安全：Protobuf 是静态类型的，需要预先定义数据结构（在 .proto 文件中）。这意味着你可以在编译时获取类型安全性，并且可以利用 Protobuf 编译器生成的代码来读写数据。而 JSON 是动态类型的，数据结构可以在运行时改变，这在某些情况下可能更灵活，但也可能导致更多的运行时错误。</p>
</li>
<li><p>可读性和互操作性：JSON 是人类可读的，可以直接在文本编辑器中查看和编辑，而且被广泛支持在几乎所有的编程语言中。而 Protobuf 是二进制格式，不易于直接阅读和编辑，但它提供了工具可以将数据转换为可读的文本格式。Protobuf 的支持也比较广泛，但可能不如 JSON 那么普遍。</p>
</li>
<li><p>版本兼容性：Protobuf 设计了一套规则来处理数据结构的变化，使得新旧版本的数据结构可以相互兼容。而在 JSON 中，如果数据结构发生变化，可能需要更多的手动处理来保证兼容性。</p>
</li>
</ul>
<p>总的来说，Protobuf 和 JSON 各有优势，适用于不同的场景。在需要<code>可读性和广泛的语言互操作性</code>的 Web 开发中，JSON 是一个很好的选择，因为 <code>HTTP 请求和响应通常需要在多种不同的平台和语言之间进行交互</code>。</p>
<p>在需要高效性能和强类型的车载网络通信中，Protobuf 是更好的选择，因为因为车载系统通常有严格的性能和资源限制，在车载网络中，带宽和资源通常是有限的，因此需要使用更高效的数据格式。<code>Protobuf 的二进制格式比 JSON 的文本格式更紧凑</code>，因此可以更有效地<code>利用网络带宽</code>。</p>
<p>拓展阅读：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://sunyunqiang.com/blog/protobuf_encode/">Protobuf编码原理</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/633656133">序列化协议Protobuf入门</a></li>
</ol>
</details>



<h3 id="介绍下DoIP报文的格式。"><a href="#介绍下DoIP报文的格式。" class="headerlink" title="介绍下DoIP报文的格式。"></a>介绍下DoIP报文的格式。</h3><details>
    <summary>
        点击展开
    </summary>

<p>DoIP（Diagnostic over Internet Protocol）是一种在以太网上进行车辆诊断的协议。它是基于TCP&#x2F;IP和UDP&#x2F;IP的，允许在车辆网络中进行高速、高效的数据传输。</p>
<p>DoIP报文的基本格式如下：</p>
<p>协议版本：这是一个8位的字段，表示DoIP协议的版本。当前的版本是0x02。</p>
<p>载荷类型：这是一个16位的字段，表示载荷的类型。例如，诊断消息、车辆识别请求等。</p>
<p>载荷长度：这是一个32位的字段，表示载荷的长度（以字节为单位）。</p>
<p>载荷：这是一个可变长度的字段，包含载荷的实际数据。其内容和长度取决于载荷类型。</p>
<p>源地址：这是一个16位的字段，表示发送节点的地址。</p>
<p>目标地址：这是一个16位的字段，表示接收节点的地址。</p>
<p>在实际使用中，DoIP报文通常会被封装在TCP或UDP报文中，然后通过以太网进行传输。具体的传输协议（TCP或UDP）取决于载荷类型和特定的应用需求。</p>
<p>拓展阅读：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.iso.org/standard/87961.html">https://www.iso.org/standard/87961.html</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/doip/doip">https://github.com/doip/doip</a></li>
<li><a target="_blank" rel="noopener" href="http://bbs.eeworld.com.cn/thread-1275968-1-1.html">http://bbs.eeworld.com.cn/thread-1275968-1-1.html</a></li>
</ul>
</details>



<h3 id="介绍下CAN报文的格式以及在工作中是如何分析CAN报文的。"><a href="#介绍下CAN报文的格式以及在工作中是如何分析CAN报文的。" class="headerlink" title="介绍下CAN报文的格式以及在工作中是如何分析CAN报文的。"></a>介绍下CAN报文的格式以及在工作中是如何分析CAN报文的。</h3><details>
    <summary>
        点击展开
    </summary>

<p>CAN（Controller Area Network）报文主要有两种格式：标准格式（CAN 2.0A）和扩展格式（CAN 2.0B）。其基本格式包括：起始位、仲裁域（包括标识符和远程传输请求位）、控制域（包括数据长度代码）、数据域、CRC域、确认域和结束位。上述两种格式的主要区别在于标识符的长度，标准格式的标识符是11位，而扩展格式的标识符是29位。</p>
<p>以下是CAN报文的基本结构：</p>
<ul>
<li><p>起始位（Start of frame）：这是一个固定为0的位，表示报文的开始。</p>
</li>
<li><p>仲裁域（Arbitration field）：这个域包括标识符和远程传输请求位（RTR）。标识符用于标识报文的类型或目的。RTR位用于区分数据帧（RTR&#x3D;0）和远程帧（RTR&#x3D;1）。</p>
</li>
<li><p>控制域（Control field）：这个域包括数据长度代码（DLC），表示数据域中的字节数（0到8字节）。</p>
</li>
<li><p>数据域（Data field）：这个域包含报文的数据，长度由DLC指定。</p>
</li>
<li><p>CRC域（CRC field）：这个域包含一个15位的循环冗余校验序列和一个固定为1的分隔位。</p>
</li>
<li><p>确认域（ACK field）：这个域包括一个确认位和一个固定为1的分隔位。发送节点将确认位设置为0，接收节点在成功接收报文后将其设置为1。</p>
</li>
<li><p>结束位（End of frame）：这是一个固定为1的位，表示报文的结束。</p>
</li>
</ul>
<p>在CAN网络中，所有节点都会监听网络上的所有报文，并根据报文的标识符决定是否处理报文。当多个节点同时发送报文时，标识符较小的报文（即优先级较高的报文）会被优先发送。这是通过CAN协议的仲裁机制实现的。</p>
<p>有一些工具可以帮助在工作中分析CAN报文，例如Wireshark、Vector CANoe等。这些工具可以自动解析CAN报文，并提供一些高级的功能，如报文过滤、触发条件等。</p>
</details>



<h3 id="简单介绍下MQTT的消息格式、消息类型、服务质量和连接保活特征。"><a href="#简单介绍下MQTT的消息格式、消息类型、服务质量和连接保活特征。" class="headerlink" title="简单介绍下MQTT的消息格式、消息类型、服务质量和连接保活特征。"></a>简单介绍下MQTT的消息格式、消息类型、服务质量和连接保活特征。</h3><details>
    <summary>
        点击展开
    </summary>

<p>MQTT（Message Queuing Telemetyr Transport 消息队列遥测传输协议）：基于发布&#x2F;订阅模式的轻量级通讯协议，该协议构建于TCP&#x2F;IP协议之上。MQTT运行于TCP之上，属于应用层协议。</p>
<ul>
<li><p><strong>消息格式</strong>：<br>每条MQTT命令消息的消息头都包含一个固定的报头，有些消息会携带一个可变报文头和一个负荷。消息格式如下：</p>
<p>  <code>固定报文头</code>  |  <code>可变报文头</code>  |  <code>负荷</code></p>
</li>
</ul>
<ol>
<li><p>固定报头：最少有两个字节，第一个字节包含消息的类型（Message Type）和QoS级别等标志位。第二个字节开始是剩余长度字节，该长度是后面的可变报文头加消息负载的总长度，该字段最多允许四个字节。<br>剩余长度字段单个字节的最大值为0x7F. 也就是127个字节。MQTT协议规定，单个字节的最高位如果是1，表示后续还有字节存在，第八位起延续位的作用。<br>由于MQTT协议最多使用四个字节表示剩余长度，并且最后一个字节的最大值只能是0x7F,而不是0xFF。所以能发送的最大消息长度是256MB，而不是512MB。</p>
</li>
<li><p>可变报头：主要包含协议名，协议版本，连接标志，心跳间隔时间，连接返回码，主题名等。</p>
</li>
<li><p>负荷：实际上可以理解为消息的主体。当MQTT发送的消息类型是CONNECT（连接）、PUBLISH（发布）、SUBSCRIBE（订阅）、SUBACK（订阅确认）、UBSUNSCRIBE（取消订阅）时会带有负荷。</p>
</li>
</ol>
<ul>
<li><strong>消息类型</strong>：<br>固定报文头中的第一个字节包含连接标志，连接标志用来区分MQTT的消息类型。MQTT协议拥有14中不同的消息类型。如下表，可简单分为连接及终止、发布和订阅、Qos2消息的机制以及各种确认ACK。</li>
</ul>
<table>
<thead>
<tr>
<th>类型名称</th>
<th>类型值</th>
<th>报文说明</th>
<th>流动方向</th>
</tr>
</thead>
<tbody><tr>
<td>CONNECT</td>
<td>1</td>
<td>客户端请求连接到服务器</td>
<td>客户端到服务器</td>
</tr>
<tr>
<td>CONNACK</td>
<td>2</td>
<td>连接确认</td>
<td>服务器到客户端</td>
</tr>
<tr>
<td>PUBLISH</td>
<td>3</td>
<td>发布消息</td>
<td>客户端到服务器，服务器到客户端</td>
</tr>
<tr>
<td>PUBACK</td>
<td>4</td>
<td>发布确认，针对QoS 1消息</td>
<td>客户端到服务器，服务器到客户端</td>
</tr>
<tr>
<td>PUBREC</td>
<td>5</td>
<td>发布收到（保证交付第一步），针对QoS 2消息</td>
<td>客户端到服务器，服务器到客户端</td>
</tr>
<tr>
<td>PUBREL</td>
<td>6</td>
<td>发布释放（保证交付第二步），针对QoS 2消息</td>
<td>客户端到服务器，服务器到客户端</td>
</tr>
<tr>
<td>PUBCOMP</td>
<td>7</td>
<td>发布完成（保证交付第三步），针对QoS 2消息</td>
<td>客户端到服务器，服务器到客户端</td>
</tr>
<tr>
<td>SUBSCRIBE</td>
<td>8</td>
<td>客户端订阅请求</td>
<td>客户端到服务器</td>
</tr>
<tr>
<td>SUBACK</td>
<td>9</td>
<td>订阅确认</td>
<td>服务器到客户端</td>
</tr>
<tr>
<td>UNSUBSCRIBE</td>
<td>10</td>
<td>取消订阅请求</td>
<td>客户端到服务器</td>
</tr>
<tr>
<td>UNSUBACK</td>
<td>11</td>
<td>取消订阅确认</td>
<td>服务器到客户端</td>
</tr>
<tr>
<td>PINGREQ</td>
<td>12</td>
<td>PING请求</td>
<td>客户端到服务器</td>
</tr>
<tr>
<td>PINGRESP</td>
<td>13</td>
<td>PING响应</td>
<td>服务器到客户端</td>
</tr>
<tr>
<td>DISCONNECT</td>
<td>14</td>
<td>客户端断开连接</td>
<td>客户端到服务器</td>
</tr>
</tbody></table>
<ul>
<li><strong>服务质量</strong>：<br>MQTT消息质量有三个等级，QoS 0、Qos 1、Qos 2。</li>
</ul>
<ol>
<li><p>Qos 0：最多分发一次，消息的传递完全依赖底层的TCP&#x2F;IP网络，协议里没有定义应答和重试。消息只会到达服务端一次，要么就没到达。</p>
</li>
<li><p>Qos 1：至少分发一次、服务器的消息接收由PUBACK消息进行确认，如果通信链路或设备异常，或指定时间内没有收到确认消息，发送端会重发这条在消息头中设置了Dup位的消息。</p>
</li>
<li><p>Qos 2：只分发一次。最高级别的消息传递，消息丢失和重复都是不可接受的，使用这个服务质量等级会有额外的开销。</p>
</li>
</ol>
<ul>
<li><strong>连接保活机制</strong>：<br>MQTT客户端可以设置一个心跳间隔时间（keep Alive Timer），表示在每个心跳检测时间内发送一条消息。如果在这个时间周期内，没有业务数据相关的消息，客户端会发送一个PINGREQ消息，相应的，服务器会返回一个PINGRESP消息进行确认。</li>
</ul>
<p>如果服务器在一个半（1.5）个心跳间隔时间周期内没有收到来自客户端的消息，就会断开与客户端的连接。心跳间隔时间最大值可以设置为18个小时，8表示客户端不会断开。</p>
<p>拓展阅读：<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1432369">https://cloud.tencent.com/developer/article/1432369</a></p>
</details>



<h3 id="RESTful-的灵魂是什么？"><a href="#RESTful-的灵魂是什么？" class="headerlink" title="RESTful 的灵魂是什么？"></a>RESTful 的灵魂是什么？</h3><details>
    <summary>
        点击展开
    </summary>

<p>RESTful的灵魂是一种设计理念和风格，其核心思想是将Web应用程序建模为资源，并通过统一的接口（HTTP方法）对资源进行操作。RESTful架构风格强调以下几个关键特征：</p>
<ol>
<li><p><strong>资源（Resources）：</strong> 将网络上的信息（如文档、图片、视频等）视为资源，并使用URI（统一资源标识符）来唯一标识每个资源。</p>
</li>
<li><p><strong>表现层状态转换（Representational State Transfer）：</strong> 客户端和服务器之间的交互通过表现层的转换来实现，客户端通过操作资源的表现形式来操作资源。</p>
</li>
<li><p><strong>无状态（Stateless）：</strong> 服务端不保存客户端的状态信息，每个请求都包含足够的信息，使服务器可以理解请求的上下文。</p>
</li>
<li><p><strong>统一接口（Uniform Interface）：</strong> 使用统一的接口对资源进行操作，包括标识资源的URI、使用标准的HTTP方法（GET、POST、PUT、DELETE等）进行操作、使用标准的媒体类型（如JSON、XML）来传输资源的表现形式。</p>
</li>
<li><p><strong>客户端-服务器架构（Client-Server）：</strong> 将系统划分为客户端和服务器，客户端负责用户界面和用户交互，服务器负责存储和管理资源。</p>
</li>
<li><p><strong>可缓存性（Cacheability）：</strong> 服务端必须声明哪些资源是可缓存的，客户端可以使用缓存来提高性能和减少网络延迟。</p>
</li>
<li><p><strong>分层系统（Layered System）：</strong> 允许系统在不影响客户端的情况下增加中间层（如代理服务器、负载均衡器等），以提高系统的可伸缩性和性能。</p>
</li>
</ol>
<p>综上所述，RESTful的灵魂在于将Web应用程序建模为资源，并通过统一的接口和无状态的通信方式来实现客户端和服务器之间的交互，以实现系统的松耦合、可伸缩性和可重用性。</p>
</details>



<h3 id="AUTOSAR-是做AP还是CP，两者有什么区别，简要介绍下？"><a href="#AUTOSAR-是做AP还是CP，两者有什么区别，简要介绍下？" class="headerlink" title="AUTOSAR 是做AP还是CP，两者有什么区别，简要介绍下？"></a>AUTOSAR 是做AP还是CP，两者有什么区别，简要介绍下？</h3><details>
    <summary>
        点击展开
    </summary>

<pre><code>• 汽车领域的一套标准软件架构
• AUTOSAR的主要内容：
    ○ 完整的基础软件架构：框架，系统有哪些模块，模块间的交互
    ○ 汽车应用接口规范
    ○ 验收测试规范
    ○ 方法论
• CP：基于传统ECU的嵌入式软件平台
• AP：基于高性能智能ECU的软件中间件 [C++11、SOA、Security]
• 功能模块介绍—AP：
    ○ 通信模块（ara::com）：模块和外界交互，SOME/IP、DDS、Signal PDU、IPC
    ○ 执行模块（ara::exec）：模块在系统中如何跑起来，由一个可执行程序变成进程，管理其启动时和运行时的一些进程的行为。
    ○ 持久化模块（ara::per）：进程记录一些数据，读写一些信息，和外界配置信息交互
    ○ 时间同步（ara::tsync）：高精度时间保证。
    ○ 日志追踪（ara::log）：模块运行的记录日志。
    ○ 状态管理（ara::sm）：模块的状态转换。
    ○ 升级管理（ara::ucm）：软件升级
    ○ 诊断管理（ara::diag）
</code></pre>
</details>



<h3 id="TC397"><a href="#TC397" class="headerlink" title="TC397"></a>TC397</h3><details>
    <summary>
        点击展开
    </summary>

<p>国内L2+大多数方案 MCU:TC397 SoC:TDA4VM</p>
<p>CP AUTOSAR一般运行在8bit、16bit、32bit的微控制器（MCU）中，如英飞凌的TC3xx，瑞萨的RH850等。<br>AP AUTOSAR可以运行在64bit的高性能处理器（MPU）、CPU等中，如瑞萨的H3，英伟达的Xavier等。除此之外，AP AUTOSAR也可以运行在虚拟硬件上。<br>CP AUTOSAR OS是基于OSEK标准的。 AP AUTOSAR OS是POSIX OS，且至少应包含PSE51子集。</p>
<p>注：<br>OSEK&#x2F;VDX、POSIX和PSE51都是操作系统标准，主要用于嵌入式系统和实时系统。</p>
<p>OSEK&#x2F;VDX：这是一个为汽车电子控制单元（ECU）开发的开放式标准。它定义了一个实时操作系统（RTOS）的接口，以及一些相关的服务，如网络通信和诊断。OSEK&#x2F;VDX标准旨在提供一个跨多个硬件平台的统一的软件架构，以简化汽车电子系统的开发和维护。</p>
<p>POSIX：这是一组由IEEE定义的操作系统接口标准，旨在提高软件的可移植性。POSIX标准定义了一组核心的API和服务，包括文件系统操作、进程管理、线程管理、和信号处理等。许多操作系统，包括大多数Unix和Linux变种，以及一些嵌入式操作系统，都提供了对POSIX标准的支持。</p>
<p>PSE51：这是POSIX标准的一个子集，专门为小型嵌入式实时系统设计。PSE51标准定义了一组最小的、对实时系统有用的API和服务，包括线程管理、时间管理、和信号量等。PSE51标准旨在提供一个适合资源受限环境的、可移植的操作系统接口。</p>
</details>



<h3 id="FOTA和TBOX的通信怎么做"><a href="#FOTA和TBOX的通信怎么做" class="headerlink" title="FOTA和TBOX的通信怎么做"></a>FOTA和TBOX的通信怎么做</h3><details>
    <summary>
        点击展开
    </summary>

<p>云端和TBOX的通信，一边是上行和下行的通信，下行一般采用MQTT协议，将云端的信息通知给TBOX，上行信息一般较多，如版本信息、安装进度、安装状态等，一般采用HTTPS的POST、GET请求和云端交互，设计到指定的一系列车云REST接口。</p>
<p>MQTT：MQTT 是一种基于发布&#x2F;订阅模式的轻量级消息协议，特别适合在网络带宽较小、不稳定或高延迟的环境中使用。在车云通信的下行通信中，云端需要将信息（如 FOTA 更新）推送给 TBOX，这种一对多的通信模式非常适合 MQTT。此外，MQTT 还支持持久会话和消息存储，可以确保重要的信息不会丢失。</p>
<p>HTTPS：HTTPS 是 HTTP 的安全版本，它在 HTTP 上添加了 SSL&#x2F;TLS 协议，可以提供数据的加密传输、身份验证和消息完整性检查。在车云通信的上行通信中，TBOX 需要将信息（如版本信息、安装进度、安装状态等）发送给云端，这种一对一的通信模式非常适合 HTTPS。此外，HTTPS 的 POST 和 GET 请求可以方便地与云端的 REST 接口进行交互。</p>
</details>



<h3 id="诊断仪的代码移植"><a href="#诊断仪的代码移植" class="headerlink" title="诊断仪的代码移植"></a>诊断仪的代码移植</h3><details>
    <summary>
        点击展开
    </summary>

<ol>
<li><p>理解源代码：首先，需要理解源代码的功能和结构，包括各个模块的作用，以及它们之间的交互方式。</p>
</li>
<li><p>选择目标平台：然后，需要选择一个目标平台，这可能是一个不同的操作系统，或者一个不同的硬件架构。</p>
</li>
<li><p>设置开发环境：根据目标平台，设置相应的开发环境，包括编译器、调试器等工具。</p>
</li>
<li><p>修改代码：根据目标平台的特性，修改源代码。这可能包括修改硬件抽象层（HAL），修改操作系统相关的代码，以及修改编译器特定的代码等。</p>
</li>
<li><p>编译和测试：编译修改后的代码，并在目标平台上进行测试。测试应该包括功能测试，性能测试，以及稳定性测试等。</p>
</li>
<li><p>优化和调试：根据测试结果，进行必要的优化和调试。</p>
</li>
</ol>
</details>



<h3 id="代码移植之后怎么做验证"><a href="#代码移植之后怎么做验证" class="headerlink" title="代码移植之后怎么做验证"></a>代码移植之后怎么做验证</h3><details>
    <summary>
        点击展开
    </summary>

<ol>
<li><p>单元测试：对每个函数或模块进行独立的测试，使用 <code>EXPECT_EQ</code> 宏来检查响应是否等于预期的响应，以确保它们在新环境中的功能正确。（1.车云接口 2.整车版本 3.网络丢包）</p>
</li>
<li><p>集成测试：在所有模块组合在一起后进行测试，以确保它们能够正确地协同工作。（编译通过）</p>
</li>
<li><p>系统测试：在整个系统级别进行测试，以确保所有组件和服务在一起工作时的行为符合预期。（放到板子上跑）</p>
</li>
<li><p>性能测试：测试系统在高负载或大数据量下的性能和稳定性。（压测）</p>
</li>
<li><p>回归测试：在每次修改代码后，重新运行所有的测试，以确保修改没有引入新的错误。（查缺补漏）</p>
</li>
<li><p>验收测试：最后，进行验收测试，以确保系统满足所有的业务需求和用户需求。（质量部门）</p>
</li>
</ol>
</details>



<h3 id="CMake的基础用法"><a href="#CMake的基础用法" class="headerlink" title="CMake的基础用法"></a>CMake的基础用法</h3><details>
    <summary>
        点击展开
    </summary>

<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/662623216">https://zhuanlan.zhihu.com/p/662623216</a></p>
<p>CMake是一个跨平台的自动化构建系统，主要用来管理软件构建的过程，它使用一个名为CMakeLists.txt的配置文件来指导编译和链接的过程。</p>
<p><code>make_minimum_required(VERSION x.x)</code>: 指定项目需要的最低CMake版本。</p>
<p><code>project(ProjectName)</code>: 定义项目的名称和使用的语言。</p>
<p><code>add_executable(TargetName source1 source2 ...)</code>: 添加一个可执行目标，并指定其源文件。</p>
<p><code>add_library(TargetName type source1 source2 ...)</code>: 添加一个库目标，并指定其类型（静态或动态）和源文件。</p>
<p><code>find_package(PackageName)</code>: 查找并加载外部依赖包。</p>
<p><code>target_link_libraries(TargetName library1 library2 ...)</code>: 指定目标链接的库。</p>
</details>



<h3 id="诊断刷写的流程"><a href="#诊断刷写的流程" class="headerlink" title="诊断刷写的流程"></a>诊断刷写的流程</h3><details>
    <summary>
        点击展开
    </summary>

<p>诊断刷写通常是指在汽车诊断过程中，通过诊断工具将新的固件刷写到汽车的电子控制单元（ECU）中。以下是一个基本的诊断刷写流程：</p>
<p>软件刷写总体上分为三个步骤：</p>
<ol>
<li>pre-programming</li>
<li>programming</li>
<li>post-programming</li>
</ol>
<p>刷写前：</p>
<p>Step 1：切换到拓展模式<br>（10：会话控制 03：拓展会话）</p>
<p>Step 2：检查刷写前提条件，如条件不满足，则退出刷写。<br>（31：例程控制 01：启动例程 XXX：例程ID，如车速、电源等）</p>
<p>Step 3：停用故障码存储功能，屏蔽故障<br>（85：故障码控制设置 02：停止故障码存储）</p>
<p>Step 4：停止发送一切通讯报文，关闭与诊断无关的报文，将节约出来的通信资源用于刷写软件，提升刷写速度。<br>（28：通信控制 01：停止发送报文和接收报文 01：一般通信报文 XXX结点识别号）</p>
<hr>
<p>Step 1：进入编程模式<br>（10：会话控制 02：编程会话）</p>
<p>Step 2：使用27服务进行安全访问<br>（27：安全访问 01：请求种子 02：发送与验证Key）</p>
<p>Step 3：写入指纹信息，即标记写软件人的身份<br>（2E：DID写入）</p>
<p>Step 4：擦除内存<br>（31：例程控制 01：启动例程 FF 00：例程ID，擦除存储数据）</p>
<p>Step 5：调用34，36，37服务完成数据的写入。<br>（34：请求下载 36：传输数据 37：请求传输退出）</p>
<p>Step 6：执行31服务，检查刚刚写入的数据块是否正确，典型的就是执行checksum验证。如果还有数据块要写，则再跳回Step 5，如果没有，则进入Step 7。<br>（31：例程控制 01：启动例程 02 02：例程ID，检查内存 FF 01： 检查编程依赖）</p>
<p>Step 7：写入所有数据块之后，一个完整的软件也就写好了，此时需要ECU检查一下这个软件是否可用，比如软硬件兼容问题。<br>（11：ECU复位 01：硬件复位）</p>
<hr>
<p>Step 1：切换到拓展模式<br>（10：会话控制 03：拓展会话）</p>
<p>Step 2：启用发送一般性通讯报文<br>（28：通信控制 00：启用发送报文和接收报文 01：一般通信报文 XXX结点识别号）</p>
<p>Step 3：各个ECU回复故障码的检测<br>（85：故障码控制设置 01：启动故障码存储）</p>
<p>Step 4：ECU回到默认模式<br>（10：会话模式 01：默认会话）</p>
</details>



<h3 id="A-x2F-B分区"><a href="#A-x2F-B分区" class="headerlink" title="A&#x2F;B分区"></a>A&#x2F;B分区</h3><details>
    <summary>
        点击展开
    </summary>

<ol>
<li>什么是A&#x2F;B分区系统呢？</li>
</ol>
<p>答：A分区或者B分区系统独立，两者之间可以相互切换的系统。</p>
<ol start="2">
<li>为什么需要这样的系统呢？</li>
</ol>
<p>答：在没有A&#x2F;B功能之前，车辆控制器的刷写需要车辆停车，满足一定的安全刷写条件后，使用诊断仪或者其他上位机刷写。这一系列的操作，费时费力。为了最大程度的节省刷写时间，给用户更好的升级体验，静默刷写来了。而静默刷写建立的基础就是A&#x2F;B功能，即：激活的分区，可以在车辆运行的过程中更新非激活分区。</p>
<ol start="3">
<li>非激活分区完成更新以后，何时切换分区？</li>
</ol>
<p>非激活分区（A分区或者B分区）完成软件更新以后，需要在下次系统启动（一般需要MCU进行系统级复位）时，进行分区切换。</p>
<ol start="4">
<li>A&#x2F;B分区均启动失败以后，应该如何处理？</li>
</ol>
<p>如果A&#x2F;B分区均启动失败，程序应该进入诊断的编程会话（Programming Session），以便于程序可以被更新，避免控制器成为”板砖”。</p>
</details>


<h3 id="为了Aspice做了那些工作"><a href="#为了Aspice做了那些工作" class="headerlink" title="为了Aspice做了那些工作"></a>为了Aspice做了那些工作</h3><details>
    <summary>
        点击展开
    </summary>

<p>ASPICE全称<code>“AutomotiveSoftware ProcessImprovement and CapacityDetermination”</code>，即<code>汽车软件过程改进及能力评定</code>。<br>它是一个过程模型，由<code>过程</code>和<code>能力度</code>两个维度构成，用于评价汽车行业<code>软件设计开发的能力水平</code>。</p>
<p>ASPICE评估对象是项目，而不是产品或公司体系。ASPICE评估只能证明一个公司某个项目在某个时间段的过程能力情况。</p>
<p>1.编写和维护技术文档，包括系统软件技术规范（SSTS）、开发接口文档等，以确保所有的软件开发活动都有明确的指导和记录。</p>
<p>2.为下一个阶段的工作提供输入。例如，系统需求会为软件需求提供输入，这样可以让工作有章法可循。</p>
<p>3.使用Jira等缺陷跟踪管理系统，明确任务和缺陷。一级需求作为epic，二级需求作为story。在这个过程中，我会与产品经理反复沟通，明确我们的目标和预期结果。</p>
<p>4.进行定期的内部审计和评估，以确保我们的软件开发过程符合ASPICE的要求。</p>
<p>5.提供培训和指导，以确保团队成员理解和遵守ASPICE规范。</p>
<p>6.在软件开发过程中，我会确保所有的变更都经过严格的变更控制过程，包括变更请求的提交、评审、批准和实施。</p>
<p>最后，我会进行持续的过程改进，以提高我们的软件开发能力和成熟度。</p>
</details>



<h3 id="进程crash之后的处理"><a href="#进程crash之后的处理" class="headerlink" title="进程crash之后的处理"></a>进程crash之后的处理</h3><details>
    <summary>
        点击展开
    </summary>

<p>Native层Crash处理:</p>
<ul>
<li><p>kernel捕捉到进程的异常信号(SIGABRT,SIGBUS,SIGFPE)时,调用信号处理函数；信号处理函数负责收集Crash进程的错误信息，并将错误信息通过socket发送给debugger守护进程；</p>
</li>
<li><p>debugger守护进程接收到crash信息后，一方面告知AMS有进程发生Crash，一方面通过tomestone保存完整的现场信息；</p>
</li>
<li><p>AMS收到Crash信息后，弹出对话框告知用户Crash信息，同时保存该crash进程的相关LOG；</p>
</li>
<li><p>出现 Crash 或 ANR，可以从以下几个方面处理：</p>
</li>
</ul>
<p>可以先把墓碑文件导出来</p>
<p>然后再搜索其中的关键字，比如：exception、crash，看看是哪些方法或者异常导致了问题；</p>
<p>根据backtrace初步定位问题原因后，查找代码进行分析修复与验证。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">NullPointerException - 空指针引用异常</span><br><span class="line">ClassCastException - 类型强制转换异常</span><br><span class="line">IllegalArgumentException - 传递非法参数异常</span><br><span class="line">ArithmeticException - 算术运算异常</span><br><span class="line">ArrayStoreException - 向数组中存放与声明类型不兼容对象异常</span><br><span class="line">IndexOutOfBoundsException - 下标越界异常</span><br><span class="line">NegativeArraySizeException - 创建一个大小为负数的数组错误异常</span><br><span class="line">NumberFormatException - 数字格式异常</span><br><span class="line">SecurityException - 安全异常</span><br><span class="line">UnsupportedOperationException - 不支持的操作异常</span><br></pre></td></tr></table></figure>

</details>


<h3 id="GCC和GDB"><a href="#GCC和GDB" class="headerlink" title="GCC和GDB"></a>GCC和GDB</h3><details>
    <summary>
        点击展开
    </summary>

<p>了解基础：首先要知道gdb是一个强大的UNIX和Linux下的<code>程序调试工具</code>，它支持多种编程语言，包括C、C++等。<br>基本命令：掌握gdb的启动方式，例如gdb program来直接调试程序。一些基本命令，如run、next、step、continue、break（或b）、print（或p）等，用于启动程序、单步执行、设置断点和查看变量值。<br>使用帮助：知道如何在gdb中使用help命令来获取帮助信息。</p>
<p>断点和监视点：深入了解不同类型的断点（如条件断点）和监视点（watchpoint）的设置和使用。<br>堆栈跟踪：学会使用backtrace（或bt）命令来查看函数调用堆栈。<br>变量查看：掌握如何查看和修改变量的值，包括局部变量和全局变量。<br>源代码导航：学习如何在gdb中导航源代码，包括设置和跳转到不同的源代码行。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">（gdb）help：查看命令帮助，具体命令查询在gdb中输入help + 命令,简写h</span><br><span class="line">（gdb）run：重新开始运行文件（run-text：加载文本文件，run-bin：加载二进制文件）,简写r</span><br><span class="line">（gdb）start：单步执行，运行程序，停在第一执行语句</span><br><span class="line">（gdb）list：查看原代码（list-n,从第n行开始查看代码。list+ 函数名：查看具体函数）,简写l</span><br><span class="line">（gdb）set：设置变量的值</span><br><span class="line">（gdb）next：单步调试（逐过程，函数直接执行）,简写n</span><br><span class="line">（gdb）step：单步调试（逐语句：跳入自定义函数内部执行）,简写s</span><br><span class="line">（gdb）backtrace：查看函数的调用的栈帧和层级关系,简写bt</span><br><span class="line">（gdb）frame：切换函数的栈帧,简写f</span><br><span class="line">（gdb）info：查看函数内部局部变量的数值,简写i</span><br><span class="line">（gdb）finish：结束当前函数，返回到函数调用点</span><br><span class="line">（gdb）continue：继续运行,简写c</span><br><span class="line">（gdb）print：打印值及地址,简写p</span><br><span class="line">（gdb）quit：退出gdb,简写q</span><br><span class="line">（gdb）break+num：在第num行设置断点,简写b</span><br><span class="line">（gdb）info breakpoints：查看当前设置的所有断点</span><br><span class="line">（gdb）delete breakpoints num：删除第num个断点,简写d</span><br><span class="line">（gdb）display：追踪查看具体变量值</span><br><span class="line">（gdb）undisplay：取消追踪观察变量</span><br><span class="line">（gdb）watch：被设置观察点的变量发生修改时，打印显示</span><br><span class="line">（gdb）i watch：显示观察点</span><br><span class="line">（gdb）enable breakpoints：启用断点</span><br><span class="line">（gdb）disable breakpoints：禁用断点</span><br><span class="line">（gdb）x：查看内存x/20xw 显示20个单元，16进制，4字节每单元</span><br><span class="line">（gdb）run argv[1] argv[2]：调试时命令行传参</span><br><span class="line">（gdb）set follow-fork-mode child#Makefile项目管理：选择跟踪父子进程（fork()）</span><br></pre></td></tr></table></figure>

</details>



<h3 id="差分升级"><a href="#差分升级" class="headerlink" title="差分升级"></a>差分升级</h3><details>
    <summary>
        点击展开
    </summary>

<p>差分算法需要解决两个主要的问题：</p>
<ol>
<li>如何高效的在old中寻找尽可能多的可用于构建new的数据流。</li>
<li>如何尽可能缩减描述old → new所需要的字节数。</li>
</ol>
<p>新老版本切分成定长的数据库，计算各块的hash，通过比对hash来寻找新旧之间相同的数据块。</p>
<p>通过后缀排序算法预处理新旧文件，将预处理的结果以后缀数组和名次数组的形式存为字典目录，基于该字典目录能能够快速查找字典数据集和待编码数据集之间的相同数据段。</p>
<p>HdiffPatch 的差异性比较主要通过以下步骤实现：</p>
<ol>
<li><p>使用<code>滑动窗口</code>在旧文件中查找新文件中的数据块。这个过程使用了<code>后缀数组</code>和<code>最长公共前缀数组</code>来加速查找。</p>
</li>
<li><p>对于在旧文件中找到的数据块，生成一个指向旧文件中位置的<code>引用</code>。</p>
</li>
<li><p>对于在旧文件中找不到的数据块，直接将这些数据包含在差分文件中。</p>
</li>
<li><p>将所有的引用和数据块按照在新文件中的顺序组合起来，生成差分文件。</p>
</li>
</ol>
<p>在 HdiffPatch 的源代码中，以下是一些核心的函数和方法：</p>
<ol>
<li><p>create_compressed_diff：这是创建差分文件的主要函数。它首先调用 search_cover 函数来查找在旧文件中的数据块，然后将找到的数据块和新文件中的其他数据一起压缩，生成差分文件。</p>
</li>
<li><p>search_cover：这个函数使用<code>滑动窗口</code>和<code>后缀数组</code>来在旧文件中查找新文件中的数据块。</p>
</li>
<li><p>hdiff_private::getChecksum：这个函数用于计算数据块的校验和，用于快速比较数据块。</p>
</li>
<li><p>hdiff_private::save_compress：这个函数用于将数据块压缩并保存到差分文件中。</p>
</li>
</ol>
<ul>
<li><p><code>使用后缀数组和最长公共前缀数组加速查找</code>：后缀数组是一个数据结构，它包含了一个字符串所有后缀的排序列表。最长公共前缀数组则存储了排序后的相邻后缀之间的最长公共前缀的长度。通过这两个数据结构，HdiffPatch 可以快速找到新文件中的数据块在旧文件中的位置。</p>
</li>
<li><p><code>使用滑动窗口查找数据块</code>：为了减小差分文件的大小，HdiffPatch 使用一个滑动窗口在旧文件中查找数据块。这个窗口的大小是可配置的，通过调整窗口大小，可以在查找速度和差分文件大小之间找到一个平衡。</p>
</li>
<li><p><code>使用压缩算法减小差分文件的大小</code>：HdiffPatch 支持多种压缩算法，包括 zlib，bzip2，lzma 等。通过压缩，可以进一步减小差分文件的大小。</p>
</li>
<li><p><code>使用校验和快速比较数据块</code>：为了加速数据块的比较，HdiffPatch 使用校验和算法计算数据块的校验和。通过比较校验和，可以快速判断两个数据块是否相同。</p>
</li>
</ul>
<p>BSDiff: APK差分升级</p>
<ol>
<li><p>将旧文件二进制使用后缀排序或哈希算法形成一个字符串索引。</p>
</li>
<li><p>使用该字符串索引对比新文件，生成差异文件(difference file)和新增文件(extra file)。</p>
</li>
<li><p>将差异文件和新增文件及必要的索引控制信息压缩为差异更新包。</p>
</li>
</ol>
<p>1）控制文件，包含需要添加和插入二进制段的指引信息（”添加指令”指定旧文件中的偏移量和长度，从旧文件读取适当的字节数，并将其添加到差异文件中的相同字节数；”插入指令”只是指定一个长度，指定的字节数是从额外的文件中读取的）；</p>
<p>2）差异文件，包含近似匹配字段的字节差异；</p>
<p>3）新增文件，包含无法近似匹配的完全不同的字段。</p>
<p>这三个文件加一起会比新文件略大，但其中控制文件和差异文件是高度结构化的，意味着其均可被高效压缩，所以可以使用类似bzip2等压缩工具将更新包总文件进行非常有效的压缩。</p>
</details>


<h3 id="Binder通讯原理解析"><a href="#Binder通讯原理解析" class="headerlink" title="Binder通讯原理解析"></a>Binder通讯原理解析</h3><details>
    <summary>
        点击展开
    </summary>

<ul>
<li>Binder 就是用来Client 端和 Server 端通信的。</li>
<li>Binder借助了内存映射（mmap）的方法，在内核空间和接收方用户空间的数据缓存区之间做了一层内存映射。从发送方用户空间拷贝到内核空间缓存区的数据，就相当于直接拷贝到了接收方用户空间的数据缓存区，从而减少了一次数据拷贝。</li>
<li>内存映射能减少数据拷贝次数，实现用户空间和内核空间的高效互动。两个空间各自的修改能直接反映在映射的内存区域，从而被对方空间及时感知。也正因为如此，内存映射能够提供对进程间通信的支持。</li>
<li>一次完整的 Binder IPC 通信过程通常是这样：<ul>
<li>1、首先 Binder 驱动在内核空间创建一个 数据接收缓存区 ；</li>
<li>2、接着在内核空间开辟一块内核缓存区，建立 内核缓存区 和 内核中数据接收缓存区 之间的映射关系，以及 内核中数据接收缓存区 和 接收进程用户空间地址 的映射关系；</li>
<li>3、发送方进程通过系统调用 copyfromuser() 将数据 copy 到内核中的内核缓存区，由于内核缓存区和接收进程的用户空间存在内存映射，因此也就相当于把数据发送到了接收进程的用户空间，这样便完成了一次进程间的通信。</li>
</ul>
</li>
</ul>
</details>


<h3 id="Android-添加自定义-native-服务"><a href="#Android-添加自定义-native-服务" class="headerlink" title="Android 添加自定义 native 服务"></a>Android 添加自定义 native 服务</h3><details>
    <summary>
        点击展开
    </summary>

<p>Native服务就是用C++写的系统服务，通过init进程启动，可以实现binder接口供client调用。</p>
<ol>
<li><p>编写服务代码：首先，你需要用C++编写你的服务代码。这通常包括实现一个或多个Binder接口，这些接口将被其他进程（客户端）调用。</p>
</li>
<li><p>编写.rc文件：.rc文件是Android的init语言脚本，用于描述应该如何启动你的服务。你需要在这个文件中指定你的服务的名称、执行路径、所需的权限等信息。</p>
</li>
<li><p>编写Android.bp文件：Android.bp文件是Android构建系统的一部分，用于描述如何构建你的服务。你需要在这个文件中指定你的源代码文件、依赖库等信息。</p>
</li>
<li><p>编译和安装：使用Android构建系统（如mm或mmm命令）编译你的服务。编译成功后，.rc文件会被安装到&#x2F;system&#x2F;etc&#x2F;init&#x2F;目录下，你的服务的可执行文件会被安装到&#x2F;system&#x2F;bin&#x2F;目录下（或其他你在.rc文件中指定的位置）。</p>
</li>
<li><p>配置SELinux策略：为了让你的服务在启动时能够获得必要的权限，你可能需要修改或添加SELinux策略。这通常涉及到编写.te文件和可能的.fc文件。</p>
</li>
<li><p>测试你的服务：重启你的设备，你的服务应该会在启动时自动运行。你可以使用ps命令检查你的服务是否正在运行，使用logcat命令查看你的服务的日志输出。</p>
</li>
</ol>
</details>
    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/blog/gtest-tutorial/" rel="prev" title="GoogleTest 快速入门">
      <i class="fa fa-chevron-left"></i> GoogleTest 快速入门
    </a></div>
      <div class="post-nav-item">
    <a href="/blog/recruitment-huawei-od-2024-03-30/" rel="next" title="华为OD机试 C卷 三道题目思路汇总">
      华为OD机试 C卷 三道题目思路汇总 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7"><span class="nav-number">1.</span> <span class="nav-text">C++语言特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5"><span class="nav-number">1.1.</span> <span class="nav-text">编译链接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0"><span class="nav-number">1.2.</span> <span class="nav-text">匿名函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">1.2.1.</span> <span class="nav-text">应用场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E7%82%B9"><span class="nav-number">1.2.2.</span> <span class="nav-text">优点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="nav-number">1.3.</span> <span class="nav-text">智能指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B"><span class="nav-number">1.4.</span> <span class="nav-text">并发编程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#C-11-STL"><span class="nav-number">1.4.1.</span> <span class="nav-text">C++11 STL</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Concurrency"><span class="nav-number">1.4.2.</span> <span class="nav-text">Concurrency</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Asynchronous"><span class="nav-number">1.4.3.</span> <span class="nav-text">Asynchronous</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Multithreading"><span class="nav-number">1.4.4.</span> <span class="nav-text">Multithreading</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#ThreadManagement"><span class="nav-number">1.4.4.1.</span> <span class="nav-text">ThreadManagement</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ThreadPool"><span class="nav-number">1.4.4.2.</span> <span class="nav-text">ThreadPool</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Thread-Synchronization"><span class="nav-number">1.4.4.3.</span> <span class="nav-text">Thread Synchronization</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Mutex"><span class="nav-number">1.4.4.3.1.</span> <span class="nav-text">Mutex</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Condition-Variable"><span class="nav-number">1.4.4.3.2.</span> <span class="nav-text">Condition Variable</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Semaphore"><span class="nav-number">1.4.4.3.3.</span> <span class="nav-text">Semaphore</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Atomic-Operation"><span class="nav-number">1.4.4.3.4.</span> <span class="nav-text">Atomic Operation</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Barrier"><span class="nav-number">1.4.4.3.5.</span> <span class="nav-text">Barrier</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Optimization"><span class="nav-number">1.4.4.4.</span> <span class="nav-text">Optimization</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E6%80%81"><span class="nav-number">1.5.</span> <span class="nav-text">多态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%BF%E5%87%BD%E6%95%B0"><span class="nav-number">1.6.</span> <span class="nav-text">仿函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#static%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">1.7.</span> <span class="nav-text">static关键字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8-amp-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="nav-number">1.8.</span> <span class="nav-text">左值引用 &amp; 右值引用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.</span> <span class="nav-text">设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A5%E5%B8%B8%E5%B7%A5%E4%BD%9C%E4%B8%AD%E7%94%A8%E5%88%B0%E4%BA%86%E9%82%A3%E4%BA%9B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="nav-number">2.1.</span> <span class="nav-text">日常工作中用到了那些设计模式？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="nav-number">2.2.</span> <span class="nav-text">如何实现一个线程安全的单例模式？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="nav-number">3.</span> <span class="nav-text">操作系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E3%80%8C%E4%BA%A7%E7%94%9F%E3%80%8D%E3%80%8C%E9%A2%84%E9%98%B2%E3%80%8D%E3%80%8C%E9%81%BF%E5%85%8D%E3%80%8D%E3%80%8C%E6%A3%80%E6%B5%8B%E3%80%8D%E3%80%8C%E8%A7%A3%E9%99%A4%E3%80%8D"><span class="nav-number">3.1.</span> <span class="nav-text">死锁的「产生」「预防」「避免」「检测」「解除」</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E7%94%B1%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84%E5%88%B0%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80"><span class="nav-number">3.2.</span> <span class="nav-text">如何由虚拟地址映射到物理地址</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C"><span class="nav-number">4.</span> <span class="nav-text">计算机网络</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-number">4.1.</span> <span class="nav-text">三次握手和四次挥手的过程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%88Three-Way-Handshake%EF%BC%89%EF%BC%9A"><span class="nav-number">4.1.1.</span> <span class="nav-text">三次握手（Three-Way Handshake）：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%88Four-Way-Handshake%EF%BC%89%EF%BC%9A"><span class="nav-number">4.1.2.</span> <span class="nav-text">四次挥手（Four-Way Handshake）：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP-%E4%B8%8E-UDP-%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="nav-number">4.2.</span> <span class="nav-text">TCP 与 UDP 的对比</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#POST%E5%92%8CGET%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.3.</span> <span class="nav-text">POST和GET的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95"><span class="nav-number">5.</span> <span class="nav-text">数据结构和算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%90%E8%BF%B0%E5%A0%86%E6%8E%92%E5%BA%8F%E4%B8%AD%E3%80%8C%E5%BB%BA%E5%A0%86%E3%80%8D%E3%80%8C%E8%B0%83%E6%95%B4%E3%80%8D%E5%92%8C%E3%80%8C%E5%88%A0%E9%99%A4%E3%80%8D%E7%9A%84%E8%BF%87%E7%A8%8B%E3%80%82"><span class="nav-number">5.1.</span> <span class="nav-text">阐述堆排序中「建堆」「调整」和「删除」的过程。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%90%E8%BF%B0%E5%AD%97%E5%85%B8%E5%BA%8FTrie%E8%BF%99%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%82"><span class="nav-number">5.2.</span> <span class="nav-text">阐述字典序Trie这种数据类型。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97%E6%8B%BE%E7%96%91"><span class="nav-number">5.3.</span> <span class="nav-text">位运算拾疑</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%9A%E5%8A%A1%E6%8A%80%E8%83%BD"><span class="nav-number">6.</span> <span class="nav-text">业务技能</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Protobuf%E5%92%8CJson%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%8C%E8%BD%A6%E5%86%85%E9%80%9A%E4%BF%A1%E5%BA%94%E7%94%A8%E9%A2%86%E5%9F%9F%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="nav-number">6.1.</span> <span class="nav-text">Protobuf和Json有什么区别，车内通信应用领域有何不同？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%8BDoIP%E6%8A%A5%E6%96%87%E7%9A%84%E6%A0%BC%E5%BC%8F%E3%80%82"><span class="nav-number">6.2.</span> <span class="nav-text">介绍下DoIP报文的格式。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%8BCAN%E6%8A%A5%E6%96%87%E7%9A%84%E6%A0%BC%E5%BC%8F%E4%BB%A5%E5%8F%8A%E5%9C%A8%E5%B7%A5%E4%BD%9C%E4%B8%AD%E6%98%AF%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90CAN%E6%8A%A5%E6%96%87%E7%9A%84%E3%80%82"><span class="nav-number">6.3.</span> <span class="nav-text">介绍下CAN报文的格式以及在工作中是如何分析CAN报文的。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E4%B8%8BMQTT%E7%9A%84%E6%B6%88%E6%81%AF%E6%A0%BC%E5%BC%8F%E3%80%81%E6%B6%88%E6%81%AF%E7%B1%BB%E5%9E%8B%E3%80%81%E6%9C%8D%E5%8A%A1%E8%B4%A8%E9%87%8F%E5%92%8C%E8%BF%9E%E6%8E%A5%E4%BF%9D%E6%B4%BB%E7%89%B9%E5%BE%81%E3%80%82"><span class="nav-number">6.4.</span> <span class="nav-text">简单介绍下MQTT的消息格式、消息类型、服务质量和连接保活特征。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RESTful-%E7%9A%84%E7%81%B5%E9%AD%82%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">6.5.</span> <span class="nav-text">RESTful 的灵魂是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AUTOSAR-%E6%98%AF%E5%81%9AAP%E8%BF%98%E6%98%AFCP%EF%BC%8C%E4%B8%A4%E8%80%85%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%8C%E7%AE%80%E8%A6%81%E4%BB%8B%E7%BB%8D%E4%B8%8B%EF%BC%9F"><span class="nav-number">6.6.</span> <span class="nav-text">AUTOSAR 是做AP还是CP，两者有什么区别，简要介绍下？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TC397"><span class="nav-number">6.7.</span> <span class="nav-text">TC397</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FOTA%E5%92%8CTBOX%E7%9A%84%E9%80%9A%E4%BF%A1%E6%80%8E%E4%B9%88%E5%81%9A"><span class="nav-number">6.8.</span> <span class="nav-text">FOTA和TBOX的通信怎么做</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%8A%E6%96%AD%E4%BB%AA%E7%9A%84%E4%BB%A3%E7%A0%81%E7%A7%BB%E6%A4%8D"><span class="nav-number">6.9.</span> <span class="nav-text">诊断仪的代码移植</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E7%A7%BB%E6%A4%8D%E4%B9%8B%E5%90%8E%E6%80%8E%E4%B9%88%E5%81%9A%E9%AA%8C%E8%AF%81"><span class="nav-number">6.10.</span> <span class="nav-text">代码移植之后怎么做验证</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CMake%E7%9A%84%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95"><span class="nav-number">6.11.</span> <span class="nav-text">CMake的基础用法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%8A%E6%96%AD%E5%88%B7%E5%86%99%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="nav-number">6.12.</span> <span class="nav-text">诊断刷写的流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#A-x2F-B%E5%88%86%E5%8C%BA"><span class="nav-number">6.13.</span> <span class="nav-text">A&#x2F;B分区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BA%86Aspice%E5%81%9A%E4%BA%86%E9%82%A3%E4%BA%9B%E5%B7%A5%E4%BD%9C"><span class="nav-number">6.14.</span> <span class="nav-text">为了Aspice做了那些工作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8Bcrash%E4%B9%8B%E5%90%8E%E7%9A%84%E5%A4%84%E7%90%86"><span class="nav-number">6.15.</span> <span class="nav-text">进程crash之后的处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GCC%E5%92%8CGDB"><span class="nav-number">6.16.</span> <span class="nav-text">GCC和GDB</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%AE%E5%88%86%E5%8D%87%E7%BA%A7"><span class="nav-number">6.17.</span> <span class="nav-text">差分升级</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Binder%E9%80%9A%E8%AE%AF%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90"><span class="nav-number">6.18.</span> <span class="nav-text">Binder通讯原理解析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Android-%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89-native-%E6%9C%8D%E5%8A%A1"><span class="nav-number">6.19.</span> <span class="nav-text">Android 添加自定义 native 服务</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">sitJac</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blog/archives/">
        
          <span class="site-state-item-count">26</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/blog/categories/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">sitJac</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/blog/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/blog/lib/velocity/velocity.min.js"></script>
  <script src="/blog/lib/velocity/velocity.ui.min.js"></script>

<script src="/blog/js/utils.js"></script>

<script src="/blog/js/motion.js"></script>


<script src="/blog/js/schemes/muse.js"></script>


<script src="/blog/js/next-boot.js"></script>




  




  
<script src="/blog/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
