<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ACM模式下C语言和Python的测试用例输入方式整理</title>
    <url>/blog/acm-codeing-tips/</url>
    <content><![CDATA[<div class="note info">

<p>在OJ网站上做题时经常出现一种情况，那就是题会做，但是不知道多组输入如何处理，导致无法AC。<br>本文对ACM模式下C语言和Python的测试用例的输入方式进行了系统的整理。</p>
</div>

<span id="more"></span>

<h2 id="ACM模式VS核心代码模式"><a href="#ACM模式VS核心代码模式" class="headerlink" title="ACM模式VS核心代码模式"></a><code>ACM模式</code>VS<code>核心代码模式</code></h2><p>有些企业是在牛客上进行面试，有些企业是在力扣上进行面试，两个平台答题模式是有区别的，所以搞懂不同的输入代码模式是很重要的。</p>
<p><code>ACM输入模式</code>：在这种模式下，你需要自己构造输入数据格式，把要需要处理的容器填充好，OJ不会给你任何代码，你需要自己导入所需的库，定义数据结构，读取和解析输入数据，然后根据题目要求输出结果，最后也要自己根据题目提示控制返回数据的格式。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nums</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 算法逻辑...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>LeetCode 的核心代码模式</code>：在这种模式下，LeetCode 已经为你处理了输入数据，将其封装在了特定的数据结构中（如数组、链表、二叉树等）。你只需要关注如何实现题目要求的算法逻辑，不需要处理输入和输出。这种模式下，你可以更专注于算法本身，但对于数据结构和输入输出的处理则有所限制。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">someFunction</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 算法逻辑...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看出ACM模式要比核心代码模式多写不少代码，相对来说ACM模式更锻炼代码能力，而核心代码模式是把侧重点完全放在算法逻辑上。</p>
<h2 id="OJ系统中C语言各种输入方式"><a href="#OJ系统中C语言各种输入方式" class="headerlink" title="OJ系统中C语言各种输入方式"></a>OJ系统中C语言各种输入方式</h2><p>ACM模式要求写出来的代码是直接可以本地运行的，所以我们需要自己写include哪些库函数，构造输入用例，构造输出用例，因此在OJ网站上做题时经常出现一种情况，那就是题会做，但是不知道多组输入如何处理，导致无法AC。</p>
<h3 id="输入一个数，并原样输出，测试数据有多组："><a href="#输入一个数，并原样输出，测试数据有多组：" class="headerlink" title="输入一个数，并原样输出，测试数据有多组："></a>输入一个数，并原样输出，测试数据有多组：</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(“%d”,&amp;a)!=EOF)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(“%d\n”,a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="先输入一个n，后输入一个共n个数的数组-输出这个数组："><a href="#先输入一个n，后输入一个共n个数的数组-输出这个数组：" class="headerlink" title="先输入一个n，后输入一个共n个数的数组,输出这个数组："></a>先输入一个n，后输入一个共n个数的数组,输出这个数组：</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(“%d”,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(“%d”,&amp;a[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="先输入一个n后输入一个共n个数的数组，最后在跟一个数X，在这n个数中查找x："><a href="#先输入一个n后输入一个共n个数的数组，最后在跟一个数X，在这n个数中查找x：" class="headerlink" title="先输入一个n后输入一个共n个数的数组，最后在跟一个数X，在这n个数中查找x："></a>先输入一个n后输入一个共n个数的数组，最后在跟一个数X，在这n个数中查找x：</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(“%d”,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(“%d”,&amp;a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">scanf</span>(“%d”,&amp;x);   </span><br></pre></td></tr></table></figure>
<h3 id="输入一组数，以0为结束标志："><a href="#输入一组数，以0为结束标志：" class="headerlink" title="输入一组数，以0为结束标志："></a>输入一组数，以0为结束标志：</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(“%d”,&amp;n),n!=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>示例1：输入一个数x再原样输出，测试数据有多组，以0为结束标志：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;	   </span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x),x!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例2：输入一个数组并原样输出，先输入一个n代表数组有n个数，测试数据有多组，以输入的n&#x3D;0时为结束标志：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>       </span><br><span class="line">&#123;                    </span><br><span class="line">    <span class="type">int</span> n,a[<span class="number">10</span>],i;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n),n!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">	   	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	   	    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[i]);</span><br><span class="line">	   	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二维数组的输入方式：第一行输入一个n，代表接下来输入一个n-n的二维矩阵："><a href="#二维数组的输入方式：第一行输入一个n，代表接下来输入一个n-n的二维矩阵：" class="headerlink" title="二维数组的输入方式：第一行输入一个n，代表接下来输入一个n*n的二维矩阵："></a>二维数组的输入方式：第一行输入一个n，代表接下来输入一个n*n的二维矩阵：</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(“%d”,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++）</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">        <span class="built_in">scanf</span>(“%d”,&amp;a[i][j]);</span><br></pre></td></tr></table></figure>
<p>示例：输入一个二维数组并原样输出，测试数据有多组：</p>
<blockquote>
<p>注意：每输入一组数据，按一次回车并输出一组的结果，然后再输入下一组测试数据再按回车再输出下一组的结果。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n,i,j,a[<span class="number">10</span>][<span class="number">10</span>]; </span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n)!=EOF) </span><br><span class="line">    &#123;           </span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) </span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;j++) </span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i][j]);   </span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) </span><br><span class="line">            &#123; </span><br><span class="line">                <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;j++) </span><br><span class="line">                &#123; </span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a[i][j]); </span><br><span class="line">                        <span class="keyword">if</span>(j!=n<span class="number">-1</span>) </span><br><span class="line">                            <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);   </span><br><span class="line">                &#125; </span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>); </span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="末尾加char"><a href="#末尾加char" class="headerlink" title="末尾加char()"></a>末尾加char()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(“%c”,&amp;c)!=EOF)             </span><br><span class="line">&#123;</span><br><span class="line">    末尾加getchar(); <span class="comment">//按了回车也算是输入了一个字符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例：输入一个字符，并判断字符串类型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">char</span> c; </span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;c)!=EOF) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">if</span>(c&gt;=<span class="string">&#x27;a&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;z&#x27;</span>||c&gt;=<span class="string">&#x27;A&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;Z&#x27;</span>) </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;alpha\n&quot;</span>); </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;numeric\n&quot;</span>); </span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;other\n&quot;</span>);</span><br><span class="line">		    getchar();</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;                      </span><br></pre></td></tr></table></figure>

<h3 id="字符串中不带空格"><a href="#字符串中不带空格" class="headerlink" title="字符串中不带空格"></a>字符串中不带空格</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(“%s”,&amp;str)!=EOF) </span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>示例：判断不含空格的字符串是由为回文串：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">char</span> s[<span class="number">100</span>]; </span><br><span class="line">    <span class="type">int</span> x,u,i; </span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s)!=EOF) </span><br><span class="line">    &#123;       </span><br><span class="line">        x=<span class="built_in">strlen</span>(s);</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;x;i++) </span><br><span class="line">        &#123;       </span><br><span class="line">            <span class="keyword">if</span>(s[i]!=s[x<span class="number">-1</span>-i]) </span><br><span class="line">            &#123; </span><br><span class="line">                u=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span>(s[i]==s[x<span class="number">-1</span>-i]) </span><br><span class="line">            &#123; </span><br><span class="line">                u=<span class="number">1</span>;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span>(u==<span class="number">1</span>) </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>); </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(u==<span class="number">0</span>) </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h3 id="输入不含空格的字符串数组"><a href="#输入不含空格的字符串数组" class="headerlink" title="输入不含空格的字符串数组"></a>输入不含空格的字符串数组</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s[i]); </span><br></pre></td></tr></table></figure>
<p>示例：输入一个n，后面跟n个无空格字符串，（相邻字符串要用空格隔开），输出字符串长度，测试数据有多组：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">int</span> n,i,j;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n)!=EOF) </span><br><span class="line">    &#123;      </span><br><span class="line">        <span class="type">int</span> a[<span class="number">20</span>]=&#123;<span class="number">0</span>&#125;;   </span><br><span class="line">        <span class="type">char</span> s[<span class="number">20</span>][<span class="number">60</span>]; </span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) </span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s[i]); </span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) </span><br><span class="line">        &#123; </span><br><span class="line">            a[i]=<span class="built_in">strlen</span>(s[i]); </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,s[i]);<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a[i]); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;               </span><br></pre></td></tr></table></figure>
<h3 id="带空格的字符串"><a href="#带空格的字符串" class="headerlink" title="带空格的字符串"></a>带空格的字符串</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(gets(str)!=<span class="literal">NULL</span>)    </span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>示例：判断多组含空格的字符串是否为回文串：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">char</span> s[<span class="number">100</span>]; </span><br><span class="line">    <span class="type">int</span> x,u,i;</span><br><span class="line">    <span class="keyword">while</span>(gets(s)!=<span class="literal">NULL</span>) </span><br><span class="line">    &#123;       </span><br><span class="line">        x=<span class="built_in">strlen</span>(s);</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;x;i++) </span><br><span class="line">        &#123;       </span><br><span class="line">            <span class="keyword">if</span>(s[i]!=s[x<span class="number">-1</span>-i]) </span><br><span class="line">            &#123; </span><br><span class="line">                u=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span>(s[i]==s[x<span class="number">-1</span>-i]) </span><br><span class="line">            &#123; </span><br><span class="line">                u=<span class="number">1</span>;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;                      </span><br><span class="line">        <span class="keyword">if</span>(u==<span class="number">1</span>) </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>); </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(u==<span class="number">0</span>) </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="输入字符串数组（含空格）"><a href="#输入字符串数组（含空格）" class="headerlink" title="输入字符串数组（含空格）"></a>输入字符串数组（含空格）</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n:i++)</span><br><span class="line">    gets(s[i]);</span><br></pre></td></tr></table></figure>
<p>示例：计算几行字符串的长度，第一行输入n，下面n行每一行输入一个含空格的字符串：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">int</span> n,i,j;</span><br><span class="line">    <span class="type">char</span> s[<span class="number">20</span>][<span class="number">60</span>]; </span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n)!=EOF) </span><br><span class="line">    &#123;      </span><br><span class="line">        <span class="type">int</span> a[<span class="number">20</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) </span><br><span class="line">            gets(s[i]); </span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) </span><br><span class="line">        &#123; </span><br><span class="line">            a[i]=<span class="built_in">strlen</span>(s[i]); </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a[i]); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试数据有T组，先输入一个组数T，接下来每一行第一个数为每组数的个数n，n的后面再跟n个数："><a href="#测试数据有T组，先输入一个组数T，接下来每一行第一个数为每组数的个数n，n的后面再跟n个数：" class="headerlink" title="测试数据有T组，先输入一个组数T，接下来每一行第一个数为每组数的个数n，n的后面再跟n个数："></a>测试数据有T组，先输入一个组数T，接下来每一行第一个数为每组数的个数n，n的后面再跟n个数：</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(“%d\n”,&amp;T);                                </span><br><span class="line"><span class="keyword">while</span>(T--)      <span class="comment">//当T减到0跳出循环</span></span><br><span class="line">&#123;    </span><br><span class="line">    <span class="built_in">scanf</span>(“%d”,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(“%d”,&amp;a[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例：输入一个一维数组，并原样输出，先输入一个T，代表有T组测试数据，下面T行每行第一个数n代表每个数组的元素个数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">int</span> n,i,a[<span class="number">10</span>],T;  </span><br><span class="line">    <span class="built_in">scanf</span>(“%d”,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);                          </span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="OJ系统中Python的多行输入"><a href="#OJ系统中Python的多行输入" class="headerlink" title="OJ系统中Python的多行输入"></a>OJ系统中Python的多行输入</h2><h3 id="input-与sys-stdin概述"><a href="#input-与sys-stdin概述" class="headerlink" title="input()与sys.stdin概述"></a>input()与sys.stdin概述</h3><p>在线判题系统（Online Judge）的多行输入问题分为定行输入与不定行输入。</p>
<p>若为定行输入，使用循环+input()即可解决。<br>若为不定行输入，还要看是否有输入结束的标志。</p>
<p>若不定行输入带结束标志，最简单的方法，使用while循环加结束判断语句即可。<br>若不定行输入不带结束标志，我们应当使用系统输入sys.stdin较为方便，也可使用其他方法。</p>
<p>这里要注意一点，不定行输入不带结束标志问题，在本地IDE上测试时，输入是自己定义的，输入结束你可以疯狂按回车键，如果你通过判断输入是否为空作为跳出循环的判断语句，你的代码可能可以运行正确，但是在OJ里这种判断方法是错误的，是不可取的。</p>
<h3 id="不定行输入有结束标志示例"><a href="#不定行输入有结束标志示例" class="headerlink" title="不定行输入有结束标志示例"></a>不定行输入有结束标志示例</h3><blockquote>
<p>题目描述 计算a+b</p>
<p>输入描述: 输入包括两个正整数a,b(1 &lt;&#x3D; a, b &lt;&#x3D; 10^9),输入数据有多组, 如果输入为0 0则结束输入</p>
<p>输出描述: 输出a+b的结果</p>
<p>示例：<br>输入<br>1 5<br>10 20<br>0 0</p>
<p>输出<br>6<br>30</p>
</blockquote>
<h4 id="方法1：sys-stdin"><a href="#方法1：sys-stdin" class="headerlink" title="方法1：sys.stdin"></a>方法1：sys.stdin</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> sys.stdin:</span><br><span class="line">    x,y = <span class="built_in">map</span>(<span class="built_in">int</span>, line.split())</span><br><span class="line">    <span class="keyword">if</span> x <span class="keyword">or</span> y:</span><br><span class="line">        <span class="built_in">print</span>(x+y)</span><br></pre></td></tr></table></figure>

<h4 id="方法2：while-input"><a href="#方法2：while-input" class="headerlink" title="方法2：while+input()"></a>方法2：while+input()</h4><p><em>注意：使用while循环时，必须加循环结束语句以保证一定能跳出循环，否则OJ不通过。</em></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    x,y = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    <span class="keyword">if</span> x == <span class="number">0</span> <span class="keyword">and</span> y == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="built_in">print</span>(x+y)</span><br></pre></td></tr></table></figure>

<h3 id="不定行输入无结束标志示例"><a href="#不定行输入无结束标志示例" class="headerlink" title="不定行输入无结束标志示例"></a>不定行输入无结束标志示例</h3><blockquote>
<p>题目描述 计算a+b</p>
<p>输入描述: 输入包括两个正整数a,b(1 &lt;&#x3D; a, b &lt;&#x3D; 10^9),输入数据有多组, 如果输入为0 0则结束输入</p>
<p>输出描述: 输出a+b的结果</p>
<p>示例：<br>输入<br>1 5<br>10 20<br>0 0</p>
<p>输出<br>6<br>30</p>
</blockquote>
<h4 id="方法1：sys-stdin-1"><a href="#方法1：sys-stdin-1" class="headerlink" title="方法1：sys.stdin"></a>方法1：sys.stdin</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> sys.stdin:</span><br><span class="line">    a,b = <span class="built_in">map</span>(<span class="built_in">int</span>, line.split())</span><br><span class="line">    <span class="built_in">print</span>(a+b)</span><br></pre></td></tr></table></figure>

<h4 id="方法2：while-input-1"><a href="#方法2：while-input-1" class="headerlink" title="方法2：while+input()"></a>方法2：while+input()</h4><p><em>多行输入没有结束标志时，若使用while循环，我们应当使用try，except语句。如下：</em></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        a,b = <span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">input</span>().split())</span><br><span class="line">        <span class="built_in">print</span>(a+b)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<p><em>通过判断输入是否为空作为跳出循环的判断语句，是错误的，如下：</em></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    line = <span class="built_in">input</span>()</span><br><span class="line">    <span class="keyword">if</span> line == <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        a,b = <span class="built_in">map</span>(<span class="built_in">int</span>,line.split())</span><br><span class="line">        <span class="built_in">print</span>(a+b)</span><br></pre></td></tr></table></figure>

<h3 id="代码样例"><a href="#代码样例" class="headerlink" title="代码样例"></a>代码样例</h3><h4 id="输入为int"><a href="#输入为int" class="headerlink" title="输入为int"></a>输入为int</h4><ol>
<li><p>输入包括两个正整数a和b，输入数据包含多组。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">line = sys.stdin.readlines()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">    numlist = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, line.split()))</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">sum</span>(numlist))</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 输入第一行包括一个数据组数t，接下来每行包括两个正整数a，b，求a+b的结果。</span><br><span class="line">```python</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">lines = sys.stdin.readlines()</span><br><span class="line">n = <span class="built_in">int</span>(lines[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    numList = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, lines[i+<span class="number">1</span>].split()))</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">sum</span>(numList))</span><br></pre></td></tr></table></figure>
</li>
<li><p>输入包括两个正整数a，b，输入数据有多组，如果输入为0，则结束输入。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    a,b = <span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">input</span>().split())</span><br><span class="line">    <span class="keyword">if</span> a== <span class="number">0</span> <span class="keyword">and</span> b == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(a+b)</span><br></pre></td></tr></table></figure>
</li>
<li><p>计算一系列数的和，输入包括多组数据。每组数据一行，每行的第一个整数为整数的个数n，n为0得时候结束输入。接下来的n个正整数，即需要求和的每个正整数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    a = [<span class="built_in">int</span>(each) <span class="keyword">for</span> each <span class="keyword">in</span> <span class="built_in">input</span>().split()]</span><br><span class="line">    <span class="keyword">if</span> a[<span class="number">0</span>]==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">sum</span>(a[<span class="number">1</span>:]))</span><br></pre></td></tr></table></figure>
</li>
<li><p>计算一系列数的和，输入的第一行包括一个正整数t，表示数据组数。接下来的t行，每行一组数据。每行的第一个整数为整数的个数n，接下来的n个正整数，即需要求和的每个正整数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    numList = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">sum</span>(numList[<span class="number">1</span>:]))</span><br></pre></td></tr></table></figure>
</li>
<li><p>计算一系列数的和，输入数据有多组，每行表示一组输入数据。每行的第一个整数为整数的个数n。接下来的n个正整数，即需要求和的每个正整数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">lines = sys.stdin.readlines()</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">    numList = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, line.split()))</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">sum</span>(numList[<span class="number">1</span>:]))</span><br></pre></td></tr></table></figure></li>
<li><p>计算一系列数的和，输入数据有多组，每行表示一组输入数据。每行不定有n个整数，空格隔开。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> sys.stdin:</span><br><span class="line">    a  = line.split()</span><br><span class="line">    ret = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(a)):</span><br><span class="line">        ret += <span class="built_in">int</span>(a[i])</span><br><span class="line">    <span class="built_in">print</span>(ret)</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="输入为字符串"><a href="#输入为字符串" class="headerlink" title="输入为字符串"></a>输入为字符串</h4><ol>
<li><p>对输入的字符串进行排序后输出。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        n = <span class="built_in">input</span>()</span><br><span class="line">        strList = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">str</span>, <span class="built_in">input</span>().split()))</span><br><span class="line">        strList.sort()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27; &#x27;</span>.joint(strList))</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>对输入的字符串进行排序后输出。多个测试用例，每个测试用例一行。每行用空格隔开，有n个字符。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        arr = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">str</span>, <span class="built_in">input</span>().split()))</span><br><span class="line">        arr.sort()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27; &#x27;</span>.join(arr))</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>对输入的字符串进行排序后输出。多个测试用例，每个测试用例一行。每行通过，隔开，有n个字符。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        a = <span class="built_in">input</span>().split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">        a.sort()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;,&quot;</span>.join(a))</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h4><ol>
<li><p>输入一个字符串，拆分成单个字符的列表。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">str_input = sys.stdin.readline().split()</span><br><span class="line">strList = [i <span class="keyword">for</span> i <span class="keyword">in</span> str_input[<span class="number">0</span>]]</span><br><span class="line"><span class="built_in">print</span>(strList)</span><br></pre></td></tr></table></figure>
</li>
<li><p>第一行表示接下来要输入几组数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">count = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line">queue = []</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(count[<span class="number">0</span>]):</span><br><span class="line">    queue.append(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())))</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>ADB命令备忘清单</title>
    <url>/blog/adb-manual/</url>
    <content><![CDATA[<div class="note info">

<ul>
<li>ADB 即 Android Debug Bridge，是 Google 的 Android SDK 中的一个命令行工具，可让计算机控制 Android 设备执行各种设备操作。</li>
<li>本文整理一些 <a href="https://developer.android.com/studio/command-line/adb.html">ADB</a> 使用时最常见的命令及其用法。</li>
</ul>
</div>

<span id="more"></span>

<h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><h3 id="设备基础"><a href="#设备基础" class="headerlink" title="设备基础"></a>设备基础</h3><!--rehype:wrap-class=row-span-2-->

<table>
<thead>
<tr>
<th align="left">Command</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>adb devices</code></td>
<td>列出已连接的设备</td>
</tr>
<tr>
<td align="left"><code>adb devices -l</code></td>
<td>列出已连接的设备和种类</td>
</tr>
<tr>
<td align="left"><code>adb connect [IP:PORT]</code></td>
<td>连接到指定 IP 和端口的设备</td>
</tr>
<tr>
<td align="left"><code>adb disconnect [IP:PORT]</code></td>
<td>断开指定 IP 和端口的设备连接，若未指定，则断开所有连接</td>
</tr>
<tr>
<td align="left"><code>adb root</code></td>
<td>以 <code>root</code> 权限重新启动 <code>adbd</code></td>
</tr>
<tr>
<td align="left"><code>adb start-server</code></td>
<td>启动 <code>adb</code> 服务</td>
</tr>
<tr>
<td align="left"><code>adb kill-server</code></td>
<td>停止 <code>adb</code> 服务</td>
</tr>
<tr>
<td align="left"><code>adb remount</code></td>
<td>重新挂载具有读&#x2F;写访问权限的文件系统</td>
</tr>
<tr>
<td align="left"><code>adb reboot</code></td>
<td>重启设备</td>
</tr>
<tr>
<td align="left"><code>adb reboot bootloader</code></td>
<td>将设备重启到 fastboot 模式</td>
</tr>
<tr>
<td align="left"><code>adb reboot recovery</code></td>
<td>将设备重启到恢复模式</td>
</tr>
<tr>
<td align="left"><code>adb disable-verity</code></td>
<td>禁用设备的 dm-verity 安全特性</td>
</tr>
</tbody></table>
<!--rehype:className=left-align code-nowrap-->

<hr>
<ul>
<li><code>wait-for-device</code> 可以在 <code>adb</code> 之后指定，以确保该命令在设备连接后运行</li>
<li><code>-s</code> 可用于在多个连接时将命令发送到特定设备</li>
</ul>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ adb wait-for-device devices</span><br><span class="line"> List of devices attached</span><br><span class="line"> somedevice-1234 device</span><br><span class="line"> someotherdevice-1234 device</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ adb -s somedevice-1234 root</span><br></pre></td></tr></table></figure>

<h3 id="Logcat"><a href="#Logcat" class="headerlink" title="Logcat"></a>Logcat</h3><!--rehype:wrap-class=row-span-2-->

<table>
<thead>
<tr>
<th align="left">Command</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>adb logcat</code></td>
<td>将日志消息打印到标准输出</td>
</tr>
<tr>
<td align="left"><code>adb logcat -g</code></td>
<td>显示当前日志缓冲区大小</td>
</tr>
<tr>
<td align="left"><code>adb logcat -G &lt;size&gt;</code></td>
<td>设置缓冲区大小（K 或 M）</td>
</tr>
<tr>
<td align="left"><code>adb logcat -c</code></td>
<td>清除日志缓冲区</td>
</tr>
<tr>
<td align="left"><code>adb logcat *:V</code></td>
<td>启用所有日志消息（详细）</td>
</tr>
<tr>
<td align="left"><code>adb logcat -f &lt;filename&gt;</code></td>
<td>将日志转储到指定文件</td>
</tr>
</tbody></table>
<!--rehype:className=left-align code-nowrap-->

<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ adb logcat -G 16M</span><br><span class="line">$ adb logcat *:V &gt; output.log</span><br></pre></td></tr></table></figure>

<h4 id="过滤日志输出"><a href="#过滤日志输出" class="headerlink" title="过滤日志输出"></a>过滤日志输出</h4><ul>
<li><code>V</code> 最详细的信息(最低优先级)</li>
<li><code>D</code> 调试信息</li>
<li><code>I</code> 普通信息</li>
<li><code>W</code> 警告信息</li>
<li><code>E</code> 错误信息</li>
<li><code>F</code> 致命错误信息</li>
<li><code>S</code> 静默(最高优先级)<!--rehype:className=cols-2 shortcuts style-none--></li>
</ul>
<p>例如，要显示优先级不低于 <code>警告</code> 的所有标记的所有日志消息，可以使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ adb logcat *:W</span><br></pre></td></tr></table></figure>

<h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h3><table>
<thead>
<tr>
<th align="left">Command</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>adb push &lt;local&gt; &lt;remote&gt;</code></td>
<td>将本地文件复制到远程设备</td>
</tr>
<tr>
<td align="left"><code>adb pull &lt;remote&gt; &lt;local&gt;</code></td>
<td>将远程设备文件复制到本地</td>
</tr>
</tbody></table>
<!--rehype:className=left-align code-nowrap-->

<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;This is a test&quot;</span> &gt; test.txt</span><br><span class="line">$ adb push  test.txt /sdcard/test.txt</span><br><span class="line">$ adb pull /sdcard/test.txt pulledTest.txt</span><br></pre></td></tr></table></figure>

<h3 id="远程-Shell"><a href="#远程-Shell" class="headerlink" title="远程 Shell"></a>远程 Shell</h3><table>
<thead>
<tr>
<th align="left">Command</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>adb shell &lt;command&gt;</code></td>
<td>在设备上运行指定的命令（大多数 Unix 命令在这里工作）</td>
</tr>
<tr>
<td align="left"><code>adb shell wm size</code></td>
<td>显示当前屏幕分辨率</td>
</tr>
<tr>
<td align="left"><code>adb shell wm size WxH</code></td>
<td>将分辨率设置为 WxH</td>
</tr>
<tr>
<td align="left"><code>adb shell pm list packages</code></td>
<td>列出所有已安装的应用包</td>
</tr>
<tr>
<td align="left"><code>adb shell pm list packages -3</code></td>
<td>列出所有已安装的第三方的应用包</td>
</tr>
<tr>
<td align="left"><code>adb shell monkey -p app.package.name</code></td>
<td>启动指定包名的应用程序</td>
</tr>
</tbody></table>
<!--rehype:className=style-list-arrow-->

<h3 id="包安装"><a href="#包安装" class="headerlink" title="包安装"></a>包安装</h3><table>
<thead>
<tr>
<th align="left">Command</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>adb shell install &lt;apk&gt;</code></td>
<td>安装应用程序</td>
</tr>
<tr>
<td align="left"><code>adb shell install &lt;path&gt;</code></td>
<td>从手机路径安装应用</td>
</tr>
<tr>
<td align="left"><code>adb shell install -r &lt;path&gt;</code></td>
<td>从手机路径安装应用（允许覆盖安装）</td>
</tr>
<tr>
<td align="left"><code>adb shell uninstall &lt;name&gt;</code></td>
<td>卸载应用程序</td>
</tr>
</tbody></table>
<!--rehype:className=left-align code-nowrap-->

<h3 id="Paths"><a href="#Paths" class="headerlink" title="Paths"></a>Paths</h3><!--rehype:wrap-class=row-span-2-->

<table>
<thead>
<tr>
<th align="left">Command</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>/data/data/&lt;package&gt;/databases</code></td>
<td>应用程序数据库</td>
</tr>
<tr>
<td align="left"><code>/data/data/&lt;package&gt;/shared_prefs/</code></td>
<td>共享偏好设置</td>
</tr>
<tr>
<td align="left"><code>/data/app</code></td>
<td>用户安装的 APK</td>
</tr>
<tr>
<td align="left"><code>/system/app</code></td>
<td>系统预装的 APK 文件</td>
</tr>
<tr>
<td align="left"><code>/mmt/asec</code></td>
<td>加密的应用程序（App2SD）</td>
</tr>
<tr>
<td align="left"><code>/mmt/emmc</code></td>
<td>内部 SD 卡</td>
</tr>
<tr>
<td align="left"><code>/mmt/adcard</code></td>
<td>外部&#x2F;内部 SD 卡</td>
</tr>
<tr>
<td align="left"><code>/mmt/adcard/external_sd</code></td>
<td>外置 SD 卡</td>
</tr>
</tbody></table>
<!--rehype:className=style-list-arrow-->

<hr>
<table>
<thead>
<tr>
<th align="left">Command</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>adb shell ls</code></td>
<td>列出目录内容</td>
</tr>
<tr>
<td align="left"><code>adb shell ls -s</code></td>
<td>每个文件的打印尺寸</td>
</tr>
<tr>
<td align="left"><code>adb shell ls -R</code></td>
<td>递归列出子目录</td>
</tr>
</tbody></table>
<!--rehype:className=left-align code-nowrap-->

<h3 id="手机信息"><a href="#手机信息" class="headerlink" title="手机信息"></a>手机信息</h3><!--rehype:wrap-class=row-span-2-->

<table>
<thead>
<tr>
<th align="left">Command</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>adb get-statе</code></td>
<td>打印设备状态</td>
</tr>
<tr>
<td align="left"><code>adb get-serialno</code></td>
<td>获取设备的序列号</td>
</tr>
<tr>
<td align="left"><code>adb shell dumpsys iphonesybinfo</code></td>
<td>获取设备的 IMEI 信息</td>
</tr>
<tr>
<td align="left"><code>adb shell netstat</code></td>
<td>列出设备上的所有 TCP 连接</td>
</tr>
<tr>
<td align="left"><code>adb shell pwd</code></td>
<td>打印当前工作目录</td>
</tr>
<tr>
<td align="left"><code>adb shell dumpsys battery</code></td>
<td>获取设备电池状态</td>
</tr>
<tr>
<td align="left"><code>adb shell pm list features</code></td>
<td>列出设备支持的所有功能</td>
</tr>
<tr>
<td align="left"><code>adb shell service list</code></td>
<td>列出设备上运行的所有服务</td>
</tr>
<tr>
<td align="left"><code>adb shell dumpsys activity &lt;package&gt;/&lt;activity&gt;</code></td>
<td>获取指定包和活动的信息</td>
</tr>
<tr>
<td align="left"><code>adb shell ps</code></td>
<td>打印设备上所有运行的进程状态</td>
</tr>
<tr>
<td align="left"><code>adb shell wm size</code></td>
<td>显示当前设备的屏幕分辨率</td>
</tr>
<tr>
<td align="left"><code>dumpsys window windows</code> | <code>grep -E &#39;mCurrentFocus|mFocusedApp&#39;</code></td>
<td>打印当前应用程序的打开活动的信息</td>
</tr>
</tbody></table>
<!--rehype:className=style-list-arrow-->

<h3 id="包信息"><a href="#包信息" class="headerlink" title="包信息"></a>包信息</h3><table>
<thead>
<tr>
<th align="left">Command</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>adb shell list packages</code></td>
<td>列出包名称</td>
</tr>
<tr>
<td align="left"><code>adb shell list packages -r</code></td>
<td>列出包名 + apks 的路径</td>
</tr>
<tr>
<td align="left"><code>adb shell list packages -3</code></td>
<td>列出第三方包名称</td>
</tr>
<tr>
<td align="left"><code>adb shell list packages -s</code></td>
<td>仅列出系统包</td>
</tr>
<tr>
<td align="left"><code>adb shell list packages -u</code></td>
<td>列出包名称 + 已卸载</td>
</tr>
<tr>
<td align="left"><code>adb shell dumpsys package packages</code></td>
<td>列出所有应用程序的信息</td>
</tr>
<tr>
<td align="left"><code>adb shell dump &lt;name&gt;</code></td>
<td>列出一个包的信息</td>
</tr>
<tr>
<td align="left"><code>adb shell path &lt;package&gt;</code></td>
<td>列出 APK 文件的路径</td>
</tr>
</tbody></table>
<!--rehype:className=style-list-arrow-->

<h3 id="设备相关命令"><a href="#设备相关命令" class="headerlink" title="设备相关命令"></a>设备相关命令</h3><!--rehype:wrap-class=col-span-2 row-span-2-->

<table>
<thead>
<tr>
<th align="left">Command</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>adb reboot recovery</code></td>
<td>重启设备进入恢复模式</td>
</tr>
<tr>
<td align="left"><code>adb reboot fastboot</code></td>
<td>重启设备进入恢复模式</td>
</tr>
<tr>
<td align="left"><code>adb shell screencap -p &quot;/path/to/screenshot.png&quot;</code></td>
<td>截图</td>
</tr>
<tr>
<td align="left"><code>adb shell screenrecord &quot;/path/to/record.mp4&quot;</code></td>
<td>录制设备屏幕</td>
</tr>
<tr>
<td align="left"><code>adb backup -apk -all -f backup.ab</code></td>
<td>备份设置和应用程序</td>
</tr>
<tr>
<td align="left"><code>adb backup -apk -shared -all -f backup.ab</code></td>
<td>备份设置、应用程序和共享存储</td>
</tr>
<tr>
<td align="left"><code>adb backup -apk -nosystem -all -f backup.ab</code></td>
<td>仅备份非系统应用程序</td>
</tr>
<tr>
<td align="left"><code>adb restore backup.ab</code></td>
<td>恢复以前的备份</td>
</tr>
<tr>
<td align="left"><code>adb shell am start -a android.intent.action.VIEW -d URL</code></td>
<td>打开网址</td>
</tr>
<tr>
<td align="left"><code>adb shell am start -t image/* -a android.intent.action.VIEW</code></td>
<td>打开画廊</td>
</tr>
</tbody></table>
<!--rehype:className=code-nowrap left-align-->

<h3 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h3><table>
<thead>
<tr>
<th align="left">Command</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>adb shell permissions groups</code></td>
<td>列出所有已定义的权限组</td>
</tr>
<tr>
<td align="left"><code>adb shell list permissions -g -r</code></td>
<td>列出了所有权限的详细信息</td>
</tr>
</tbody></table>
<!--rehype:className=style-list-arrow-->

<h3 id="Logs"><a href="#Logs" class="headerlink" title="Logs"></a>Logs</h3><table>
<thead>
<tr>
<th align="left">Command</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>adb logcat [options] [filter] [filter]</code></td>
<td>查看设备日志</td>
</tr>
<tr>
<td align="left"><code>adb bugreport</code></td>
<td>打印错误报告</td>
</tr>
</tbody></table>
<!--rehype:className=style-list-arrow-->

<h2 id="常见的-ADB-命令"><a href="#常见的-ADB-命令" class="headerlink" title="常见的 ADB 命令"></a>常见的 ADB 命令</h2><h3 id="将文件推送到-Android-设备的下载文件夹"><a href="#将文件推送到-Android-设备的下载文件夹" class="headerlink" title="将文件推送到 Android 设备的下载文件夹"></a>将文件推送到 Android 设备的下载文件夹</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ adb push example.apk /sdcard/Download/</span><br></pre></td></tr></table></figure>

<h3 id="列出所有已安装的包并获取完整路径"><a href="#列出所有已安装的包并获取完整路径" class="headerlink" title="列出所有已安装的包并获取完整路径"></a>列出所有已安装的包并获取完整路径</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ adb shell pm list packages -f</span><br></pre></td></tr></table></figure>

<h3 id="从安卓设备中提取文件"><a href="#从安卓设备中提取文件" class="headerlink" title="从安卓设备中提取文件"></a>从安卓设备中提取文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ adb pull /sdcard/Download/example.apk</span><br></pre></td></tr></table></figure>

<h3 id="从主机安装-APK-到-Android-设备"><a href="#从主机安装-APK-到-Android-设备" class="headerlink" title="从主机安装 APK 到 Android 设备"></a>从主机安装 APK 到 Android 设备</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ adb shell install example.apk</span><br></pre></td></tr></table></figure>

<h3 id="从-Android-设备存储安装-APK"><a href="#从-Android-设备存储安装-APK" class="headerlink" title="从 Android 设备存储安装 APK"></a>从 Android 设备存储安装 APK</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ adb shell install /sdcard/Download/example.apk</span><br></pre></td></tr></table></figure>

<h3 id="设置网络代理"><a href="#设置网络代理" class="headerlink" title="设置网络代理"></a>设置网络代理</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ adb shell settings put global http_proxy &lt;address&gt;:&lt;port&gt;</span><br></pre></td></tr></table></figure>

<h3 id="禁用网络代理"><a href="#禁用网络代理" class="headerlink" title="禁用网络代理"></a>禁用网络代理</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ adb shell settings put global http_proxy :0</span><br></pre></td></tr></table></figure>

<h3 id="显示连接的设备并指定一个设备进行-Shell"><a href="#显示连接的设备并指定一个设备进行-Shell" class="headerlink" title="显示连接的设备并指定一个设备进行 Shell"></a>显示连接的设备并指定一个设备进行 Shell</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ adb devices</span><br><span class="line">$ adb -s 7f1c864e shell</span><br></pre></td></tr></table></figure>

<p><code>7f1c864e</code> 是设备 <code>ID</code></p>
<h3 id="通过-IP-地址连接到设备"><a href="#通过-IP-地址连接到设备" class="headerlink" title="通过 IP 地址连接到设备"></a>通过 IP 地址连接到设备</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ adb connect 192.168.56.101:5555</span><br></pre></td></tr></table></figure>

<h3 id="通过-Wi-Fi-连接-ADB"><a href="#通过-Wi-Fi-连接-ADB" class="headerlink" title="通过 Wi-Fi 连接 ADB"></a>通过 Wi-Fi 连接 ADB</h3><!--rehype:wrap-class=row-span-5-->

<p>我们可以通过 <code>Wi-Fi</code> 或专门使用 <code>tcp</code> 连接使用 <code>adb</code>。 要通过 <code>Wi-Fi</code> 使用 <code>adb</code>，首先通过 <code>USB</code> 连接手机并启用 <code>USB</code> 调试。然后列出所有设备：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ adb devices</span><br><span class="line"><span class="comment"># 这应该给出这样的输出：</span></span><br><span class="line"><span class="comment"># device_id    device</span></span><br></pre></td></tr></table></figure>

<p>现在检查 <code>Android</code> 设备的 <code>IP</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ adb shell ifconfig</span><br><span class="line"><span class="comment"># 输出:</span></span><br><span class="line"></span><br><span class="line">wlan0  Link encap:UNSPEC    Driver icnss</span><br><span class="line">       inet addr:XXX.XXX.X.XX  Bcast:XXX.XXX.X.XXX</span><br></pre></td></tr></table></figure>

<p>记下 <code>inet addr</code> 后的 <code>IP</code> 地址。稍后要用。现在在某个端口重新启动 <code>tcpip</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ adb tcpip <span class="variable">$port</span></span><br></pre></td></tr></table></figure>

<p>例如 5555：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ adb tcpip 5555</span><br></pre></td></tr></table></figure>

<p>现在可以断开 USB 线缆使用。 若要连接到设备请键入以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ adb connect <span class="variable">$ip</span>:<span class="variable">$port</span></span><br></pre></td></tr></table></figure>

<p>例如:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ adb connect 192.168.1.4:5555</span><br></pre></td></tr></table></figure>

<h3 id="将计算机上的-APK-文件安装到设备"><a href="#将计算机上的-APK-文件安装到设备" class="headerlink" title="将计算机上的 APK 文件安装到设备"></a>将计算机上的 APK 文件安装到设备</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ adb install /Users/dev/projects/myapp.apk</span><br></pre></td></tr></table></figure>

<h3 id="查找应用的-APK-路径"><a href="#查找应用的-APK-路径" class="headerlink" title="查找应用的 APK 路径"></a>查找应用的 APK 路径</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ adb shell pm path com.example.myapp</span><br></pre></td></tr></table></figure>

<p>将 <code>com.example.myapp</code> 替换为自己的应用程序包名称</p>
<h3 id="通过名称查找应用的包名"><a href="#通过名称查找应用的包名" class="headerlink" title="通过名称查找应用的包名"></a>通过名称查找应用的包名</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ adb shell pm list package | grep app_name</span><br></pre></td></tr></table></figure>

<h3 id="从设备提取-APK-到计算机"><a href="#从设备提取-APK-到计算机" class="headerlink" title="从设备提取 APK 到计算机"></a>从设备提取 APK 到计算机</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ adb pull /data/app/com.example.myapp.apk ./</span><br></pre></td></tr></table></figure>

<h3 id="将文件从计算机复制到设备"><a href="#将文件从计算机复制到设备" class="headerlink" title="将文件从计算机复制到设备"></a>将文件从计算机复制到设备</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ adb push path/to/local/file /sdcard/foo.txt</span><br></pre></td></tr></table></figure>

<h3 id="滚动屏幕"><a href="#滚动屏幕" class="headerlink" title="滚动屏幕"></a>滚动屏幕</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ adb shell input swipe 300 300 500 1000 <span class="comment"># 上</span></span><br><span class="line">$ adb shell input swipe 500 1000 300 300 <span class="comment"># 下</span></span><br></pre></td></tr></table></figure>

<h3 id="发文本"><a href="#发文本" class="headerlink" title="发文本"></a>发文本</h3><p>使用虚拟键盘发送文本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ adb shell input text <span class="string">&quot;Hello World&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="发送按键事件"><a href="#发送按键事件" class="headerlink" title="发送按键事件"></a>发送按键事件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ adb shell input keyevent 66</span><br><span class="line"><span class="comment"># 66 是回车键码</span></span><br></pre></td></tr></table></figure>

<h3 id="发送点击"><a href="#发送点击" class="headerlink" title="发送点击"></a>发送点击</h3><p>点击屏幕：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ adb shell input tap x y</span><br></pre></td></tr></table></figure>

<h3 id="查看包的日志"><a href="#查看包的日志" class="headerlink" title="查看包的日志"></a>查看包的日志</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ adb shell <span class="string">&#x27;logcat --pid=$(pidof -s &lt;package_name&gt;)&#x27;</span></span><br></pre></td></tr></table></figure>

<p>查看特定包的日志</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>A collection of code snippets</title>
    <url>/blog/code-segment/</url>
    <content><![CDATA[<div class="note info">

<p>这里是一些代码段以及常用指令的集合，可能是来自网上的，也可能是平时的积累，常看常新，learning by doing ~</p>
</div>

<span id="more"></span>

<h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>万能头函数，包含了C++标准库中几乎所有的头文件。<br>优点可以简化代码，可以节省一些输入的时间，在编程竞赛中很常用。<br>缺点是包含了很多不必要的头文件，可能会导致编译时间增加，实际的项目开发中不推荐使用。</p>
</blockquote>
<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>用来优化输入&#x2F;输出流的一个方法，在使用输入&#x2F;输出流之前调用，并且只需要调用一次。<br>调用后C++的标准输入&#x2F;输出流和C的标准输入&#x2F;输出流就不再同步，优点是由于取消了同步，<code>cin</code>和<code>cout</code>的性能会得到提升。<br>同时这意味着不能再混合使用<code>cin</code>&#x2F;<code>cout</code>和<code>scanf</code>&#x2F;<code>printf</code>，否则可能会导致未定义的行为。</p>
</blockquote>
<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::priority_queue&lt;<span class="type">int</span>&gt; pq;</span><br><span class="line">std::priority_queue&lt;<span class="type">int</span>, std::vector&lt;<span class="type">int</span>&gt;, std::greater&lt;<span class="type">int</span>&gt;&gt; pq;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>priority_queue</code>是C++标准库中的一个容器适配器，它提供了优先队列的功能。<br>优先队列是一种特殊的队列，每次出队的元素是当前队列中优先级最高的元素。<br>默认创建一个最大堆，也就是说每次出队的元素是当前队列中的最大元素,可以通过提供自定义的比较函数来改变这个行为。</p>
</blockquote>
<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">2</span>) &lt;&lt; floatNum &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>将浮点数a以固定的格式和2位的精度输出，然后输出一个换行符。<br>例如，如果a的值为3.14159，那么这段代码会输出3.14。</p>
</blockquote>
<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; year &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; <span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; <span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) &lt;&lt; month &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; <span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; <span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) &lt;&lt; day &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出一个日期，日期的格式为”年-月-日”，并且月和日都是两位数，如果不足两位则在前面补0。<br>例如，如果year的值为1999，month的值为9，day的值为14，那么这段代码会输出1999-09-14。</p>
</blockquote>
<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::string str = <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="type">int</span> num = std::<span class="built_in">stoi</span>(str);</span><br><span class="line"></span><br><span class="line">std::string str = <span class="string">&quot;123.45&quot;</span>;</span><br><span class="line"><span class="type">float</span> num = std::<span class="built_in">stof</span>(str);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> num = <span class="number">123</span>;</span><br><span class="line">std::string str = std::<span class="built_in">to_string</span>(num);</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> num = <span class="number">123.45</span>;</span><br><span class="line">std::string str = std::<span class="built_in">to_string</span>(num);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>string → int:   <code>std::stoi</code><br>string → float: <code>std::stof</code><br>int → string:   <code>std::to_string</code><br>float → string: <code>std::to_string</code></p>
</blockquote>
<hr>
<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="type">int</span> num = <span class="built_in">atoi</span>(str);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, num);  <span class="comment">// 输出：123</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> num = <span class="number">123</span>;</span><br><span class="line"><span class="type">char</span> str[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">itoa</span>(num, str, <span class="number">10</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str);  <span class="comment">// 输出：123</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>用于数字和字符串之间转换的函数<br>ASCII to integer: <code>atoi()</code>，接收字符数组形式的字符串，转换为对应的整数。如果字符串不能转换为有效的整数，或者字符串为空，<code>atoi()</code>函数将返回 0。<br>integer to ASCII: <code>itoa()</code>，接收一个整数和一个字符数组，并将证书转换为字符串传出在字符数组中。<code>itoa()</code>还接受一个第三个参数，用于指定转换的基数（例如，10 表示十进制，16 表示十六进制）</p>
</blockquote>
<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>&#125;;</span><br><span class="line">std::<span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line">vec.<span class="built_in">erase</span>(std::<span class="built_in">unique</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>()), vec.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用<code>std::sort</code>和<code>std::unique</code>函数来去除<code>std::vector</code>中的重复元素。<br>首先，使用<code>std::sort</code>函数对<code>std::vector</code>进行排序。这是因为<code>std::unique</code>函数只能去除相邻的重复元素，所以需要先进行排序。<br>然后，使用<code>std::unique</code>函数去除<code>std::vector</code>中的重复元素。<code>std::unique</code>函数会将所有重复的元素移到<code>std::vector</code>的末尾，并返回一个迭代器指向第一个重复元素。<br>最后，使用<code>std::vector::erase</code>函数删除所有重复的元素。</p>
</blockquote>
<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> max_it = *std::<span class="built_in">max_element</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>
<blockquote>
<p>找到<code>std::vector</code>中的最大值并将其赋值给max_it<br><code>std::max_element</code>函数返回一个指向最大元素的迭代器，使用*操作符来获取这个元素的值。<br>注意的是，如果<code>std::vector</code>是空的，那么<code>std::max_element</code>会返回<code>v.end()</code>，这是一个无效的迭代器，不能对它进行解引用。</p>
</blockquote>
<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">min</span>()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>常量表达式，它返回int类型可以表示的最小值，通常是-2147483648。<br>同理<code>std::numeric_limits&lt;int&gt;::max()</code>返回int类型可以表示的最大值，<code>std::numeric_limits&lt;double&gt;::epsilon()</code>返回double类型的机器epsilon。</p>
</blockquote>
<hr>
<h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="number">3.14159</span></span><br><span class="line">y = <span class="number">2.71828</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&#123;0:.1f&#125; &#123;0:.2f&#125; &#123;0:.3f&#125;, &#123;1:.3f&#125;&quot;</span>.<span class="built_in">format</span>(x, y))</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Python字符串格式化表达式，这段代码会输出<code>&quot;3.1 3.14 3.141, 2.718&quot;</code><br><code>&#123;&#125;</code>：这是一个占位符，它会被.format()方法中的参数替换。<br><code>0</code>：这是格式说明符中的字段名，表示.format()方法中的第一个参数。如果.format()方法中有多个参数，你可以通过改变这个数字来选择不同的参数。<br><code>:</code>：这是格式说明符的开始，它后面的内容用于控制参数的输出格式。<br><code>.3</code>：这是精度，表示小数点后的位数。在这里，它设置精度为3，也就是小数点后有三位。<br><code>f</code>：这是格式类型，表示浮点数。它会将参数转换为浮点数，并按照前面的精度输出。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># worse</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;My name is %s and weight is %d kg!&quot;</span> % (<span class="string">&#x27;Zara&#x27;</span>, <span class="number">21</span>)   <span class="comment">#Python2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># better 1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;My name is &#123;&#125; and weight is &#123;&#125; kg!&quot;</span>.<span class="built_in">format</span>(<span class="string">&#x27;Zara&#x27;</span>, <span class="number">21</span>))  <span class="comment">#Python3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># better 2</span></span><br><span class="line">name = <span class="string">&#x27;Zara&#x27;</span></span><br><span class="line">weight = <span class="number">21</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;My name is <span class="subst">&#123;name&#125;</span> and weight is <span class="subst">&#123;weight&#125;</span> kg!&quot;</span>)  <span class="comment">#Python3</span></span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(math.sin(math.radians(<span class="number">30</span>)))</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在Python的math模块中，所有的三角函数（如sin、cos等）都接受的是弧度值，而不是角度值。所以，需要先要用<code>math.radians()</code>转换为弧度。</p>
</blockquote>
<hr>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr = <span class="built_in">input</span>()</span><br><span class="line">num = [<span class="built_in">int</span>(n) <span class="keyword">for</span> n <span class="keyword">in</span> arr.split()]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>标准输入读取一行文本，然后将这行文本分割为多个字符串，再将这些字符串转换为整数，并将这些整数存储在一个列表中。</p>
</blockquote>
<hr>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;ASCII value of &#x27;A&#x27;:&quot;</span>, <span class="built_in">ord</span>(<span class="string">&#x27;A&#x27;</span>))  <span class="comment"># Output: 65</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;ASCII value of &#x27;Z&#x27;:&quot;</span>, <span class="built_in">ord</span>(<span class="string">&#x27;Z&#x27;</span>))  <span class="comment"># Output: 90</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;ASCII value of &#x27;a&#x27;:&quot;</span>, <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>))  <span class="comment"># Output: 97</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;ASCII value of &#x27;z&#x27;:&quot;</span>, <span class="built_in">ord</span>(<span class="string">&#x27;z&#x27;</span>))  <span class="comment"># Output: 122</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Character for ASCII value 65:&quot;</span>, <span class="built_in">chr</span>(<span class="number">65</span>))     <span class="comment"># Output: &#x27;A&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Character for ASCII value 90:&quot;</span>, <span class="built_in">chr</span>(<span class="number">90</span>))     <span class="comment"># Output: &#x27;Z&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Character for ASCII value 97:&quot;</span>, <span class="built_in">chr</span>(<span class="number">97</span>))     <span class="comment"># Output: &#x27;a&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Character for ASCII value 122:&quot;</span>, <span class="built_in">chr</span>(<span class="number">122</span>))   <span class="comment"># Output: &#x27;z&#x27;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>A-Z: 65-90, a-z: 97-122</p>
</blockquote>
<hr>
<h2 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h2><p><code>gcd(a, b) = gcd(b, a % b)</code></p>
<blockquote>
<p>基于欧几里得算法递归实现求两个整数的最大公约数</p>
</blockquote>
<p><code>lcm(a, b) = a * b / gcd(a, b)</code></p>
<blockquote>
<p>一个数的最小公倍数和最大公约数的乘积等于这两个数的乘积。</p>
</blockquote>
<hr>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find . -type f -exec sed -i &#x27;s#https://github.com/#https://mirror.ghproxy.com/github.com/#g&#x27; &#123;&#125; \;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>替换当前目录及其子目录中所有文件中的Github资源下载镜像地址</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find . -type f \( -name &quot;*.cpp&quot; -o -name &quot;*.hpp&quot; \) -exec sed -i &#x27;s/MW_LOG_I/MW_LOG_D/g&#x27; &#123;&#125; \;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>修改当前目录及其子目录中所有.cpp和.hpp文件中的log打印等级</p>
</blockquote>
<hr>
]]></content>
      <categories>
        <category>⭐</category>
      </categories>
  </entry>
  <entry>
    <title>C++ Cheat Sheet</title>
    <url>/blog/cpp-cheat-sheet/</url>
    <content><![CDATA[<div class="note info">

<p>本文围绕 C++ 的Syntax, Data Structures, Algorithms以及STL和相关高频应用进行集中攻克，既能提升在 C++ 面试前的准备效率，也能提前把握实际工作中的 C++ 要点。</p>
</div>

<span id="more"></span>

<p>C++ STL（标准模板库）<br>是一套C++模板类，提供通用的模板类和函数<br>容器-Containers：用于管理某一类对象的集合<br>算法-Algorithms：作用于容器，提供了执行各种操作的方式<br>迭代器-Iterators：用于遍历对象集合的元素<br>向量 Vector：能够存放任意类型的动态数组<br>1.顺序序列：元素按线性顺序排序；可通过元素在序列中的位置访问对应的元素<br>2.动态数组：对序列中任意元素进行快速直接访问；提供在序列末尾相对快速地添加&#x2F;删除元素<br>C++中两种输入输出方式：<br>cin、cout；效率低；因为输出时将内容先放入缓冲区再输出<br>使用ios::sync_with_stdio(false);使内容不在缓存直接输出</p>
<h2 id="1-main综合模板"><a href="#1-main综合模板" class="headerlink" title="1.main综合模板"></a>1.main综合模板</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>         <span class="comment">//C++中输入输出函数 cout endl 等</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span>          <span class="comment">//string相关函数操作</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>          <span class="comment">//C语言输入输出函数 printf scanf 等</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span>         <span class="comment">//C语言string操作函数 strlen strcmp等</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>         <span class="comment">//标准C库函数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span>          <span class="comment">//文件流操作</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span>           <span class="comment">//标准数学函数  max  min  pow等</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>           <span class="comment">//向量(vector) 容器</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span>            <span class="comment">//队列(FIFO)  容器</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span>            <span class="comment">//堆(STACK) 容器</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span>        <span class="comment">//向量vector排序sort  反转reverse 等函数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span>    <span class="comment">//字典相关</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span>              <span class="comment">//hashmap容器</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-数组排序库"><a href="#2-数组排序库" class="headerlink" title="2.数组排序库"></a>2.数组排序库</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="built_in">sort</span>(a, a + <span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<h2 id="3-字符串库"><a href="#3-字符串库" class="headerlink" title="3.字符串库"></a>3.字符串库</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string s;</span><br><span class="line"><span class="type">int</span> pos = s.<span class="built_in">find</span>(<span class="string">&quot;afsd&quot;</span>); 	    <span class="comment">//在s串中查找指定串, 返回值为查找的串在string中的首部索引 没有找到的话返回 string::npos</span></span><br><span class="line"><span class="type">int</span> pos = s.<span class="built_in">find</span>(<span class="string">&quot;afsd&quot;</span>, <span class="number">5</span>)     <span class="comment">//从字符串s 下标5开始，查找字符串b ,返回b 在s 中的索引</span></span><br><span class="line">string s2 = s.<span class="built_in">substr</span>(<span class="number">2</span>, <span class="number">5</span>);     <span class="comment">//substr(startPosition,lenth)</span></span><br><span class="line">string s2 = s.<span class="built_in">substr</span>(<span class="number">2</span>);        <span class="comment">//截取从[2,string::npos)  从当前索引到string结尾</span></span><br><span class="line"><span class="type">int</span> = <span class="built_in">atoi</span>(s.<span class="built_in">c_str</span>());          <span class="comment">//将字符串转化为整数</span></span><br></pre></td></tr></table></figure>

<h2 id="4-向量vector的基本用法"><a href="#4-向量vector的基本用法" class="headerlink" title="4.向量vector的基本用法"></a>4.向量vector的基本用法</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; s;                  <span class="comment">//向量是一串数据组</span></span><br><span class="line">s.<span class="built_in">pop_back</span>();                   <span class="comment">//弹出向量的尾部元素，并不反悔任何值</span></span><br><span class="line">s.<span class="built_in">push_back</span>(&lt;<span class="type">int</span>&gt;);             <span class="comment">//压入新的元素到向量的尾部</span></span><br><span class="line"><span class="type">int</span> = s.<span class="built_in">size</span>();                 <span class="comment">//反回栈的大小</span></span><br><span class="line"><span class="type">bool</span> = s.<span class="built_in">empty</span>();               <span class="comment">//判断向量是否为空 如果为空，返回true</span></span><br><span class="line">&lt;<span class="type">int</span>&gt; = s.<span class="built_in">front</span>();              <span class="comment">//访问向量最前的元素</span></span><br><span class="line">&lt;<span class="type">int</span>&gt; = s.<span class="built_in">back</span>();               <span class="comment">//访问向量最后的元素</span></span><br><span class="line">s.<span class="built_in">clear</span>();                      <span class="comment">//清空整个向量</span></span><br><span class="line">s.<span class="built_in">insert</span>( s.<span class="built_in">begin</span>() + n, &lt;<span class="type">int</span>&gt;);    <span class="comment">//在向量中第n个索引元素前插入&lt;int&gt;</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; s2;</span><br><span class="line">s.<span class="built_in">insert</span>( s.<span class="built_in">begin</span>() + n, s2.<span class="built_in">begin</span>(), s2.<span class="built_in">end</span>());    <span class="comment">//在向量中第n个索引元素前插入同类的s2向量</span></span><br><span class="line">s.<span class="built_in">erase</span>(s.<span class="built_in">begin</span>() + n);         <span class="comment">//删除向量中的第n个索引元素</span></span><br><span class="line">s.<span class="built_in">erase</span>(s.<span class="built_in">begin</span>() + n, s.<span class="built_in">begin</span>() + m);     <span class="comment">//删除向量中的[n,m)区间的元素</span></span><br><span class="line"><span class="built_in">find</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>(), <span class="type">int</span>) == s.<span class="built_in">end</span>();  <span class="comment">//在vector s中查找是否有某个元素，如果有，返回指针类型 vector&lt;int&gt;::iterator</span></span><br></pre></td></tr></table></figure>
<h2 id="5-vector初始化"><a href="#5-vector初始化" class="headerlink" title="5.vector初始化"></a>5.vector初始化</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">s</span><span class="params">(a, a+<span class="number">5</span>)</span></span>;  <span class="comment">//将数组元素初始化为vector中的元素</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">s</span>(a, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(b));   <span class="comment">//创建s[a][b]大小的二维向量</span></span><br><span class="line"></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">v1</span><span class="params">(<span class="number">3</span>)</span></span>;                                 <span class="comment">// 1. Create a vector v1 with 3 elements of default value 0  </span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">v2</span><span class="params">(<span class="number">5</span>, <span class="number">2</span>)</span></span>;                              <span class="comment">// 2. Create a vector v2 with 5 elements of value 2  </span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">v3</span><span class="params">(<span class="number">3</span>, <span class="number">1</span>, v2.get_allocator())</span></span>;          <span class="comment">// 3. Create a vector v3 with 3 elements of value 1 and with the allocator of vector v2  </span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">v4</span><span class="params">(v2)</span></span>;                                <span class="comment">// 4. Create a copy, vector v4, of vector v2  </span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">v5</span><span class="params">(v4.begin() + <span class="number">1</span>, v4.begin() + <span class="number">3</span>)</span></span>;    <span class="comment">// 5. Create a vector v5 by copying the range v4[_First, _Last) </span></span><br></pre></td></tr></table></figure>
<h2 id="6-Vector排序"><a href="#6-Vector排序" class="headerlink" title="6.Vector排序"></a>6.Vector排序</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注意包含头文件#include &lt;algorithm&gt;</span></span><br><span class="line"><span class="built_in">sort</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());   <span class="comment">//默认升序排列</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">sortFun</span><span class="params">(<span class="type">int</span> &amp; x, <span class="type">int</span> &amp; y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &lt; y;   <span class="comment">//升序排列</span></span><br><span class="line">    <span class="comment">//return x &gt; y;	//降序排列</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(num.<span class="built_in">begin</span>(), num.<span class="built_in">end</span>(), sortFun);  <span class="comment">//按照sortFun制定的规则排序</span></span><br><span class="line"><span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());            <span class="comment">//颠倒vector s中的所有元素，倒序</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="7-栈queue的基本用法"><a href="#7-栈queue的基本用法" class="headerlink" title="7.栈queue的基本用法"></a>7.栈queue的基本用法</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">queue&lt;<span class="type">int</span>&gt; s;   <span class="comment">//栈是先入先出的FIFO</span></span><br><span class="line">s.<span class="built_in">front</span>();      <span class="comment">//栈首元素  只能通过front 和 back 接口访问首尾元素，无法访问中间元素</span></span><br><span class="line">s.<span class="built_in">back</span>();       <span class="comment">//栈尾元素</span></span><br><span class="line">s.<span class="built_in">pop</span>();        <span class="comment">//弹出栈的首元素</span></span><br><span class="line">s.<span class="built_in">push</span>();       <span class="comment">//压入新的元素</span></span><br><span class="line">s.<span class="built_in">size</span>();       <span class="comment">//反回栈的大小</span></span><br><span class="line">s.<span class="built_in">empty</span>();      <span class="comment">//判断queue是否为空</span></span><br><span class="line">s = <span class="built_in">queue</span>&lt;<span class="type">int</span>&gt;();   <span class="comment">//清空栈，通过赋值空栈的方式清空</span></span><br></pre></td></tr></table></figure>
<h2 id="8-堆stack的基本用法"><a href="#8-堆stack的基本用法" class="headerlink" title="8.堆stack的基本用法"></a>8.堆stack的基本用法</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">stack&lt;<span class="type">int</span>&gt; s;   <span class="comment">//堆是后入先出  </span></span><br><span class="line">s.<span class="built_in">top</span>();        <span class="comment">//堆顶元素  只能使用top访问顶部元素 无法访问中间元素</span></span><br><span class="line">s.<span class="built_in">pop</span>();        <span class="comment">//弹出堆的顶元素，并不反回任何值，仅弹出元素</span></span><br><span class="line">s.<span class="built_in">push</span>();       <span class="comment">//压入新的元素</span></span><br><span class="line">s.<span class="built_in">size</span>();       <span class="comment">//反回栈的大小</span></span><br><span class="line">s.<span class="built_in">empty</span>();      <span class="comment">//判断堆是否为空</span></span><br></pre></td></tr></table></figure>
<h2 id="9-hashmap的基本用法-构建一一映射的关系"><a href="#9-hashmap的基本用法-构建一一映射的关系" class="headerlink" title="9.hashmap的基本用法(构建一一映射的关系)"></a>9.hashmap的基本用法(构建一一映射的关系)</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">map&lt;k, v&gt; m;	    <span class="comment">//定义了一个名为m的空的map对象 其中的key为k 值为v</span></span><br><span class="line"><span class="function">map&lt;k, v&gt; <span class="title">m2</span><span class="params">(m)</span></span>;    <span class="comment">//创建了m的副本m2</span></span><br><span class="line"><span class="function">map&lt;k, v&gt; <span class="title">m3</span><span class="params">(m.begin() + b, m.begin() + e)</span></span>; <span class="comment">//创建了map对象m3，并且存储迭代器b和e范围内的所有元素的副本</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//例： </span></span><br><span class="line">map&lt;string , <span class="type">int</span>&gt; m;  <span class="comment">//key为一个string 值为一个int</span></span><br><span class="line">m[<span class="string">&quot;ABC&quot;</span>] = <span class="number">123</span>;       <span class="comment">//在m中创建了一个映射关系 通过key值 &quot;ABC&quot; 可查找到int值 123   注意：使用key值访问一个不存在的元素将会创建新元素</span></span><br><span class="line">m[<span class="string">&quot;DEF&quot;</span>] = <span class="number">456</span>;       <span class="comment">//在m中创建了一个映射关系 通过key值 &quot;DEF&quot; 可查找到int值 456   注意：使用key值访问一个已存在的元素将会覆盖原元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//插入值：</span></span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;string, <span class="type">int</span>&gt;(<span class="string">&quot;GHI&quot;</span>, <span class="number">789</span>));            <span class="comment">//与m[&quot;GHI&quot;] = 789;等效</span></span><br><span class="line">m.<span class="built_in">insert</span>(m.<span class="built_in">begin</span>() ,<span class="built_in">pair</span>&lt;string, <span class="type">int</span>&gt;(<span class="string">&quot;GHI&quot;</span>, <span class="number">789</span>)); <span class="comment">//在m的首部插入值</span></span><br><span class="line">m.<span class="built_in">insert</span>(&#123; &#123;<span class="string">&quot;ABC&quot;</span>, <span class="number">123</span> &#125;, &#123;<span class="string">&quot;DEF&quot;</span>, <span class="number">456</span>&#125; &#125;);          <span class="comment">//列表形式多元素插入</span></span><br><span class="line"></span><br><span class="line">m.<span class="built_in">erase</span>(m.<span class="built_in">begin</span>());     <span class="comment">//删除首部元素</span></span><br><span class="line">m.<span class="built_in">erase</span>(<span class="string">&quot;ABC&quot;</span>);         <span class="comment">//删除key值为ABC的元素</span></span><br><span class="line"></span><br><span class="line">map&lt;string, <span class="type">int</span>&gt;::iterator index = m.<span class="built_in">find</span>(<span class="string">&quot;ABC&quot;</span>);   <span class="comment">//查找key值为&quot;ABC&quot;的元素索引 通常用法: m.find(&quot;ABC&quot;) != m.end(); //找到了该元素</span></span><br><span class="line"></span><br><span class="line">m.<span class="built_in">empty</span>();      <span class="comment">//是否为空</span></span><br><span class="line">m.<span class="built_in">clear</span>();      <span class="comment">//清空所有元素</span></span><br><span class="line">m.<span class="built_in">size</span>();       <span class="comment">//m中元素的个数</span></span><br><span class="line">m.<span class="built_in">max_size</span>();   <span class="comment">//最多容纳的元素个数</span></span><br><span class="line">m.<span class="built_in">swap</span>(m1);     <span class="comment">//交换两个map</span></span><br></pre></td></tr></table></figure>

<h2 id="10-数组"><a href="#10-数组" class="headerlink" title="10.数组"></a>10.数组</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector &lt;<span class="type">int</span>&gt; a;</span><br><span class="line">vector &lt;<span class="type">int</span>&gt; <span class="built_in">b</span>(<span class="number">10</span>); <span class="comment">//b默认长度为10</span></span><br><span class="line">vector &lt;<span class="type">int</span>&gt; <span class="built_in">c</span>(<span class="number">10</span>, <span class="number">2</span>); <span class="comment">//c用2进行初始化</span></span><br><span class="line">a.<span class="built_in">size</span>();</span><br><span class="line">a.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">a.<span class="built_in">back</span>(); <span class="comment">//返回vector最后一个值</span></span><br><span class="line">a.<span class="built_in">pop_back</span>(); <span class="comment">//删除最后一个值</span></span><br><span class="line"><span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;:: iterator it = a.<span class="built_in">begin</span>(); it != a.<span class="built_in">end</span>(); it++)&#123;</span><br><span class="line">   cout&lt;&lt;*it;</span><br><span class="line">&#125;</span><br><span class="line">vector.<span class="built_in">erase</span>(it); <span class="comment">//返回删除元素的下一个元素的迭代器</span></span><br><span class="line">vector.<span class="built_in">insert</span>(it, <span class="number">2</span>); <span class="comment">//在迭代器指定的位置之前插入2，并返回表示新插入元素的迭代器</span></span><br><span class="line">*<span class="built_in">max_element</span>(myVector.<span class="built_in">begin</span>(), myVector.<span class="built_in">end</span>()); <span class="comment">//利用迭代器返回最大值</span></span><br></pre></td></tr></table></figure>

<h2 id="11-栈"><a href="#11-栈" class="headerlink" title="11.栈"></a>11.栈</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">stack &lt;<span class="type">int</span>&gt; a;</span><br><span class="line">a.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">a.<span class="built_in">top</span>(); <span class="comment">//返回栈顶元素</span></span><br><span class="line">a.<span class="built_in">pop</span>();</span><br><span class="line">a.<span class="built_in">empty</span>(); <span class="comment">//如果栈为空，则返回true</span></span><br><span class="line">a.<span class="built_in">size</span>();</span><br></pre></td></tr></table></figure>

<h2 id="12-队列"><a href="#12-队列" class="headerlink" title="12.队列"></a>12.队列</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">queue &lt;int&gt; a;</span><br><span class="line">a.push(1);</span><br><span class="line">a.front();</span><br><span class="line">a.back(); </span><br><span class="line">a.pop();</span><br></pre></td></tr></table></figure>

<h2 id="13-字符串"><a href="#13-字符串" class="headerlink" title="13.字符串"></a>13.字符串</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">string a; //默认&quot;&quot;</span><br><span class="line">a += &#x27;d&#x27;; </span><br><span class="line">a += &quot;ansjcknkj&quot;;</span><br><span class="line">a.back(); //返回最后一个字符</span><br><span class="line">string b = a.substr(1,5); //从位置1向后截取5个字符的子字符串</span><br><span class="line">a.pop_back(); //去掉最后一个字符</span><br><span class="line">string c = to_string(1); //整数to string</span><br><span class="line">c = to_string(1.98); //float to string</span><br><span class="line">int d = stoi(&quot;890&quot;); //string to int</span><br></pre></td></tr></table></figure>

<h2 id="14-堆"><a href="#14-堆" class="headerlink" title="14.堆"></a>14.堆</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">heap（堆）C++默认实现优先队列就是用的堆，所以用优先队列会比较方便</span><br><span class="line"></span><br><span class="line">priority_queue &lt;int&gt; a; //最大堆</span><br><span class="line">priority_queue &lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; b; //最小堆，节点值不大于两边子节点</span><br><span class="line">a.push(1);</span><br><span class="line">a.pop();</span><br><span class="line">a.top(); //返回堆顶元素</span><br></pre></td></tr></table></figure>

<h2 id="15-映射表"><a href="#15-映射表" class="headerlink" title="15.映射表"></a>15.映射表</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">map &lt;int, bool&gt; a;</span><br><span class="line">a[0] = true;</span><br><span class="line">cout&lt;&lt;a[0]&lt;&lt;a[1]; //会输出true和false。如果映射表中不存在key值对应的元素，会根据默认构造函数赋值。</span><br><span class="line">a[2]++; //a[2] = 1 </span><br><span class="line">map &lt;int, bool&gt;:: iterator it = a.find(12); //没找到会返回a.end()</span><br><span class="line">for(map&lt;int, string&gt;::iterator it = myMap.begin(); it != myMap.end(); it++)&#123;</span><br><span class="line">  cout&lt;&lt;it-&gt;first&lt;&lt;it-&gt;second;</span><br><span class="line">&#125; //遍历映射表</span><br></pre></td></tr></table></figure>

<h2 id="16-奇技淫巧"><a href="#16-奇技淫巧" class="headerlink" title="16.奇技淫巧"></a>16.奇技淫巧</h2><h3 id="16-1辗转相除法求最大公约数"><a href="#16-1辗转相除法求最大公约数" class="headerlink" title="16.1辗转相除法求最大公约数"></a>16.1辗转相除法求最大公约数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> m,<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> m;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">fun</span>(n,m%n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="16-2如何判断链表有环，并找出入环点"><a href="#16-2如何判断链表有环，并找出入环点" class="headerlink" title="16.2如何判断链表有环，并找出入环点"></a>16.2如何判断链表有环，并找出入环点</h3><p>对于如何判断链表有环，可以从起点发出两个指针，一个一次一步，另一个一次两步，如果两个指针相遇，那么这个单链表就有环。<br>第一问得出相遇点后，再发出一个指针，统计这个指针再次回到这个点的距离，也就是环的距离。然后从起点再发出两个指针，一个指针在另一个前面，两个指针的距离就是环的距离，当两个指针再次相遇的时候就是环的入口。</p>
<h3 id="16-3异或运算-可以快速判断多个项的相等结果"><a href="#16-3异或运算-可以快速判断多个项的相等结果" class="headerlink" title="16.3异或运算 可以快速判断多个项的相等结果"></a>16.3异或运算 可以快速判断多个项的相等结果</h3><p>c &#x3D; a⊕b &#x2F;&#x2F;如果a、b两个值不相同，则异或结果为1。如果a、b两个值相同，异或结果为0<br>(a⊕b)⊕c &#x3D; a⊕(b⊕c)<br>在判断数值是否相同时，可以通过异或运算快速判断<br>面，两个指针的距离就是环的距离，当两个指针再次相遇的时候就是环的入口。</p>
<h3 id="16-4异或运算-可以快速判断多个项的相等结果"><a href="#16-4异或运算-可以快速判断多个项的相等结果" class="headerlink" title="16.4异或运算 可以快速判断多个项的相等结果"></a>16.4异或运算 可以快速判断多个项的相等结果</h3><p>c &#x3D; a⊕b &#x2F;&#x2F;如果a、b两个值不相同，则异或结果为1。如果a、b两个值相同，异或结果为0<br>(a⊕b)⊕c &#x3D; a⊕(b⊕c)<br>在判断数值是否相同时，可以通过异或运算快速判断</p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
  </entry>
  <entry>
    <title>C++ 设计模式学习路线</title>
    <url>/blog/cpp-design-patterns/</url>
    <content><![CDATA[<div class="note info">

<ul>
<li>设计模式是针对常见问题的通用解决方案，目前最为经典的设计模式有 23 种。</li>
<li>学习设计模式不仅能开拓思路、写出更优质的代码、提高项目的开发和维护效率；还能更好地阅读和理解源码，甚至可以根据文件名称直接推断出源码的架构设计。</li>
</ul>
</div>

<span id="more"></span>

<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>你是否在项目开发中思考过如下几个问题？</p>
<ul>
<li>同样都是写代码，为什么有些大佬的思路清晰、代码整洁，而我的代码却充满了重复和混乱，每次要修改时都无从下手、Bug 一堆？</li>
<li>如何写代码，才能使得项目易于扩展和维护？</li>
<li>我每天都在写重复的代码，如何提升水平？</li>
<li>为什么我读不懂大佬写的源码？是不是缺少了什么知识？</li>
</ul>
<p>如果存在上述问题，那么我们一定要学习软件开发中的重要技能 —— <code>设计模式</code>！</p>
<p>设计模式是软件开发人员在软件开发过程中面临的一般问题的 <strong>通用</strong> 解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。</p>
<p>通俗地说就是前辈们在写代码时摸索出了一些不错的方法，可以用于解决一类问题、更好地开发和维护项目。于是其他软件开发者纷纷效仿，久而久之，就得出了一套优秀的软件开发方法总结。</p>
<h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p>在 1994 年，由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人合著出版了一本名为《Design Patterns - Elements of Reusable Object-Oriented Software》（中文译名：<a href="https://book.douban.com/subject/1052241/">《设计模式 - 可复用的面向对象软件元素》</a>）的书，该书首次提到了软件开发中设计模式的概念。</p>
<h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><h3 id="简要概述"><a href="#简要概述" class="headerlink" title="简要概述"></a>简要概述</h3><p>《Design Patterns: Element of Reusable Object Oriented Software》</p>
<ul>
<li>Creational Patterns:<ul>
<li>Abstract Factory</li>
<li>Builder</li>
<li>Factory Method</li>
<li>Prototype</li>
<li>Singleton</li>
</ul>
</li>
<li>Structural Patterns<ul>
<li>Adapter</li>
<li>Bridge</li>
<li>Composite</li>
<li>Decorator</li>
<li>Facade</li>
<li>Flyweight</li>
<li>Proxy</li>
</ul>
</li>
<li>Behivioural Patterns<ul>
<li>Chain of Responsibility</li>
<li>Command</li>
<li>Interpreter</li>
<li>Mediator</li>
<li>Memento</li>
<li>Observer</li>
<li>State</li>
<li>Strategy</li>
<li>Template Method</li>
<li>Visitor</li>
</ul>
</li>
</ul>
<p>编程7大原则</p>
<ol>
<li>单一指责原则 Single Responsibility Principle</li>
<li>开闭原则 Open-CLosed Principle</li>
<li>迪米特法则 Law of Demeter</li>
<li>依赖倒置原则 Dependency Inversion Principle</li>
<li>合成复用原则 Composite Reuse Principle</li>
<li>接口隔离原则 Interface Segregation Principle</li>
<li>里氏替换原则 Liskov Substitution Principle</li>
</ol>
<ul>
<li><p>设计模式分类 </p>
<ul>
<li>根据作用范围：类 &#x2F; 对象模式</li>
<li>根据目的分类：创建型 &#x2F; 结构型 &#x2F; 行为型模式</li>
</ul>
</li>
<li><p>创建型模式：<strong>如何创建对象</strong></p>
<ul>
<li>单例模式（懒汉式、饿汉式、双检锁、线程唯一单例）</li>
<li>工厂方法模式（类）</li>
<li>抽象工厂模式</li>
<li>建造者模式</li>
<li>原型模式</li>
</ul>
</li>
<li><p>结构型模式：<strong>如何将类或对象结合在一起形成一个更强大的结构</strong></p>
<ul>
<li>适配器模式（类 &#x2F; 对象）</li>
<li>组合模式</li>
<li>装饰器模式</li>
<li>代理模式</li>
<li>享元模式</li>
<li>外观模式</li>
<li>桥接模式</li>
</ul>
</li>
<li><p>行为型模式：<strong>类或对象间如何交互、如何划分职责，从而更好地完成任务</strong> </p>
<ul>
<li>迭代器模式</li>
<li>模板方法模式（类）</li>
<li>策略模式</li>
<li>命令模式</li>
<li>状态模式</li>
<li>责任链模式</li>
<li>备忘录模式</li>
<li>观察者模式</li>
<li>访问者模式</li>
<li>中介者模式</li>
<li>解释器模式（类）</li>
</ul>
</li>
</ul>
<h3 id="知识图表"><a href="#知识图表" class="headerlink" title="知识图表"></a>知识图表</h3><blockquote>
<p>表格来源： <a href="https://www.cnblogs.com/zhangdezhang/p/16082901.html">GoF设计模式-23大设计模式（表格）-程序员必备+必背</a></p>
</blockquote>
<p>表一：GoF的23种设计模式一览表</p>
<table>
  <tr>
    <td></td>
    <td>创建型模式*5  <br> Creational</td>
    <td>结构性模式*7  <br> Structural</td>
    <td>行为型模式*11 <br> Behavioral</td>
  </tr>
  <tr>
    <td>类模式</td>
    <td>
      <p>工厂方法模式 (Factory Method)</p>
    </td>
    <td>
      <p>(类)适配器模式 (Class Adapter)</p>
    </td>
    <td>
      <p>解释器模式 (Interpreter)</p>
      <p>模板方法模式 (Template Method)</p>
    </td>
  </tr>
  <tr>
    <td>对象模式</td>
    <td>
      <p>抽象工厂模式 (Abstract Factory)</p>
      <p>建造者模式 (Builder)</p>
      <p>原型模式 (Prototype)</p>
      <p>单例模式 (Singleton)</p>
    </td>
    <td>
      <p>(对象)适配器模式 (Object Adapter)</p>
      <p>桥接模式 (Bridge)</p>
      <p>组合模式 (Composite)</p>
      <p>装饰模式 (Decorator)</p>
      <p>外观模式 (Facade)</p>
      <p>享元模式 (Flyweight)</p>
      <p>代理模式 (Proxy)</p>
    </td>
    <td>
      <p>职责链模式 (Chain of Responsibility)</p>
      <p>命令模式 (Command)</p>
      <p>迭代器模式 (Iterator)</p>
      <p>中介者模式 (Mediator)</p>
      <p>备忘录模式 (Memento)</p>
      <p>观察者模式 (Observer)</p>
      <p>状态模式 (State)</p>
      <p>策略模式 (Strategy)</p>
      <p>访问者模式 (Visitor)</p>
    </td>
  </tr>
</table>

<p>表二：GoF的23种设计模式简要说明</p>
<table>
  <tr>
    <th>模式类别</th>
    <th>模式名称</th>
    <th>模式说明</th>
  </tr>
  <tr>
    <td rowspan="5">创建型模式*5 <br> Creational Pattern</td>
    <td>抽象工厂模式 <br> Abstract Factory <br> Pattern</td>
    <td>提供一个创建一系列相关或者相互依赖的对象的接口，而无需指定它们具体的类</td>
  </tr>
  <tr>
    <td>工厂方法模式 <br> Factory Method <br> Pattern</td>
    <td>定义一个用于创建对象的类型，但是让子类决定将哪一个类实例化；工厂方法模式让一个类的实例化延迟到子类</td>
  </tr>
  <tr>
    <td>建造者模式 <br> Builder Pattern</td>
    <td>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示</td>
  </tr>
  <tr>
    <td>原型模式 <br> Prototype Pattern</td>
    <td>使用原型实例指定待创建对象的类型，并且通过复制这个原型来创建新的类</td>
  </tr>
  <tr>
    <td>单例模式 <br> Singleton Pattern</td>
    <td>确保一个类只有一个实例，并提供一个全局访问点来访问这个实例</td>
  </tr>

  <tr>
    <td rowspan="7">结构型模式*7 <br> Structural Pattern</td>
    <td>适配器模式 <br> Adapter Pattern</td>
    <td>将一个类的接口转换成客户希望的另一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作</td>
  </tr>
  <tr>
    <td>桥接模式 <br> Bridge Pattern</td>
    <td>将抽象部分与它的实现部分解耦，使得两者都能够独立变化</td>
  </tr>
  <tr>
    <td>组合模式 <br> Composite Pattern</td>
    <td>组合多个对象形成树形结构以表示具有部分-整体关系的层次结构，组合模式让客户端可以统一对待单个对象的组合对象</td>
  </tr>
  <tr>
    <td>装饰模式 <br> Decorator Pattern</td>
    <td>动态的给一个对象增加一些额外的职责。就扩展功能而言，装饰模式提供了一种比使用子类更加灵活的替代方案；</td>
  </tr>
  <tr>
    <td>外观模式 <br> Facade Pattern</td>
    <td>为子系统中的一组接口提供一个统一的入口。外观模式定义了一个高层接口，这个接口使得这一子系统更容易使用</td>
  </tr>
  <tr>
    <td>享元模式 <br> Flyweight Pattern</td>
    <td>运用共享技术有效地支持大量细粒度对象的复用</td>
  </tr>
  <tr>
    <td>代理模式 <br> Proxy Pattern</td>
    <td>给某一个对象提供一个代理或占位符，并由代理对象来控制对原有对象的访问</td>
  </tr>

  <tr>
    <td rowspan="11">行为型模式*11 <br> Behavioral Pattern</td>
    <td>职责链模式 <br> Chain of <br> Responsibility Pattern</td>
    <td>避免将一个请求的发送者与接收者耦合在一起，让多个对象都有机会处理请求；将接收请求的对象连接成一条链，并且沿着这条链传递请求，直到有一个对象能够处理它为止</td>
  </tr>
  <tr>
    <td>命令模式 <br> Command Pattern</td>
    <td>将一个请求封装为一个对象，从而可用不同的请求对客户进行参数化，对请求排队或者记录请求日志，以及支持可撤销的操作</td>
  </tr>
  <tr>
    <td>迭代器模式 <br> Iterator Pattern</td>
    <td>提供一种方法顺序访问一个聚合对象中的各个元素，而又不用暴露该对象的内部表示</td>
  </tr>
  <tr>
    <td>中介者模式 <br> Mediator Pattern</td>
    <td>定义一个对象来封装一系列对象的交互；中介者模式使各对象之间不需要显式的相互引用，从而使其耦合松散，而且让你可以独立的改变他们之间的交互</td>
  </tr>
  <tr>
    <td>备忘录模式 <br> Memento Pattern</td>
    <td>在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态</td>
  </tr>
  <tr>
    <td>观察者模式 <br> Observer Pattern</td>
    <td>定义对象之间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新</td>
  </tr>
  <tr>
    <td>状态模式 <br> State Pattern</td>
    <td>允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类</td>
  </tr>
  <tr>
    <td>策略模式 <br> Strategy Pattern</td>
    <td>定义一系列算法，将每一个算法封装起来，并让它们可以相互替换，策略模式让算法可以独立于使用它的客户变化</td>
  </tr>
  <tr>
    <td>模板方法模式 <br> Template Method <br> Pattern</td>
    <td>定义一个操作中算法的框架，而将一些步骤延迟到子类中；模板方法模式使得子类可以不改变一个算法的结构，即可重新定义该算法的某些特定步骤</td>
  </tr>
  <tr>
    <td>访问者模式 <br> Visitor Pattern</td>
    <td>表示一个作用于某对象结构中的各个元素的操作；访问者模式让你可以在不改变各个元素的类的前提下定义用于这些元素的新操作</td>
  </tr>
</table>

<blockquote>
<p>表格来源： <a href="https://home.cnblogs.com/u/schips/">schips</a></p>
</blockquote>
<p>表三：GoF的23种设计模式的对比</p>
<table>
<thead>
<tr>
<th>设计模式</th>
<th>适用层次</th>
<th>引入时机</th>
<th>复杂度</th>
<th>变化</th>
<th>实现</th>
<th>体现的原则</th>
</tr>
</thead>
<tbody><tr>
<td>工厂方法</td>
<td>代码级</td>
<td>编码时</td>
<td>简单</td>
<td>子类的实例化</td>
<td>对象的创建工作延迟到子类</td>
<td>开闭原则</td>
</tr>
<tr>
<td>单例</td>
<td>代码级、应用级</td>
<td>设计时、编码时</td>
<td>简单</td>
<td>唯一实例</td>
<td>封装对象产生的个数</td>
<td></td>
</tr>
<tr>
<td>门面</td>
<td>应用级、构架级</td>
<td>设计时、编码时</td>
<td>简单</td>
<td>子系统的高层接口</td>
<td>封装子系统</td>
<td>开闭原则</td>
</tr>
<tr>
<td>模板方法</td>
<td>代码级</td>
<td>编码时、重构时</td>
<td>简单</td>
<td>算法子步骤的变化</td>
<td>封装算法结构</td>
<td>依赖倒置原则</td>
</tr>
<tr>
<td>抽象工厂</td>
<td>应用级</td>
<td>设计时</td>
<td>较复杂</td>
<td>产品家族的扩展</td>
<td>封装产品族系列内容的创建</td>
<td>开闭原则</td>
</tr>
<tr>
<td>组合</td>
<td>代码级</td>
<td>编码时、重构时</td>
<td>较复杂</td>
<td>复杂对象接口的统一</td>
<td>统一复杂对象的接口</td>
<td>里氏代换原则</td>
</tr>
<tr>
<td>代理</td>
<td>应用级、构架级</td>
<td>设计时、编码时</td>
<td>简单</td>
<td>对象访问的变化</td>
<td>封装对象的访问过程</td>
<td>里氏代换原则</td>
</tr>
<tr>
<td>命令</td>
<td>应用级</td>
<td>设计时、编码时</td>
<td>较简单</td>
<td>请求的变化</td>
<td>封装行为对对象</td>
<td>开闭原则</td>
</tr>
<tr>
<td>观察者</td>
<td>应用级、构架级</td>
<td>设计时、编码时</td>
<td>较简单</td>
<td>通讯对象的变化</td>
<td>封装对象通知</td>
<td>开闭原则</td>
</tr>
<tr>
<td>策略</td>
<td>应用级</td>
<td>设计时</td>
<td>一般</td>
<td>算法的变化</td>
<td>封装算法</td>
<td>里氏代换原则</td>
</tr>
<tr>
<td>建造者</td>
<td>代码级</td>
<td>编码时</td>
<td>一般</td>
<td>对象组建的变化</td>
<td>封装对象的组建过程</td>
<td>开闭原则</td>
</tr>
<tr>
<td>Adapter</td>
<td>代码级</td>
<td>重构时</td>
<td>一般</td>
<td>对象接口的变化</td>
<td>接口的转换</td>
<td></td>
</tr>
<tr>
<td>桥接</td>
<td>代码级</td>
<td>设计时、编码时</td>
<td>一般</td>
<td>对象的多维度变化</td>
<td>分离接口以及实现</td>
<td>开闭原则</td>
</tr>
<tr>
<td>装饰器</td>
<td>代码级</td>
<td>重构时</td>
<td>较复杂</td>
<td>对象的组合职责</td>
<td>在稳定接口上扩展</td>
<td>开闭原则</td>
</tr>
<tr>
<td>迭代器</td>
<td>代码级、应用级</td>
<td>编码时、重构时</td>
<td>较简单</td>
<td>对象内部集合的变化</td>
<td>封装对象内部集合的使用</td>
<td>单一职责原则</td>
</tr>
<tr>
<td>中介者</td>
<td>应用级、构架级</td>
<td>编码时、重构时</td>
<td>一般</td>
<td>对象交互的变化</td>
<td>封装对象间的交互</td>
<td>开闭原则</td>
</tr>
<tr>
<td>备忘录</td>
<td>代码级</td>
<td>编码时</td>
<td>较简单</td>
<td>状态的辅助保存</td>
<td>封装对象状态的变化</td>
<td>接口隔离原则</td>
</tr>
<tr>
<td>状态</td>
<td>应用级</td>
<td>设计时、编码时</td>
<td>一般</td>
<td>对象状态的变化</td>
<td>封装与状态相关的行为</td>
<td>单一职责原则</td>
</tr>
<tr>
<td>访问者</td>
<td>应用级</td>
<td>设计时</td>
<td>较复杂</td>
<td>对象操作变化</td>
<td>封装对象操作变化</td>
<td>开闭原则</td>
</tr>
<tr>
<td>原型</td>
<td>应用级</td>
<td>编码时、重构时</td>
<td>较简单</td>
<td>实例化的类</td>
<td>封装对原型的拷贝</td>
<td>依赖倒置原则</td>
</tr>
<tr>
<td>享元</td>
<td>代码级、应用级</td>
<td>设计时</td>
<td>一般</td>
<td>系统开销的优化</td>
<td>封装对象的获取</td>
<td></td>
</tr>
<tr>
<td>责任链</td>
<td>应用级、构架级</td>
<td>设计时、编码时</td>
<td>较复杂</td>
<td>对象的请求过程</td>
<td>封装对象的责任范围</td>
<td></td>
</tr>
<tr>
<td>解释器</td>
<td>应用级</td>
<td>设计时</td>
<td>较复杂</td>
<td>领域问题的变化</td>
<td>封装特定领域的变化</td>
<td></td>
</tr>
</tbody></table>
<p>除了这 23 种主流设计模式外，还有一些其他设计模式，比如 Immutable 不可变模式等，了解即可。</p>
<h2 id="学习建议"><a href="#学习建议" class="headerlink" title="学习建议"></a>学习建议</h2><ol>
<li>对设计模式的学习和其他知识一样，先了解每种设计模式是什么？作用是什么？能够解决什么问题？适用于什么场景？有什么特点？类和对象的关系是什么（建议结合 UML 类图来理解）？再去考虑编码实现和进一步在项目中应用。</li>
<li>一定要多写代码实践，最好每个设计模式都实现一遍，不要去背代码，用的多了自然就能写出代码了。</li>
<li>每个设计模式都可以 <strong>独立学习</strong> ，互相之间联系不大，因此可以根据自己的时间来选择性学习（比如先学重点的单例模式）。</li>
<li>在学会基础的设计模式后，可以分析之前学过的框架源码（比如 Spring、MyBatis 等），参考别人是如何应用设计模式的。</li>
<li><strong>不要过度依赖设计模式！！！！！！</strong> 它并不是银弹，过分使用设计模式可能只会增加系统的复杂度。</li>
</ol>
<h2 id="学习路线"><a href="#学习路线" class="headerlink" title="学习路线"></a>学习路线</h2><p>主流的设计模式共有 23 种，建议大家按照以下四个阶段来学习：</p>
<ol>
<li>基础学习</li>
<li>编码实现</li>
<li>项目实战</li>
<li>备战面试</li>
</ol>
<p>其中第一个阶段和第二个阶段 <strong>可以同时进行</strong> ，即对于每个设计模式的学习都是：先了解、再编码实现。</p>
<h3 id="一、基础学习"><a href="#一、基础学习" class="headerlink" title="一、基础学习"></a>一、基础学习</h3><p>本阶段的目标：依次了解每一种设计模式的应用场景、特点、UML 类图，能够对设计模式有个基础的印象。</p>
<h4 id="学习顺序"><a href="#学习顺序" class="headerlink" title="学习顺序"></a>学习顺序</h4><p>根据使用频率、难易度、面试考察率等综合排序，仅供参考，并不绝对！</p>
<p>优先：</p>
<ol>
<li>单例模式</li>
<li>工厂方法模式</li>
<li>迭代器模式</li>
<li>策略模式</li>
<li>建造者模式</li>
<li>模板方法模式</li>
<li>代理模式</li>
<li>责任链模式</li>
<li>抽象工厂模式</li>
<li>适配器模式</li>
<li>观察者模式</li>
<li>外观模式</li>
</ol>
<p>一般：</p>
<ol>
<li>桥接模式</li>
<li>组合模式</li>
<li>装饰器模式</li>
<li>状态模式</li>
<li>访问者模式</li>
<li>中介者模式</li>
<li>命令模式</li>
<li>备忘录模式</li>
</ol>
<p>低优先：</p>
<ol>
<li>原型模式</li>
<li>享元模式</li>
<li>解释器模式</li>
</ol>
<h4 id="推荐资源"><a href="#推荐资源" class="headerlink" title="推荐资源"></a>推荐资源</h4><blockquote>
<p>以下资源看 1 - 2 个就足够入门了</p>
</blockquote>
<ul>
<li>书籍 <ul>
<li>《图解设计模式》：<a href="https://www.aliyundrive.com/s/jcQugLGNs1V">https://www.aliyundrive.com/s/jcQugLGNs1V</a> 提取码: 5i9c（强烈推荐，用 Java 语言实现，图多、有示例代码、有习题和答案，很不错）</li>
<li>《大话设计模式》：<a href="https://www.aliyundrive.com/s/73jZWnfAtaA">https://www.aliyundrive.com/s/73jZWnfAtaA</a> 提取码: 9gc7（比较有趣）</li>
<li>《Head First 设计模式》：<a href="https://www.aliyundrive.com/s/GnuQcruh7Us">https://www.aliyundrive.com/s/GnuQcruh7Us</a> 提取码: 9gc7</li>
<li>《设计模式：可复用面向对象软件的基础》：<a href="https://www.aliyundrive.com/s/T9ECaPtxzg4">https://www.aliyundrive.com/s/T9ECaPtxzg4</a> 提取码: 9gc7（大黑书，难度较大，有能力和时间才去读）</li>
<li>《JavaScript 设计模式与开发实践》：<a href="https://www.aliyundrive.com/s/tzcZCU8bqnR">https://www.aliyundrive.com/s/tzcZCU8bqnR</a> 提取码: 9gc7（适合前端同学阅读）</li>
<li>《Python 设计模式》：<a href="https://www.aliyundrive.com/s/3RNoX31XqUy">https://www.aliyundrive.com/s/3RNoX31XqUy</a> 提取码: 9gc7</li>
</ul>
</li>
<li>视频 <ul>
<li>尚硅谷图解 Java 设计模式：<a href="https://www.bilibili.com/video/BV1G4411c7N4">https://www.bilibili.com/video/BV1G4411c7N4</a> （讲的很棒也很全面，也和一些主流框架相结合，系统学习 Java 的同学可以看）</li>
<li>五分钟学设计模式：<a href="https://www.bilibili.com/video/BV1af4y1y7sS">https://www.bilibili.com/video/BV1af4y1y7sS</a> （小短快科普，比较轻松）</li>
<li>黑马程序员Java设计模式详解：<a href="https://www.bilibili.com/video/BV1Np4y1z7BU">https://www.bilibili.com/video/BV1Np4y1z7BU</a> （很完整，最后讲解了 Spring 框架的部分设计）</li>
<li>用一个项目讲解 23 种设计模式：<a href="https://www.bilibili.com/video/BV19g411N7yx">https://www.bilibili.com/video/BV19g411N7yx</a> （和项目结合，思路不错，但其中有一些直播翻车，可部分跳过）</li>
</ul>
</li>
<li>文档 <ul>
<li>菜鸟教程：<a href="https://www.runoob.com/design-pattern/design-pattern-tutorial.html">https://www.runoob.com/design-pattern/design-pattern-tutorial.html</a> （还是比较推荐的，学过设计模式后如果忘记了，可以查看这个文档快速补回来）</li>
<li>C++ 图说设计模式：<a href="https://design-patterns.readthedocs.io/zh_CN/latest/">https://design-patterns.readthedocs.io/zh_CN&#x2F;latest&#x2F;</a></li>
<li>Go 语言设计模式系列博客：<a href="https://lailin.xyz/post/singleton.html">https://lailin.xyz/post/singleton.html</a></li>
</ul>
</li>
</ul>
<h3 id="二、编码实现"><a href="#二、编码实现" class="headerlink" title="二、编码实现"></a>二、编码实现</h3><p>本阶段的目标：依次编码实现每个设计模式，用任何支持面向对象的编程语言都可以，最好能够独立（不借助任何资料）从 0 写出每个设计模式的代码。</p>
<h4 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h4><p>一些源码示例，仅供参考，更多的内容可以直接在 GitHub 搜索关键词 <code>Design Pattern</code> 或 <code>设计模式</code> ：</p>
<ul>
<li>各语言设计模式示例代码：<a href="https://github.com/wx-chevalier/design-pattern-examples">https://github.com/wx-chevalier/design-pattern-examples</a></li>
<li>Java 23 种设计模式全归纳：<a href="https://github.com/youlookwhat/DesignPattern">https://github.com/youlookwhat/DesignPattern</a> （教程 + 源码）</li>
<li>C++ 设计模式源码：<a href="https://github.com/liu-jianhao/Cpp-Design-Patterns">https://github.com/liu-jianhao/Cpp-Design-Patterns</a> （设计模式介绍 + 源码）</li>
<li>JavaScript 示例代码： <ul>
<li><a href="https://github.com/wchaowu/javascript">https://github.com/wchaowu/javascript</a></li>
<li><a href="https://github.com/zy445566/design-pattern-in-javascript">https://github.com/zy445566/design-pattern-in-javascript</a></li>
</ul>
</li>
<li>Python 示例代码： <ul>
<li><a href="https://github.com/wklken/py-patterns">https://github.com/wklken/py-patterns</a></li>
</ul>
</li>
<li>Go 示例代码 <ul>
<li><a href="https://github.com/mohuishou/go-design-pattern">https://github.com/mohuishou/go-design-pattern</a></li>
</ul>
</li>
</ul>
<h3 id="三、项目实战"><a href="#三、项目实战" class="headerlink" title="三、项目实战"></a>三、项目实战</h3><p>本阶段的目标：通过做项目或阅读项目源码来进一步强化每个设计模式的实际应用。做到能根据某个场景主动选出合适的设计模式来优化代码、灵活运用，并且能够通过文件命名、项目目录结构等途径来快速判断出某个框架是否使用了设计模式。</p>
<p>可以先通过一个视频了解设计模式的实际应用：</p>
<ul>
<li>实际工作中，如何运用 Java 设计模式：<a href="https://www.bilibili.com/video/BV1tK4y1s7Uo">https://www.bilibili.com/video/BV1tK4y1s7Uo</a></li>
</ul>
<p>列举一些设计模式在框架源码中的应用：</p>
<blockquote>
<p>部分内容源于网络</p>
</blockquote>
<ul>
<li>Spring <ul>
<li>工厂模式：通过 BeanFactory 和 ApplicationContext 来创建对象</li>
<li>单例模式：Spring Bean 默认为单例模式</li>
<li>策略模式：例如 Resource 的实现类，针对不同的资源文件，实现了不同方式的资源获取策略</li>
<li>代理模式：Spring 的 AOP 功能用到了 JDK 的动态代理和 CGLIB 字节码生成技术</li>
<li>模板方法：可以将相同部分的代码放在父类中，而将不同的代码放入不同的子类中，用来解决代码重复的问题。比如RestTemplate、JmsTemplate、JpaTemplate</li>
<li>适配器模式：Spring AOP 的增强或通知（Advice）使用到了适配器模式</li>
<li>观察者模式：Spring 事件驱动模型</li>
<li>桥接模式：可以根据客户的需求能够动态切换不同的数据源。比如我们的项目需要连接多个数据库，客户在每次访问中根据需要会去访问不同的数据库</li>
</ul>
</li>
<li>Spring MVC <ul>
<li>组合模式：WebMvcConfigurerComposite，树枝和树叶都实现了相同的抽象类或接口 WebMvcConfigurer</li>
<li>责任链模式：DispatcherServlet 依次拦截和处理请求</li>
<li>适配器模式：HandlerAdapter 处理器适配</li>
</ul>
</li>
<li>MyBatis（参考：<a href="https://blog.csdn.net/aha_jasper/article/details/108701785">https://blog.csdn.net/aha_jasper&#x2F;article&#x2F;details&#x2F;108701785</a> ） <ul>
<li>Builder + Factory 模式：创建 SqlSession 工厂和 SqlSession</li>
<li>模板方法模式：BaseExecutor 定义执行器基本流程</li>
<li>解释器模式：SqlNode 动态解析 SQL</li>
<li>单例模式：ErrorContext 线程唯一</li>
<li>装饰器模式：Cache 的实现用组合而非继承实现更灵活地缓存方式结合</li>
<li>迭代器模式：PropertyTokenizer 利用迭代器模式实现属性解析器</li>
<li>适配器模式：Log 适配不同的日志框架</li>
</ul>
</li>
<li>Google Guava（参考：<a href="https://blog.csdn.net/aha_jasper/article/details/108695561">https://blog.csdn.net/aha_jasper&#x2F;article&#x2F;details&#x2F;108695561</a> ） <ul>
<li>Builder 模式：更方便地构建内存缓存</li>
<li>Wrapper 模式（代理模式、装饰器、适配器模式）：轻松实现对类的扩展</li>
<li>Immutable 模式：不可变集合实现，如 ImmutableList、ImmutableSet、ImmutableMap 等</li>
</ul>
</li>
<li>更多可以自行学习： <ul>
<li>Netty</li>
<li>SpringBoot</li>
<li>Tomcat</li>
<li>Dubbo</li>
<li>Spring Cloud</li>
</ul>
</li>
</ul>
<h3 id="四、备战面试"><a href="#四、备战面试" class="headerlink" title="四、备战面试"></a>四、备战面试</h3><p>面试时对设计模式的考察主要有 4 种形式：</p>
<ol>
<li>直接问你某个设计模式的作用和大致的原理，考察你对设计模式的了解程度</li>
<li>让你手写某个设计模式的代码，考察你对设计模式的熟悉程度和编码能力</li>
<li>给你一个实际的业务场景，让你去设计系统，考察你对设计模式的理解应用能力和逻辑思维</li>
<li>问你某个框架（轮子）的核心设计和源码细节，考察你对设计模式的理解应用能力</li>
</ol>
<h4 id="经典面试题"><a href="#经典面试题" class="headerlink" title="经典面试题"></a>经典面试题</h4><ol>
<li>理论：简单介绍一下软件开发原则？</li>
<li>理论：设计模式如何分类？</li>
<li>你用过哪些设计模式？举例说明设计模式在你的项目或是某个框架源码中的应用。</li>
<li>说出某个设计模式的优缺点？什么时候使用它？</li>
<li>单例模式有哪些实现方式？分别有哪些优缺点？请手写其中一种</li>
<li>原型模式和单例模式的区别是什么？</li>
<li>简单工厂、工厂方法和抽象工厂三者有什么区别？</li>
<li>介绍一下代理模式，说一下静态代理和动态代理（比如 Spring AOP 就用到了）的区别？</li>
</ol>
<h4 id="资源-1"><a href="#资源-1" class="headerlink" title="资源"></a>资源</h4><ul>
<li>设计模式面试题汇总：<a href="https://pan.baidu.com/s/1tjIGc7pnHjgiFPo0fhcKXw">https://pan.baidu.com/s/1tjIGc7pnHjgiFPo0fhcKXw</a> 提取码: wuan（朋友 JavaGuide 整理，很全面 👍🏻）</li>
<li>面试官最爱问的13道”设计模式”题（视频）：<a href="https://www.bilibili.com/video/BV1fR4y1N74H">https://www.bilibili.com/video/BV1fR4y1N74H</a></li>
<li>设计模式图解与各语言实例代码 ： <a href="https://refactoringguru.cn/design-patterns">https://refactoringguru.cn/design-patterns</a></li>
</ul>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
  </entry>
  <entry>
    <title>《计算机考研机试指南》第2版题目链接及代码</title>
    <url>/blog/cskaoyan-algorithm-links/</url>
    <content><![CDATA[<div class="note info">

<p>Preparing for 2022 ECNU Dase Master&#39;s Degree Graduate Re-examination Prepare.<br>教材参考王道《计算机考研机试指南》，课程视频参考天勤上机辅导系列教程。</p>
</div>

<span id="more"></span>

<h2 id="第1章-从零开始"><a href="#第1章-从零开始" class="headerlink" title="第1章 从零开始"></a>第1章 从零开始</h2><blockquote>
<ul>
<li><a href="https://book.douban.com/subject/34901239/">《王道考研机试指南》</a></li>
<li>题解（书籍作者炉灰）：<a href="https://github.com/BenedictYoung/Lecture">例题代码</a>   <a href="https://github.com/BenedictYoung/Practice">习题代码</a></li>
<li>视频教程：<a href="https://youtube.com/playlist?list=PLjAs5kw1NNs2QSuOBgx0Y5wdugbT5173k&si=IejPCWkmq1Bc72fg">2021版上机辅导</a></li>
</ul>
</blockquote>
<h2 id="第2章-暴力求解"><a href="#第2章-暴力求解" class="headerlink" title="第2章 暴力求解"></a>第2章 暴力求解</h2><h3 id="2-1-枚举"><a href="#2-1-枚举" class="headerlink" title="2.1 枚举"></a>2.1 枚举</h3><table>
<thead>
<tr>
<th></th>
<th>题目</th>
<th>地址</th>
</tr>
</thead>
<tbody><tr>
<td>例题2.1</td>
<td>abc（清华大学复试上机题）</td>
<td><a href="http://t.cn/E9WMRTE">http://t.cn/E9WMRTE</a></td>
</tr>
<tr>
<td>例题2.2</td>
<td>反序数（清华大学复试上机题）</td>
<td><a href="http://t.cn/E9WBrut">http://t.cn/E9WBrut</a></td>
</tr>
<tr>
<td>例题2.3</td>
<td>对称平方数1（清华大学复试上机题）</td>
<td><a href="http://t.cn/E9lUYRn">http://t.cn/E9lUYRn</a></td>
</tr>
<tr>
<td>习题2.1</td>
<td>与7无关的数（北京大学复试上机题）</td>
<td><a href="http://t.cn/E9lOOZQ">http://t.cn/E9lOOZQ</a></td>
</tr>
<tr>
<td>习题2.2</td>
<td>百鸡问题（北京哈尔滨工业大学复试上机题）</td>
<td><a href="http://t.cn/E9ldhru">http://t.cn/E9ldhru</a></td>
</tr>
<tr>
<td>习题2.3</td>
<td>old bill（上海交通大学复试上机题）</td>
<td><a href="http://t.cn/E9jqijR">http://t.cn/E9jqijR</a></td>
</tr>
</tbody></table>
<h3 id="2-2-模拟"><a href="#2-2-模拟" class="headerlink" title="2.2 模拟"></a>2.2 模拟</h3><h4 id="1-图形排版"><a href="#1-图形排版" class="headerlink" title="1. 图形排版"></a>1. 图形排版</h4><table>
<thead>
<tr>
<th></th>
<th>题目</th>
<th>地址</th>
</tr>
</thead>
<tbody><tr>
<td>例题2.4</td>
<td>输出梯形（清华大学复试上机题）</td>
<td></td>
</tr>
<tr>
<td>例题2.5</td>
<td>叠筐</td>
<td><a href="http://shorturl.at/goWY8">http://shorturl.at/goWY8</a></td>
</tr>
<tr>
<td>习题2.4</td>
<td>Repeater（北京大学复试上机题）</td>
<td><a href="http://t.cn/E9jcaVb">http://t.cn/E9jcaVb</a></td>
</tr>
<tr>
<td>习题2.5</td>
<td>Hello World for U（浙江大学复试上机题）</td>
<td><a href="http://t.cn/E9jizni">http://t.cn/E9jizni</a></td>
</tr>
</tbody></table>
<h4 id="2-日期问题"><a href="#2-日期问题" class="headerlink" title="2. 日期问题"></a>2. 日期问题</h4><table>
<thead>
<tr>
<th></th>
<th>题目</th>
<th>地址</th>
</tr>
</thead>
<tbody><tr>
<td>例题2.6</td>
<td>今年的第几天？（清华大学复试上机题）</td>
<td><a href="http://t.cn/E9jXK5A">http://t.cn/E9jXK5A</a></td>
</tr>
<tr>
<td>例题2.7</td>
<td>打印日期（华中科技大学复试上机题）</td>
<td><a href="http://t.cn/E9YP2a8">http://t.cn/E9YP2a8</a></td>
</tr>
<tr>
<td>例题2.8</td>
<td>日期累加（北京理工大学复试上机题）</td>
<td><a href="http://t.cn/E9Yw0Cr">http://t.cn/E9Yw0Cr</a></td>
</tr>
<tr>
<td>习题2.6</td>
<td>日期差值（上海交通大学复试上机题）</td>
<td><a href="http://t.cn/E9Yz0LE">http://t.cn/E9Yz0LE</a></td>
</tr>
<tr>
<td>习题2.7</td>
<td>Day of Week（清华大学复试上机题）</td>
<td><a href="http://t.cn/E9YZLbi">http://t.cn/E9YZLbi</a></td>
</tr>
<tr>
<td>习题2.8</td>
<td>日期类（北京理工大学复试上机题）</td>
<td><a href="http://t.cn/E9RJUp4">http://t.cn/E9RJUp4</a></td>
</tr>
</tbody></table>
<h4 id="3-其他模拟"><a href="#3-其他模拟" class="headerlink" title="3. 其他模拟"></a>3. 其他模拟</h4><table>
<thead>
<tr>
<th></th>
<th>题目</th>
<th>地址</th>
</tr>
</thead>
<tbody><tr>
<td>例题2.9</td>
<td>剩下的树（清华大学复试上机题）</td>
<td><a href="http://t.cn/E9ufYo5">http://t.cn/E9ufYo5</a></td>
</tr>
<tr>
<td>例题2.10</td>
<td>手机键盘（清华大学复试上机题）</td>
<td><a href="http://t.cn/E9ulcIc">http://t.cn/E9ulcIc</a></td>
</tr>
<tr>
<td>例题2.11</td>
<td>XXX定律（浙江大学复试上机题）</td>
<td><a href="http://t.cn/E937wDs">http://t.cn/E937wDs</a></td>
</tr>
<tr>
<td>习题2.9</td>
<td>Grading（浙江大学复试上机题）</td>
<td><a href="http://t.cn/E9rDPSq">http://t.cn/E9rDPSq</a></td>
</tr>
<tr>
<td>习题2.10</td>
<td>路径打印（上海交通大学复试上机题）</td>
<td><a href="http://t.cn/E9dvHs4">http://t.cn/E9dvHs4</a></td>
</tr>
<tr>
<td>习题2.11</td>
<td>坠落的蚂蚁（北京大学复试上机题）</td>
<td><a href="http://t.cn/E9dhoRA">http://t.cn/E9dhoRA</a></td>
</tr>
</tbody></table>
<h2 id="第3章-排序与查找"><a href="#第3章-排序与查找" class="headerlink" title="第3章 排序与查找"></a>第3章 排序与查找</h2><h3 id="3-1-排序"><a href="#3-1-排序" class="headerlink" title="3.1 排序"></a>3.1 排序</h3><table>
<thead>
<tr>
<th></th>
<th>题目</th>
<th>地址</th>
</tr>
</thead>
<tbody><tr>
<td>例题3.1</td>
<td>排序（清华大学复试上机题）</td>
<td><a href="http://t.cn/E9dLx5K">http://t.cn/E9dLx5K</a></td>
</tr>
<tr>
<td>例题3.2</td>
<td>成绩排序（清华大学复试上机题）</td>
<td><a href="http://t.cn/E9d3ysv">http://t.cn/E9d3ysv</a></td>
</tr>
<tr>
<td>例题3.3</td>
<td>成绩排序2（清华大学复试上机题）</td>
<td><a href="http://t.cn/E9gyHM1">http://t.cn/E9gyHM1</a></td>
</tr>
<tr>
<td>习题3.1</td>
<td>特殊排序（华中科技大学复试上机题）</td>
<td><a href="http://t.cn/E9gio39">http://t.cn/E9gio39</a></td>
</tr>
<tr>
<td>习题3.2</td>
<td>整数奇偶排序（北京大学复试上机题）</td>
<td><a href="http://t.cn/E9glPvp">http://t.cn/E9glPvp</a></td>
</tr>
<tr>
<td>习题3.3</td>
<td>小白鼠排队（北京大学复试上机题）</td>
<td><a href="http://t.cn/E9gXh9Z">http://t.cn/E9gXh9Z</a></td>
</tr>
<tr>
<td>习题3.4</td>
<td>奥运排序问题（浙江大学复试上机题）</td>
<td><a href="http://t.cn/E9gYpyl">http://t.cn/E9gYpyl</a></td>
</tr>
</tbody></table>
<h3 id="3-2-查找"><a href="#3-2-查找" class="headerlink" title="3.2 查找"></a>3.2 查找</h3><table>
<thead>
<tr>
<th></th>
<th>题目</th>
<th>地址</th>
</tr>
</thead>
<tbody><tr>
<td>例题3.4</td>
<td>找x（哈尔滨工业大学复试上机题）</td>
<td><a href="http://t.cn/E9gHFnS">http://t.cn/E9gHFnS</a></td>
</tr>
<tr>
<td>例题3.5</td>
<td>查找（北京邮电大学复试上机题）</td>
<td><a href="http://t.cn/E9g8aaR">http://t.cn/E9g8aaR</a></td>
</tr>
<tr>
<td>习题3.5</td>
<td>找最小数（北京邮电大学复试上机题）</td>
<td><a href="http://t.cn/E9gekWa">http://t.cn/E9gekWa</a></td>
</tr>
<tr>
<td>习题3.6</td>
<td>打印极值点下标（北京大学复试上机题）</td>
<td><a href="http://t.cn/E9ehDw4">http://t.cn/E9ehDw4</a></td>
</tr>
<tr>
<td>习题3.7</td>
<td>找位置（华中科技大学复试上机题）</td>
<td><a href="http://t.cn/E9eh4jY">http://t.cn/E9eh4jY</a></td>
</tr>
</tbody></table>
<h2 id="第4章-字符串"><a href="#第4章-字符串" class="headerlink" title="第4章 字符串"></a>第4章 字符串</h2><h3 id="4-1-字符串"><a href="#4-1-字符串" class="headerlink" title="4.1 字符串"></a>4.1 字符串</h3><h3 id="4-2-字符串处理"><a href="#4-2-字符串处理" class="headerlink" title="4.2 字符串处理"></a>4.2 字符串处理</h3><table>
<thead>
<tr>
<th></th>
<th>题目</th>
<th>地址</th>
</tr>
</thead>
<tbody><tr>
<td>例题4.1</td>
<td>特殊乘法（清华大学复试上机题）</td>
<td><a href="http://t.cn/Ai8by9vW">http://t.cn/Ai8by9vW</a></td>
</tr>
<tr>
<td>例题4.2</td>
<td>密码翻译（北京大学复试上机题）</td>
<td><a href="http://t.cn/Ai8bGaIx">http://t.cn/Ai8bGaIx</a></td>
</tr>
<tr>
<td>例题4.3</td>
<td>简单密码（北京大学复试上机题）</td>
<td><a href="http://t.cn/Ai8bih2z">http://t.cn/Ai8bih2z</a></td>
</tr>
<tr>
<td>例题4.4</td>
<td>统计字符（浙江大学复试上机题）</td>
<td><a href="http://t.cn/Ai8fvq4I">http://t.cn/Ai8fvq4I</a></td>
</tr>
<tr>
<td>例题4.5</td>
<td>字母统计（上海交通大学复试上机题）</td>
<td><a href="http://t.cn/Ai8VB72e">http://t.cn/Ai8VB72e</a></td>
</tr>
<tr>
<td>习题4.1</td>
<td>skew数（北京大学复试上机题）</td>
<td><a href="http://t.cn/Ai8IALKI">http://t.cn/Ai8IALKI</a></td>
</tr>
<tr>
<td>习题4.2</td>
<td>单词替换（北京大学复试上机题）</td>
<td><a href="http://t.cn/Ai8Iycp6">http://t.cn/Ai8Iycp6</a></td>
</tr>
<tr>
<td>习题4.3</td>
<td>首字母大写（北京大学复试上机题）</td>
<td><a href="http://t.cn/Ai8I2hco">http://t.cn/Ai8I2hco</a></td>
</tr>
<tr>
<td>习题4.4</td>
<td>浮点数加法（北京大学复试上机题）</td>
<td><a href="http://t.cn/Ai8I4v0j">http://t.cn/Ai8I4v0j</a></td>
</tr>
<tr>
<td>习题4.5</td>
<td>后缀字符串排序（上海交通大学复试上机题）</td>
<td><a href="http://1t.click/VGP">http://1t.click/VGP</a></td>
</tr>
</tbody></table>
<h3 id="4-3-字符串匹配"><a href="#4-3-字符串匹配" class="headerlink" title="4.3 字符串匹配"></a>4.3 字符串匹配</h3><table>
<thead>
<tr>
<th></th>
<th>题目</th>
<th>地址</th>
</tr>
</thead>
<tbody><tr>
<td>例题4.6</td>
<td>Number Sequence</td>
<td><a href="http://shorturl.at/OQUV6">http://shorturl.at/OQUV6</a></td>
</tr>
<tr>
<td>例题4.7</td>
<td>Oulipo</td>
<td><a href="http://poj.org/problem?id=3461">http://poj.org/problem?id=3461</a></td>
</tr>
<tr>
<td>习题4.6</td>
<td>字符串匹配（北京航空航天大学复试上机题）</td>
<td><a href="http://1t.click/VGG">http://1t.click/VGG</a></td>
</tr>
<tr>
<td>习题4.7</td>
<td>String Matching（上海交通大学复试上机题）</td>
<td><a href="http://1t.click/VGH">http://1t.click/VGH</a></td>
</tr>
</tbody></table>
<h2 id="第5章-数据结构一"><a href="#第5章-数据结构一" class="headerlink" title="第5章 数据结构一"></a>第5章 数据结构一</h2><h3 id="5-1-向量"><a href="#5-1-向量" class="headerlink" title="5.1 向量"></a>5.1 向量</h3><table>
<thead>
<tr>
<th></th>
<th>题目</th>
<th>地址</th>
</tr>
</thead>
<tbody><tr>
<td>例题5.1</td>
<td>完数与盈数（清华大学复试上机题）</td>
<td><a href="http://t.cn/AiKEyQWW">http://t.cn/AiKEyQWW</a></td>
</tr>
</tbody></table>
<h3 id="5-2-队列"><a href="#5-2-队列" class="headerlink" title="5.2 队列"></a>5.2 队列</h3><table>
<thead>
<tr>
<th></th>
<th>题目</th>
<th>地址</th>
</tr>
</thead>
<tbody><tr>
<td>例题5.2</td>
<td>约瑟夫问题NO.2</td>
<td><a href="http://bailian.openjudge.cn/practice/3254">http://bailian.openjudge.cn/practice/3254</a></td>
</tr>
<tr>
<td>例题5.3</td>
<td>猫狗收容所</td>
<td></td>
</tr>
</tbody></table>
<h3 id="5-3-栈"><a href="#5-3-栈" class="headerlink" title="5.3 栈"></a>5.3 栈</h3><table>
<thead>
<tr>
<th></th>
<th>题目</th>
<th>地址</th>
</tr>
</thead>
<tbody><tr>
<td>例题5.4</td>
<td>Zero-complexity Transposition（交大复试上机题）</td>
<td><a href="http://t.cn/AiKa20bt">http://t.cn/AiKa20bt</a></td>
</tr>
<tr>
<td>例题5.5</td>
<td>括号匹配问题</td>
<td><a href="http://shorturl.at/mpvx7">http://shorturl.at/mpvx7</a></td>
</tr>
<tr>
<td>例题5.6</td>
<td>简单计算器（浙江大学复试上机题）</td>
<td><a href="http://t.cn/AiKoGS94">http://t.cn/AiKoGS94</a></td>
</tr>
<tr>
<td>习题5.1</td>
<td>堆栈的使用（吉林大学复试上机题）</td>
<td><a href="http://t.cn/AiKKM6F6">http://t.cn/AiKKM6F6</a></td>
</tr>
<tr>
<td>习题5.2</td>
<td>计算表达式（上海交通大学复试上机题）</td>
<td><a href="http://t.cn/AiKKJjJ5">http://t.cn/AiKKJjJ5</a></td>
</tr>
</tbody></table>
<h2 id="第6章-数学问题"><a href="#第6章-数学问题" class="headerlink" title="第6章 数学问题"></a>第6章 数学问题</h2><h3 id="6-1-进制转换"><a href="#6-1-进制转换" class="headerlink" title="6.1 进制转换"></a>6.1 进制转换</h3><table>
<thead>
<tr>
<th></th>
<th>题目</th>
<th>地址</th>
</tr>
</thead>
<tbody><tr>
<td>例题6.1</td>
<td>二进制数（北京邮电大学复试上机题）</td>
<td><a href="http://t.cn/AiCuKTOv">http://t.cn/AiCuKTOv</a></td>
</tr>
<tr>
<td>例题6.2</td>
<td>进制转换（清华大学复试上机题）</td>
<td><a href="http://t.cn/AiCuoPRO">http://t.cn/AiCuoPRO</a></td>
</tr>
<tr>
<td>例题6.3</td>
<td>十进制与二进制（清华大学复试上机题）</td>
<td><a href="http://t.cn/AiCuoHKg">http://t.cn/AiCuoHKg</a></td>
</tr>
<tr>
<td>例题6.4</td>
<td>进制转换2（清华大学复试上机题）</td>
<td><a href="http://t.cn/AiCuKG7E">http://t.cn/AiCuKG7E</a></td>
</tr>
<tr>
<td>习题6.1</td>
<td>八进制（华中科技大学复试上机题）</td>
<td><a href="http://t.cn/AiCu0lHe">http://t.cn/AiCu0lHe</a></td>
</tr>
<tr>
<td>习题6.2</td>
<td>又一版A+B（浙江大学复试上机题）</td>
<td><a href="http://t.cn/AiCuOSWv">http://t.cn/AiCuOSWv</a></td>
</tr>
<tr>
<td>习题6.3</td>
<td>进制转换（北京大学复试上机题）</td>
<td><a href="http://t.cn/AiCuig9B">http://t.cn/AiCuig9B</a></td>
</tr>
<tr>
<td>习题6.4</td>
<td>数制转换（北京大学复试上机题）</td>
<td><a href="http://t.cn/AiCu6ne4">http://t.cn/AiCu6ne4</a></td>
</tr>
</tbody></table>
<h3 id="6-2-最大公约数与最小公倍数"><a href="#6-2-最大公约数与最小公倍数" class="headerlink" title="6.2 最大公约数与最小公倍数"></a>6.2 最大公约数与最小公倍数</h3><table>
<thead>
<tr>
<th></th>
<th>题目</th>
<th>地址</th>
</tr>
</thead>
<tbody><tr>
<td>例题6.5</td>
<td>最大公约数（哈尔滨工业大学复试上机题）</td>
<td><a href="http://t.cn/AiCuWLTS">http://t.cn/AiCuWLTS</a></td>
</tr>
<tr>
<td>例题6.6</td>
<td>最小公倍数</td>
<td><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1108">http://acm.hdu.edu.cn/showproblem.php?pid=1108</a></td>
</tr>
<tr>
<td>习题6.5</td>
<td>最简真分数（北京大学复试上机题）</td>
<td><a href="http://t.cn/AiCua2g8">http://t.cn/AiCua2g8</a></td>
</tr>
</tbody></table>
<h3 id="6-3-质数"><a href="#6-3-质数" class="headerlink" title="6.3 质数"></a>6.3 质数</h3><table>
<thead>
<tr>
<th></th>
<th>题目</th>
<th>地址</th>
</tr>
</thead>
<tbody><tr>
<td>例题6.7</td>
<td>素数判定（哈尔滨工业大学复试上机题）</td>
<td><a href="http://t.cn/AiCuWE0Q">http://t.cn/AiCuWE0Q</a></td>
</tr>
<tr>
<td>例题6.8</td>
<td>素数</td>
<td><a href="http://t.cn/AiCulqtW">http://t.cn/AiCulqtW</a></td>
</tr>
<tr>
<td>习题6.6</td>
<td>Prime Number（上海交通大学复试上机题）</td>
<td><a href="http://t.cn/AiCulrSh">http://t.cn/AiCulrSh</a></td>
</tr>
</tbody></table>
<h3 id="6-4-分解质因数"><a href="#6-4-分解质因数" class="headerlink" title="6.4 分解质因数"></a>6.4 分解质因数</h3><table>
<thead>
<tr>
<th></th>
<th>题目</th>
<th>地址</th>
</tr>
</thead>
<tbody><tr>
<td>例题6.9</td>
<td>质因数的个数（清华大学复试上机题）</td>
<td><a href="http://t.cn/Aip7J0Oo">http://t.cn/Aip7J0Oo</a></td>
</tr>
<tr>
<td>习题6.7</td>
<td>约数的个数（清华大学复试上机题）</td>
<td><a href="http://t.cn/Aip7dTUp">http://t.cn/Aip7dTUp</a></td>
</tr>
<tr>
<td>习题6.8</td>
<td>整除问题（上海交通大学复试上机题）</td>
<td><a href="http://t.cn/Aip7eHBD">http://t.cn/Aip7eHBD</a></td>
</tr>
</tbody></table>
<h3 id="6-5-快速幂"><a href="#6-5-快速幂" class="headerlink" title="6.5 快速幂"></a>6.5 快速幂</h3><table>
<thead>
<tr>
<th></th>
<th>题目</th>
<th>地址</th>
</tr>
</thead>
<tbody><tr>
<td>例题6.10</td>
<td>人见人爱A^B</td>
<td><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2035">http://acm.hdu.edu.cn/showproblem.php?pid=2035</a></td>
</tr>
<tr>
<td>习题6.9</td>
<td>求root(N,K)（清华大学复试上机题）</td>
<td><a href="http://t.cn/AipAw4B1">http://t.cn/AipAw4B1</a></td>
</tr>
</tbody></table>
<h3 id="6-6-矩阵与矩阵快速幂"><a href="#6-6-矩阵与矩阵快速幂" class="headerlink" title="6.6 矩阵与矩阵快速幂"></a>6.6 矩阵与矩阵快速幂</h3><table>
<thead>
<tr>
<th></th>
<th>题目</th>
<th>地址</th>
</tr>
</thead>
<tbody><tr>
<td>例题6.11</td>
<td>计算两个矩阵的乘积（哈尔滨工业大学复试上机题）</td>
<td><a href="http://t.cn/Aip450PJ">http://t.cn/Aip450PJ</a></td>
</tr>
<tr>
<td>例题6.12</td>
<td>矩阵幂（北京邮电大学复试上机题）</td>
<td><a href="http://t.cn/Aip4T3HX">http://t.cn/Aip4T3HX</a></td>
</tr>
<tr>
<td>习题6.10</td>
<td>A+B for Matrices（浙江大学复试上机题）</td>
<td><a href="http://t.cn/Aipb7GBG">http://t.cn/Aipb7GBG</a></td>
</tr>
<tr>
<td>习题6.11</td>
<td>递推数列（清华大学复试上机题）</td>
<td><a href="http://t.cn/AipbZ2sS">http://t.cn/AipbZ2sS</a></td>
</tr>
</tbody></table>
<h3 id="6-7-高精度整数"><a href="#6-7-高精度整数" class="headerlink" title="6.7 高精度整数"></a>6.7 高精度整数</h3><table>
<thead>
<tr>
<th></th>
<th>题目</th>
<th>地址</th>
</tr>
</thead>
<tbody><tr>
<td>例题6.13</td>
<td>a+b（华中科技大学复试上机题）</td>
<td><a href="http://t.cn/AipaWiSG">http://t.cn/AipaWiSG</a></td>
</tr>
<tr>
<td>例题6.14</td>
<td>N的阶乘（清华大学复试上机题）</td>
<td><a href="http://t.cn/AipaBKQJ">http://t.cn/AipaBKQJ</a></td>
</tr>
<tr>
<td>习题6.12</td>
<td>数字阶梯求和（哈尔滨工业大学复试上机题）</td>
<td><a href="http://t.cn/Aipak8BQ">http://t.cn/Aipak8BQ</a></td>
</tr>
<tr>
<td>习题6.13</td>
<td>大整数的因子（北京大学复试上机题）</td>
<td><a href="http://t.cn/AipaFCJE">http://t.cn/AipaFCJE</a></td>
</tr>
</tbody></table>
<h2 id="第7章-贪心策略"><a href="#第7章-贪心策略" class="headerlink" title="第7章 贪心策略"></a>第7章 贪心策略</h2><h3 id="7-1-简单贪心"><a href="#7-1-简单贪心" class="headerlink" title="7.1 简单贪心"></a>7.1 简单贪心</h3><table>
<thead>
<tr>
<th></th>
<th>题目</th>
<th>地址</th>
</tr>
</thead>
<tbody><tr>
<td>例题7.1</td>
<td>鸡兔同笼（北京大学复试上机题）</td>
<td><a href="http://t.cn/E9ewERU">http://t.cn/E9ewERU</a></td>
</tr>
<tr>
<td>例题7.2</td>
<td>FatMouse’ Trade</td>
<td><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1009">http://acm.hdu.edu.cn/showproblem.php?pid=1009</a></td>
</tr>
<tr>
<td>例题7.3</td>
<td>Senior’s Gun</td>
<td><a href="http://acm.hdu.edu.cn/showproblem.php?pid=5281">http://acm.hdu.edu.cn/showproblem.php?pid=5281</a></td>
</tr>
<tr>
<td>习题7.1</td>
<td>代理服务器（清华大学复试上机题）</td>
<td><a href="http://t.cn/E9emuS9">http://t.cn/E9emuS9</a></td>
</tr>
</tbody></table>
<h3 id="7-2-区间贪心"><a href="#7-2-区间贪心" class="headerlink" title="7.2 区间贪心"></a>7.2 区间贪心</h3><table>
<thead>
<tr>
<th></th>
<th>题目</th>
<th>地址</th>
</tr>
</thead>
<tbody><tr>
<td>例题7.4</td>
<td>今年暑假不AC</td>
<td><a href="http://shorturl.at/eGPW4">http://shorturl.at/eGPW4</a></td>
</tr>
<tr>
<td>例题7.5</td>
<td>Case of Fugitive</td>
<td><a href="http://codeforces.com/problemset/problem/555/B">http://codeforces.com/problemset/problem/555/B</a></td>
</tr>
<tr>
<td>习题7.2</td>
<td>To Fill or Not to Fill（清华复试上机题）</td>
<td><a href="http://dwz.date/b2tj">http://dwz.date/b2tj</a></td>
</tr>
</tbody></table>
<h2 id="第8章-递归与分治"><a href="#第8章-递归与分治" class="headerlink" title="第8章 递归与分治"></a>第8章 递归与分治</h2><h3 id="8-1-递归策略"><a href="#8-1-递归策略" class="headerlink" title="8.1 递归策略"></a>8.1 递归策略</h3><table>
<thead>
<tr>
<th></th>
<th>题目</th>
<th>地址</th>
</tr>
</thead>
<tbody><tr>
<td>例题8.1</td>
<td>n的阶乘（清华大学复试上机题）</td>
<td><a href="http://t.cn/Ai0ocOUY">http://t.cn/Ai0ocOUY</a></td>
</tr>
<tr>
<td>例题8.2</td>
<td>汉诺塔Ⅲ</td>
<td><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2064">http://acm.hdu.edu.cn/showproblem.php?pid=2064</a></td>
</tr>
<tr>
<td>习题8.1</td>
<td>杨辉三角形（西北工业大学复试上机题）</td>
<td><a href="http://t.cn/Ai0KcLRI">http://t.cn/Ai0KcLRI</a></td>
</tr>
<tr>
<td>习题8.2</td>
<td>全排列（北京大学复试上机题）</td>
<td><a href="http://t.cn/Ai0K0hXZ">http://t.cn/Ai0K0hXZ</a></td>
</tr>
</tbody></table>
<h3 id="8-2-分治法"><a href="#8-2-分治法" class="headerlink" title="8.2 分治法"></a>8.2 分治法</h3><table>
<thead>
<tr>
<th></th>
<th>题目</th>
<th>地址</th>
</tr>
</thead>
<tbody><tr>
<td>例题8.3</td>
<td>Fibonacci（上海交通大学复试上机题）</td>
<td><a href="http://t.cn/Ai0K3tU5">http://t.cn/Ai0K3tU5</a></td>
</tr>
<tr>
<td>例题8.4</td>
<td>二叉树（北京大学复试上机题）</td>
<td><a href="http://t.cn/Ai0Ke6I0">http://t.cn/Ai0Ke6I0</a></td>
</tr>
<tr>
<td>习题8.3</td>
<td>2的幂次方（上海交通大学复试上机题）</td>
<td><a href="http://suo.im/5D5hnX">http://suo.im/5D5hnX</a></td>
</tr>
</tbody></table>
<h2 id="第9章-搜索"><a href="#第9章-搜索" class="headerlink" title="第9章 搜索"></a>第9章 搜索</h2><h3 id="9-1-宽度优先搜索"><a href="#9-1-宽度优先搜索" class="headerlink" title="9.1 宽度优先搜索"></a>9.1 宽度优先搜索</h3><table>
<thead>
<tr>
<th></th>
<th>题目</th>
<th>地址</th>
</tr>
</thead>
<tbody><tr>
<td>例题9.1</td>
<td>Catch That Cow</td>
<td><a href="http://poj.org/problem?id=3278">http://poj.org/problem?id=3278</a></td>
</tr>
<tr>
<td>例题9.2</td>
<td>Find The Multiple</td>
<td><a href="http://poj.org/problem?id=1426">http://poj.org/problem?id=1426</a></td>
</tr>
<tr>
<td>习题9.1</td>
<td>玛雅人的密码</td>
<td><a href="http://t.cn/Ai0lUhJj">http://t.cn/Ai0lUhJj</a></td>
</tr>
</tbody></table>
<h3 id="9-2-深度优先搜索"><a href="#9-2-深度优先搜索" class="headerlink" title="9.2 深度优先搜索"></a>9.2 深度优先搜索</h3><table>
<thead>
<tr>
<th></th>
<th>题目</th>
<th>地址</th>
</tr>
</thead>
<tbody><tr>
<td>例题9.3</td>
<td>A Knights’s Journey</td>
<td><a href="http://poj.org/problem?id=2488">http://poj.org/problem?id=2488</a></td>
</tr>
<tr>
<td>例题9.4</td>
<td>Square</td>
<td><a href="http://poj.org/problem?id=2362">http://poj.org/problem?id=2362</a></td>
</tr>
<tr>
<td>习题9.1</td>
<td>神奇的口袋（北京大学复试上机题）</td>
<td><a href="http://t.cn/Ai0u0GUz">http://t.cn/Ai0u0GUz</a></td>
</tr>
<tr>
<td>习题9.2</td>
<td>八皇后（北京大学复试上机题）</td>
<td><a href="http://t.cn/Ai0uOazs">http://t.cn/Ai0uOazs</a></td>
</tr>
</tbody></table>
<h2 id="第10章-数据结构二"><a href="#第10章-数据结构二" class="headerlink" title="第10章 数据结构二"></a>第10章 数据结构二</h2><h3 id="10-1-二叉树"><a href="#10-1-二叉树" class="headerlink" title="10.1 二叉树"></a>10.1 二叉树</h3><table>
<thead>
<tr>
<th></th>
<th>题目</th>
<th>地址</th>
</tr>
</thead>
<tbody><tr>
<td>例题10.1</td>
<td>二叉树遍历（清华大学复试上机题）</td>
<td><a href="http://t.cn/AiKuUTlX">http://t.cn/AiKuUTlX</a></td>
</tr>
<tr>
<td>例题10.2</td>
<td>二叉树遍历（华中科技大学复试上机题）</td>
<td><a href="http://t.cn/AiKgDfLU">http://t.cn/AiKgDfLU</a></td>
</tr>
</tbody></table>
<h3 id="10-2-二叉排序树"><a href="#10-2-二叉排序树" class="headerlink" title="10.2 二叉排序树"></a>10.2 二叉排序树</h3><table>
<thead>
<tr>
<th></th>
<th>题目</th>
<th>地址</th>
</tr>
</thead>
<tbody><tr>
<td>例题10.3</td>
<td>二叉排序树（华中科技大学复试上机题</td>
<td><a href="http://t.cn/Ai9PAkkv">http://t.cn/Ai9PAkkv</a></td>
</tr>
<tr>
<td>例题10.4</td>
<td>二叉排序树（华中科技大学复试上机题）</td>
<td><a href="http://t.cn/AiKD0L5V">http://t.cn/AiKD0L5V</a></td>
</tr>
<tr>
<td>习题10.1</td>
<td>二叉搜索树（浙江大学复试上机题）</td>
<td><a href="http://t.cn/Ai9PUJtK">http://t.cn/Ai9PUJtK</a></td>
</tr>
</tbody></table>
<h3 id="10-3-优先队列"><a href="#10-3-优先队列" class="headerlink" title="10.3 优先队列"></a>10.3 优先队列</h3><table>
<thead>
<tr>
<th></th>
<th>题目</th>
<th>地址</th>
</tr>
</thead>
<tbody><tr>
<td>例题10.5</td>
<td>复数集合（北京邮电大学复试上机题）</td>
<td><a href="http://t.cn/Ai98yYlt">http://t.cn/Ai98yYlt</a></td>
</tr>
<tr>
<td>例题10.6</td>
<td>哈夫曼树（北京邮电大学复试上机题）</td>
<td><a href="http://t.cn/AiCuGMki">http://t.cn/AiCuGMki</a></td>
</tr>
<tr>
<td>习题10.2</td>
<td>查找第K小的数（北京邮电大学复试上机题）</td>
<td><a href="http://t.cn/AiCu5hcK">http://t.cn/AiCu5hcK</a></td>
</tr>
<tr>
<td>习题10.3</td>
<td>搬水果（吉林大学复试上机题）</td>
<td><a href="http://t.cn/AiCu5nsQ">http://t.cn/AiCu5nsQ</a></td>
</tr>
</tbody></table>
<h3 id="10-4-散列表"><a href="#10-4-散列表" class="headerlink" title="10.4 散列表"></a>10.4 散列表</h3><table>
<thead>
<tr>
<th></th>
<th>题目</th>
<th>地址</th>
</tr>
</thead>
<tbody><tr>
<td>例题10.7</td>
<td>查找学生信息（清华大学复试上机题）</td>
<td><a href="http://t.cn/AiCuVIuY">http://t.cn/AiCuVIuY</a></td>
</tr>
<tr>
<td>例题10.8</td>
<td>魔咒词典（浙江大学复试上机题）</td>
<td><a href="http://t.cn/AiCufczt">http://t.cn/AiCufczt</a></td>
</tr>
<tr>
<td>例题10.9</td>
<td>字串计算（北京大学复试上机题）</td>
<td><a href="http://t.cn/AiCuJtI5">http://t.cn/AiCuJtI5</a></td>
</tr>
<tr>
<td>习题10.4</td>
<td>统计同成绩学生人数（浙江大学复试上机题）</td>
<td><a href="http://t.cn/Ai0u0GUz">http://t.cn/Ai0u0GUz</a></td>
</tr>
<tr>
<td>习题10.5</td>
<td>开门人和关门人(浙江大学复试上机题)</td>
<td><a href="http://t.cn/AiCuM09f">http://t.cn/AiCuM09f</a></td>
</tr>
<tr>
<td>习题10.6</td>
<td>谁是你的潜在朋友（北京大学复试上机题）</td>
<td><a href="http://t.cn/AiCux4f7">http://t.cn/AiCux4f7</a></td>
</tr>
</tbody></table>
<h2 id="第11章-图论"><a href="#第11章-图论" class="headerlink" title="第11章 图论"></a>第11章 图论</h2><h3 id="11-1-概述"><a href="#11-1-概述" class="headerlink" title="11.1 概述"></a>11.1 概述</h3><h3 id="11-2-并查集"><a href="#11-2-并查集" class="headerlink" title="11.2 并查集"></a>11.2 并查集</h3><table>
<thead>
<tr>
<th></th>
<th>题目</th>
<th>地址</th>
</tr>
</thead>
<tbody><tr>
<td>例题11.1</td>
<td>畅通工程（浙江大学复试上机题）</td>
<td><a href="http://t.cn/AiOvBHj9">http://t.cn/AiOvBHj9</a></td>
</tr>
<tr>
<td>例题11.2</td>
<td>连通图（吉林大学复试上机题）</td>
<td><a href="http://t.cn/AiO77VoA">http://t.cn/AiO77VoA</a></td>
</tr>
<tr>
<td>例题11.3</td>
<td>Is It A Tree?（北京大学复试上机题）</td>
<td><a href="http://t.cn/AiO7FyDO">http://t.cn/AiO7FyDO</a></td>
</tr>
<tr>
<td>习题11.1</td>
<td>找出直系亲属（浙江大学复试上机题）</td>
<td><a href="http://t.cn/AiOzTX5c">http://t.cn/AiOzTX5c</a></td>
</tr>
<tr>
<td>习题11.2</td>
<td>第一题（上海交通大学复试上机题）</td>
<td><a href="http://t.cn/AiOhkgMJ">http://t.cn/AiOhkgMJ</a></td>
</tr>
<tr>
<td>习题11.3</td>
<td>Head of a Gang（浙江大学复试上机题）</td>
<td><a href="http://t.cn/AiOzQMBH">http://t.cn/AiOzQMBH</a></td>
</tr>
</tbody></table>
<h3 id="11-3-最小生成树"><a href="#11-3-最小生成树" class="headerlink" title="11.3 最小生成树"></a>11.3 最小生成树</h3><table>
<thead>
<tr>
<th></th>
<th>题目</th>
<th>地址</th>
</tr>
</thead>
<tbody><tr>
<td>例题11.4</td>
<td>还是畅通工程（浙江大学复试上机题）</td>
<td><a href="http://t.cn/AiWud0C6">http://t.cn/AiWud0C6</a></td>
</tr>
<tr>
<td>例题11.5</td>
<td>继续畅通工程（浙江大学复试上机题）</td>
<td><a href="http://t.cn/AiW3fcfp">http://t.cn/AiW3fcfp</a></td>
</tr>
<tr>
<td>习题11.4</td>
<td>Freckles（北京大学复试上机题）</td>
<td><a href="http://t.cn/AiW3Hbqr">http://t.cn/AiW3Hbqr</a></td>
</tr>
<tr>
<td>习题11.5</td>
<td>Jungle Roads（北京大学复试上机题）</td>
<td><a href="http://t.cn/AiW33P91">http://t.cn/AiW33P91</a></td>
</tr>
</tbody></table>
<h3 id="11-4-最短路径"><a href="#11-4-最短路径" class="headerlink" title="11.4 最短路径"></a>11.4 最短路径</h3><table>
<thead>
<tr>
<th></th>
<th>题目</th>
<th>地址</th>
</tr>
</thead>
<tbody><tr>
<td>例题11.6</td>
<td>畅通工程续（浙江大学复试上机题）</td>
<td><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1874">http://acm.hdu.edu.cn/showproblem.php?pid=1874</a></td>
</tr>
<tr>
<td>例题11.7</td>
<td>最短路径问题（浙江大学复试上机题）</td>
<td><a href="http://t.cn/AilPbME2">http://t.cn/AilPbME2</a></td>
</tr>
<tr>
<td>习题11.6</td>
<td>最短路径（上海交通大学复试上机题）</td>
<td><a href="http://t.cn/AilPCAuL">http://t.cn/AilPCAuL</a></td>
</tr>
</tbody></table>
<h3 id="11-5-拓扑排序"><a href="#11-5-拓扑排序" class="headerlink" title="11.5 拓扑排序"></a>11.5 拓扑排序</h3><table>
<thead>
<tr>
<th></th>
<th>题目</th>
<th>地址</th>
</tr>
</thead>
<tbody><tr>
<td>例题11.8</td>
<td>Legal or Not</td>
<td><a href="http://acm.hdu.edu.cn/showproblem.php?pid=3342">http://acm.hdu.edu.cn/showproblem.php?pid=3342</a></td>
</tr>
<tr>
<td>例题11.9</td>
<td>确定比赛名次</td>
<td><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1285">http://acm.hdu.edu.cn/showproblem.php?pid=1285</a></td>
</tr>
</tbody></table>
<h3 id="11-6-关键路径"><a href="#11-6-关键路径" class="headerlink" title="11.6 关键路径"></a>11.6 关键路径</h3><table>
<thead>
<tr>
<th></th>
<th>题目</th>
<th>地址</th>
</tr>
</thead>
<tbody><tr>
<td>例题11.10</td>
<td>Instructions Arrangement</td>
<td><a href="http://acm.hdu.edu.cn/showproblem.php?pid=4109">http://acm.hdu.edu.cn/showproblem.php?pid=4109</a></td>
</tr>
<tr>
<td>例题11.11</td>
<td>p3（清华大学复试上机题）</td>
<td></td>
</tr>
</tbody></table>
<h2 id="第12章-动态规划"><a href="#第12章-动态规划" class="headerlink" title="第12章 动态规划"></a>第12章 动态规划</h2><h3 id="12-1-递归求解"><a href="#12-1-递归求解" class="headerlink" title="12.1 递归求解"></a>12.1 递归求解</h3><table>
<thead>
<tr>
<th></th>
<th>题目</th>
<th>地址</th>
</tr>
</thead>
<tbody><tr>
<td>例题12.1</td>
<td>N阶楼梯上楼问题（华中科技大学复试上机题）</td>
<td><a href="http://t.cn/Aij9Fr3V">http://t.cn/Aij9Fr3V</a></td>
</tr>
<tr>
<td>习题12.1</td>
<td>吃糖果（北京大学复试上机题）</td>
<td><a href="http://t.cn/AiQsVyKz">http://t.cn/AiQsVyKz</a></td>
</tr>
</tbody></table>
<h3 id="12-2-最大连续子序列和"><a href="#12-2-最大连续子序列和" class="headerlink" title="12.2 最大连续子序列和"></a>12.2 最大连续子序列和</h3><table>
<thead>
<tr>
<th></th>
<th>题目</th>
<th>地址</th>
</tr>
</thead>
<tbody><tr>
<td>例题12.2</td>
<td>最大序列和（清华大学复试上机题）</td>
<td><a href="http://t.cn/AiYSlQMU">http://t.cn/AiYSlQMU</a></td>
</tr>
<tr>
<td>例题12.3</td>
<td>最大子矩阵（北京大学复试上机题）</td>
<td><a href="http://t.cn/AiYSemJz">http://t.cn/AiYSemJz</a></td>
</tr>
<tr>
<td>习题12.2</td>
<td>最大连续子序列（浙江大学复试上机题）</td>
<td><a href="http://t.cn/AiYoUkjP">http://t.cn/AiYoUkjP</a></td>
</tr>
</tbody></table>
<h3 id="12-3-最长递增子序列"><a href="#12-3-最长递增子序列" class="headerlink" title="12.3 最长递增子序列"></a>12.3 最长递增子序列</h3><table>
<thead>
<tr>
<th></th>
<th>题目</th>
<th>地址</th>
</tr>
</thead>
<tbody><tr>
<td>例题12.4</td>
<td>拦截导弹（北京大学复试上机题）</td>
<td><a href="http://t.cn/AiYCeV3m">http://t.cn/AiYCeV3m</a></td>
</tr>
<tr>
<td>例题12.5</td>
<td>最长上升子序列和（北京大学复试上机题）</td>
<td><a href="http://t.cn/AiYNAGD3">http://t.cn/AiYNAGD3</a></td>
</tr>
<tr>
<td>习题12.3</td>
<td>合唱队形（北京大学复试上机题）</td>
<td><a href="http://t.cn/AiYNyHPe">http://t.cn/AiYNyHPe</a></td>
</tr>
</tbody></table>
<h3 id="12-4-最长公共子序列"><a href="#12-4-最长公共子序列" class="headerlink" title="12.4 最长公共子序列"></a>12.4 最长公共子序列</h3><table>
<thead>
<tr>
<th></th>
<th>题目</th>
<th>地址</th>
</tr>
</thead>
<tbody><tr>
<td>例题12.6</td>
<td>Common Subsequence</td>
<td><a href="http://shorturl.at/drv19">http://shorturl.at/drv19</a></td>
</tr>
<tr>
<td>习题12.4</td>
<td>Coincidence（上海交通大学复试上机题）</td>
<td><a href="http://t.cn/AiY03RO5">http://t.cn/AiY03RO5</a></td>
</tr>
</tbody></table>
<h3 id="12-5-背包问题"><a href="#12-5-背包问题" class="headerlink" title="12.5 背包问题"></a>12.5 背包问题</h3><h4 id="1-0-1背包"><a href="#1-0-1背包" class="headerlink" title="1.  0-1背包"></a>1.  0-1背包</h4><table>
<thead>
<tr>
<th></th>
<th>题目</th>
<th>地址</th>
</tr>
</thead>
<tbody><tr>
<td>例题12.7</td>
<td>点菜问题（北京大学复试上机题）</td>
<td><a href="http://t.cn/AiYOrkXr">http://t.cn/AiYOrkXr</a></td>
</tr>
<tr>
<td>习题12.5</td>
<td>采药（北京大学复试上机题）</td>
<td>地址错</td>
</tr>
<tr>
<td>习题12.6</td>
<td>最小邮票数（清华大学复试上机题）</td>
<td><a href="http://t.cn/AiYlwchD">http://t.cn/AiYlwchD</a></td>
</tr>
</tbody></table>
<h4 id="2-完全背包"><a href="#2-完全背包" class="headerlink" title="2. 完全背包"></a>2. 完全背包</h4><table>
<thead>
<tr>
<th></th>
<th>题目</th>
<th>地址</th>
</tr>
</thead>
<tbody><tr>
<td>例题12.8</td>
<td>Piggy-Bank</td>
<td><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1114">http://acm.hdu.edu.cn/showproblem.php?pid=1114</a></td>
</tr>
</tbody></table>
<h4 id="3-多重背包"><a href="#3-多重背包" class="headerlink" title="3. 多重背包"></a>3. 多重背包</h4><table>
<thead>
<tr>
<th></th>
<th>题目</th>
<th>地址</th>
</tr>
</thead>
<tbody><tr>
<td>例题12.9</td>
<td>珍惜现在，感恩生活</td>
<td><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2191">http://acm.hdu.edu.cn/showproblem.php?pid=2191</a></td>
</tr>
</tbody></table>
<h3 id="12-6-其他问题"><a href="#12-6-其他问题" class="headerlink" title="12.6 其他问题"></a>12.6 其他问题</h3><table>
<thead>
<tr>
<th></th>
<th>题目</th>
<th>地址</th>
</tr>
</thead>
<tbody><tr>
<td>例题12.10</td>
<td>The Triangle</td>
<td><a href="http://poj.org/problem?id=1163">http://poj.org/problem?id=1163</a></td>
</tr>
<tr>
<td>例题12.11</td>
<td>Monkey Banana Problem</td>
<td><a href="http://shorturl.at/emrS4">http://shorturl.at/emrS4</a></td>
</tr>
<tr>
<td>习题12.7</td>
<td>放苹果（北京大学复试上机题）</td>
<td><a href="http://t.cn/AiQsyOnq">http://t.cn/AiQsyOnq</a></td>
</tr>
<tr>
<td>习题12.8</td>
<td>整数拆分（清华大学复试上机题）</td>
<td><a href="http://t.cn/AiQsUM0Q">http://t.cn/AiQsUM0Q</a></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>DDS 协议介绍</title>
    <url>/blog/dds-tips/</url>
    <content><![CDATA[<div class="note info">

<ul>
<li>DDS是一种为实时系统设计的发布-订阅通信协议，其特点是去中心化、支持多种QoS机制和实时通信，和SOME&#x2F;IP类似但不完全相同。</li>
<li>RTI Connext DDS和Fast DDS（以前称为Fast RTPS）都是实现了DDS规范的中间件，本文是对DDS相关概念的介绍，以及对RTI Connext DDS和Fast DDS的一些基本对比。</li>
</ul>
</div>

<span id="more"></span>

<center>
    <strong>
        <font size="6">
            Data Distribution Service
        </font>
    </strong>
</center>

<h2 id="DDS介绍"><a href="#DDS介绍" class="headerlink" title="DDS介绍"></a>DDS介绍</h2><p>DDS（Data Distribution Service）是由OMG（Object Management Group）发布的分布式通信规范。</p>
<p>OMG成立于1989年，是一个国际性、开放性、非营利性的技术标准联盟，由供应商、终端用户、学术机构和政府机构推动。OMG工作组致力于制定企业集成标准和开发可为数千个垂直行业提供现实价值的技术标准，其中包括统一建模语言SYSML、UML，以及中间件标准CORBA、DDS等。</p>
<p>DDS最早应用于美国海军系统，用于解决在军舰系统复杂网络环境中进行大量软件升级时的兼容性问题。随着DDS被ROS2和AUTOSAR引入，目前它已经广泛应用于航空、航天、船舶、国防、金融、通信、汽车等领域。</p>
<p>目前，DDS已被多个车载中间件平台引入。AUTOSAR AP已完整地集成了DDS标准的网络绑定。另外，虽然AUTOSAR CP的标准规范本身不支持DDS，但通过一些变通方法也可以在CP上集成DDS。ROS2和CyberRT的底层都使用了开源的DDS作为最重要的通信机制。</p>
<h2 id="DDS特点"><a href="#DDS特点" class="headerlink" title="DDS特点"></a>DDS特点</h2><h3 id="数据中心（Data-Centricity）"><a href="#数据中心（Data-Centricity）" class="headerlink" title="数据中心（Data Centricity）"></a>数据中心（Data Centricity）</h3><p>DDS最重要的特性是以数据为中心，这与其他许多通信中间件不同。DDS的数据共享以Topic为单元，应用程序能够通过Topic判断包含的数据类型，而不必依赖其他上下文信息。同时，DDS能够按照用户定义的方式自动地存储、发布或订阅数据，使应用程序能够像访问本地数据一样进行数据的写入或读取。</p>
<h3 id="全局数据空间（Global-Data-space）"><a href="#全局数据空间（Global-Data-space）" class="headerlink" title="全局数据空间（Global Data space）"></a>全局数据空间（Global Data space）</h3><p>DDS实现的数据共享可以被理解为一个抽象的全局数据空间，无论应用程序是用哪种开发语言编写，或者在哪种操作系统上运行，都可以以相同的方式访问这个全局数据空间，就像访问本地存储空间一样。当然，全局数据空间只是一个抽象概念，在实际实现中，数据仍然被分别存储在每个应用程序的本地空间中。在系统运行时，数据是按需传输或存储的，数据的发布者只发送订阅者需要的数据，而订阅者只接收并存储本地应用程序当前所需的数据。</p>
<h3 id="服务质量（Quality-of-service）"><a href="#服务质量（Quality-of-service）" class="headerlink" title="服务质量（Quality of service）"></a>服务质量（Quality of service）</h3><p>DDS还提供了高度灵活的QoS（Quality of Service）策略，以满足用户对数据共享方式的不同需求，例如可靠性和故障处理等。对于对数据安全性要求较高的系统，DDS还提供了精细的数据安全控制，包括应用程序身份认证、权限控制和数据加密等。</p>
<h3 id="动态发现（Dynamic-Discovery）"><a href="#动态发现（Dynamic-Discovery）" class="headerlink" title="动态发现（Dynamic Discovery）"></a>动态发现（Dynamic Discovery）</h3><p>类似于SOME&#x2F;IP-SD，DDS提供了数据发布者和订阅者的动态发现机制，这意味着用户无需手动配置通信节点的地址或其他属性信息，因为它们在运行过程中会自动发现对方并自动完成相关配置，实现了即插即用的功能。</p>
<h3 id="可扩展架构（Scalable-Architecture）"><a href="#可扩展架构（Scalable-Architecture）" class="headerlink" title="可扩展架构（Scalable Architecture）"></a>可扩展架构（Scalable Architecture）</h3><p>DDS可应用于边缘计算、云计算领域。在边缘计算中，DDS可以实现高速实时的设备间通信。在中间系统中，DDS提供健壮可靠的QoS和内容感知的信息流。DDS提供可扩展的信息访问和数据分发手段，用于集成信息系统，将各系统接入云端。<br>OMG DDS的适用范围广泛，涵盖了从小型设备到云计算系统等超大型系统。DDS能够以超高速传输数据并同时管理数千个数据对象，提供极高的可用性和安全性，非常适用于物联网。通过提供一个标准的通信层，DDS屏蔽了底层复杂性，简化了分布式系统的开发。</p>
<h3 id="安全（Security）"><a href="#安全（Security）" class="headerlink" title="安全（Security）"></a>安全（Security）</h3><p>DDS为关键任务的工业物联网环境提供了全面的安全保护机制，跨系统、跨供应商，覆盖从边缘设备到云端的安全性需求。<br>DDS提供了身份验证、访问控制、数据加密和数据完整性等安全机制，以确保数据分发的安全性。这些安全机制是在点对点对等架构上实现的，不会影响实时通信的性能。</p>
<h2 id="DDS与SOME-x2F-IP区别"><a href="#DDS与SOME-x2F-IP区别" class="headerlink" title="DDS与SOME&#x2F;IP区别"></a>DDS与SOME&#x2F;IP区别</h2><p>SOME&#x2F;IP和DDS是目前在域控最常用的两类通信中间件，它们都是面向服务的通信协议，并采用以数据为中心的发布&#x2F;订阅模式。<br>然而，SOME&#x2F;IP和DDS在许多方面也存在差异，主要区别如下：</p>
<h3 id="主要应用领域不同"><a href="#主要应用领域不同" class="headerlink" title="主要应用领域不同"></a>主要应用领域不同</h3><p>SOME&#x2F;IP专为汽车领域开发，针对汽车领域的需求定义了一套通信标准，并在汽车领域深耕已久；而DDS是一个工业级别的强实时通信标准，适应性较强，但在应用于汽车领域时需要进行专门的裁剪。</p>
<h3 id="灵活性和可伸缩性不同"><a href="#灵活性和可伸缩性不同" class="headerlink" title="灵活性和可伸缩性不同"></a>灵活性和可伸缩性不同</h3><p>相比SOME&#x2F;IP，DDS引入了许多标准内置特性，如基于内容和时间的过滤、与传输无关的可靠性、持久性、存活性、延迟&#x2F;截止时间监视、可扩展类型等。当AUTOSAR AP与DDS一起构建通信框架时，该框架不仅与现有API和应用程序兼容，还在可靠性、性能、灵活性和可伸缩性等方面提供重要的好处。</p>
<h3 id="订阅方和发布方的耦合程度不同-⭐"><a href="#订阅方和发布方的耦合程度不同-⭐" class="headerlink" title="订阅方和发布方的耦合程度不同 ⭐"></a>订阅方和发布方的耦合程度不同 ⭐</h3><p>在SOME&#x2F;IP中，订阅方在正常数据传输之前需要与发布方建立网络连接并询问发布方是否提供所需服务，即Service Discovery，从这个角度看，节点之间仍然存在一定的耦合性。而在DDS标准下每个订阅方或发布方只需要在自己的程序中订阅或发布数据，无需关心任何连接。因此，在DDS中，服务的订阅方和发布方更加彻底地解耦。</p>
<h3 id="服务策略不同"><a href="#服务策略不同" class="headerlink" title="服务策略不同"></a>服务策略不同</h3><p>良好的服务质量（QoS）是DDS标准相对于SOME&#x2F;IP最重要的特征。SOME&#x2F;IP只有一个QoS，而RTI DDS和开源DDS分别提供了50多个和20多个QoS，这些QoS基本上涵盖了大多数可预见的业务场景。</p>
<h3 id="应用场景不同"><a href="#应用场景不同" class="headerlink" title="应用场景不同"></a>应用场景不同</h3><p>从应用场景的角度来看，SOME&#x2F;IP更适用于车载网络，并且只能在基于IP类型的网络环境中使用；而DDS在传输方式上没有特别的限制，可以支持基于非IP类型的网络，例如共享内存、跨核通信、PCIe等。此外，DDS还提供了完备的车联网解决方案，其独有的DDS Security和DDS Web功能为用户提供一站式的“车-云-移动端”解决方案。</p>
<h2 id="方案对比"><a href="#方案对比" class="headerlink" title="方案对比"></a>方案对比</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><h4 id="商业方案"><a href="#商业方案" class="headerlink" title="商业方案"></a>商业方案</h4><ol>
<li><p><a href="https://www.rti.com/en/">RTI - Connext DDS</a><br>RTI作为OMG组织董事会的成员，领导了DDS标准的制定，并开发了名为Connext的DDS品牌，因此也被称为Connext DDS，是业界领先的DDS供应商。</p>
</li>
<li><p><a href="http://www.twinoakscomputing.com/">Twin Oaks Computing, Inc. - CoreDX DDS</a><br>Twin Oaks Computing, Inc. 是一家致力于开发和提供优质软件解决方案的公司，其开发的CoreDX DDS是领先的DDS中间件，主要特点是体积小，速度快，适用于小型和嵌入式系统。</p>
</li>
<li><p><a href="http://www.remedy.nl/">Remedy IT</a><br>Remedy IT是一家致力于开放标准的技术服务&#x2F;咨询&#x2F;培训公司，为航空航天、国防、金融、电信和能源等不同领域的各种组织提供DDS软件解决方案和支持。</p>
</li>
</ol>
<h4 id="开源方案"><a href="#开源方案" class="headerlink" title="开源方案"></a>开源方案</h4><p>开源DDS相对于商用的RTI Connext DDS等来说，也是根据OMG官方标准开发的，但源代码是开放的，主要包括Fast DDS和Open DDS等。</p>
<ol>
<li><p><a href="http://www.eprosima.com/">eProsima Fast DDS</a><br>在自动驾驶领域，由RTI原核心团队成员在欧洲创办的eProsima公司推出了影响力较大的开源DDS，名为Fast DDS。在eProsima将Fast DDS的源代码开放后，用户可以直接在GitHub上免费下载使用。</p>
</li>
<li><p><a href="https://objectcomputing.com/products/opendds">Object Computing OpenDDS</a><br>Open DDS由位于圣路易斯和凤凰城的Object Computing的ACE&#x2F;TAO团队开发，与Fast DDS有一定的相似性，两者都基于RTPS实现，都是面向数据的通信框架，并遵循同一标准。<br>上述两类开源方案都支持去中心化、支持QoS机制和实时通信等DDS标准。</p>
</li>
</ol>
<p>尽管开源DDS对RTI的商用DDS形成一定的竞争，但开源DDS也存在一些不足之处：开源DDS的使用门槛较高，使用起来没有商业方案方便；开源DDS服务策略完整性远不及商业版本，RTI DDS的服务策略有50多个，而开源DDS只有23个；RTI的DDS已通过了ASIL-D认证，而开源DDS尚未达到这一认证水平。 </p>
<table>
<thead>
<tr>
<th></th>
<th>Rti Connext DDS</th>
<th>Fast DDS</th>
</tr>
</thead>
<tbody><tr>
<td>供应商</td>
<td>Real-Time Innovations</td>
<td>eProsima</td>
</tr>
<tr>
<td>开源与否</td>
<td>不开源，需要购买商业许可</td>
<td>开源</td>
</tr>
<tr>
<td>性能</td>
<td>在数据吞吐量和延迟方面更优</td>
<td>在内存使用和CPU使用方面更优</td>
</tr>
<tr>
<td>特性</td>
<td>提供了一些高级特性，如数据查询和持久化</td>
<td>支持更多的平台和操作系统</td>
</tr>
<tr>
<td>平台支持</td>
<td>RTI Connext DDS 支持平台</td>
<td>Fast DDS 支持平台</td>
</tr>
<tr>
<td>社区支持</td>
<td>庞大的用户社区和丰富的文档</td>
<td>较弱</td>
</tr>
<tr>
<td>安全性</td>
<td>高，通过了ASIL-D认证</td>
<td>较弱</td>
</tr>
<tr>
<td>Qos服务策略</td>
<td>多，50+</td>
<td>较少，20+</td>
</tr>
<tr>
<td>使用门槛</td>
<td>使用门槛较低，接口、编译均可自动化处理</td>
<td>使用门槛较高，接口封装、编译等均须手动配置</td>
</tr>
<tr>
<td>便捷性</td>
<td>提供丰富的工具和服务，使用较为便捷</td>
<td>内置工具和服务较少，使用便捷性较弱</td>
</tr>
</tbody></table>
<h3 id="RTI-CONNXT-DDS"><a href="#RTI-CONNXT-DDS" class="headerlink" title="RTI CONNXT DDS"></a>RTI CONNXT DDS</h3><h4 id="官方链接"><a href="#官方链接" class="headerlink" title="官方链接"></a>官方链接</h4><ul>
<li>官方网站：<a href="https://www.rti.com/">https://www.rti.com/</a></li>
<li>开发文档：<a href="https://community.rti.com/documentation/rti-connext-720">https://community.rti.com/documentation/rti-connext-720</a></li>
<li>最佳实践：<a href="https://github.com/rticommunity/rticonnextdds-examples/tree/master/examples/connext_dds">Examples</a></li>
<li>版本下载：<a href="https://s3.amazonaws.com/RTI/Bundles/7.2.0/Evaluation/rti_connext_dds-7.2.0-lm-x64Linux4gcc7.3.0.run">RTI Connext DDS 7.2.0</a></li>
</ul>
<h4 id="核心接口"><a href="#核心接口" class="headerlink" title="核心接口"></a>核心接口</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Start communicating in a domain, usually one participant per application</span></span><br><span class="line">dds::<span class="function">domain::DomainParticipant <span class="title">participant</span><span class="params">(domain_id)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a Topic with a name and a datatype</span></span><br><span class="line">dds::<span class="function">topic::Topic&lt; ::OTACtrl_struct&gt; <span class="title">topic</span><span class="params">(participant, <span class="string">&quot;Example OTACtrl_struct&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a Publisher</span></span><br><span class="line">dds::<span class="function">pub::Publisher <span class="title">publisher</span><span class="params">(participant)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a DataWriter with default QoS</span></span><br><span class="line">dds::<span class="function">pub::DataWriter&lt; ::OTACtrl_struct&gt; <span class="title">writer</span><span class="params">(publisher, topic)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// Set the values</span></span><br><span class="line">::OTACtrl_struct data;</span><br><span class="line">data.<span class="built_in">ota_hmi_req</span>(OTA_HMI_Req::SetAppointmentTime);</span><br><span class="line">data.<span class="built_in">appointment_time</span>(std::<span class="built_in">to_string</span>(<span class="number">1704962170593</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// write data</span></span><br><span class="line">writer.<span class="built_in">write</span>(data);</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Start communicating in a domain, usually one participant per application</span></span><br><span class="line">dds::<span class="function">domain::DomainParticipant <span class="title">participant</span><span class="params">(domain_id)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a Topic with a name and a datatype</span></span><br><span class="line">dds::<span class="function">topic::Topic&lt; ::OTACtrl_struct&gt; <span class="title">topic</span><span class="params">(participant, <span class="string">&quot;Example OTACtrl_struct&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a Subscriber and DataReader with default Qos</span></span><br><span class="line">dds::<span class="function">sub::Subscriber <span class="title">subscriber</span><span class="params">(participant)</span></span>;</span><br><span class="line">dds::<span class="function">sub::DataReader&lt; ::OTACtrl_struct&gt; <span class="title">reader</span><span class="params">(subscriber, topic)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a ReadCondition for any data received on this reader and set a</span></span><br><span class="line"><span class="comment">// handler to process the data</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> samples_read = <span class="number">0</span>;</span><br><span class="line">dds::sub::<span class="function">cond::ReadCondition <span class="title">read_condition</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    reader,</span></span></span><br><span class="line"><span class="params"><span class="function">    dds::sub::status::DataState::any(),</span></span></span><br><span class="line"><span class="params"><span class="function">    [reader, &amp;samples_read]() &#123; samples_read += process_data(reader); &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// WaitSet will be woken when the attached condition is triggered</span></span><br><span class="line">dds::core::cond::WaitSet waitset;</span><br><span class="line">waitset += read_condition;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!application::shutdown_requested &amp;&amp; samples_read &lt; sample_count) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;::OTACtrl_struct subscriber sleeping up to 1 sec...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Run the handlers of the active conditions. Wait for up to 1 second.</span></span><br><span class="line">    waitset.<span class="built_in">dispatch</span>(dds::core::<span class="built_in">Duration</span>(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="内置工具"><a href="#内置工具" class="headerlink" title="内置工具"></a>内置工具</h4><ul>
<li><code>rtiadminconsole</code>: 用于监视分析和配置正在运行的DDS系统的工具。</li>
<li><code>rticlouddiscoveryservice</code>: 用于在云环境中发现DDS服务的工具。</li>
<li><code>rticonverter</code>: 用于转换DDS数据的工具。</li>
<li><code>rtiddsgen</code>: 用于从IDL文件生成DDS数据类型的工具。</li>
<li><code>rtiddsgen_server</code>: rtiddsgen的服务器版本。</li>
<li><code>rtiddsping</code>: 用于测试DDS网络连接的工具。</li>
<li><code>rtiddsspy</code>: 用于监听DDS网络上的数据的工具。</li>
<li><code>rtilauncher</code>: 一个图形界面工具，用于启动其他RTI工具。</li>
<li><code>rtimonitor</code>: 用于监视DDS系统的工具。</li>
<li><code>rtipersistenceservice</code>: 用于在DDS系统中提供数据持久化的服务。</li>
<li><code>rtipkginstall</code>: 用于安装RTI软件包的工具。</li>
<li><code>rtipssh</code>: 用于在DDS系统中提供安全的shell服务。</li>
<li><code>rtirecordingindexer</code>: 用于索引DDS数据记录的工具。</li>
<li><code>rtirecordingservice</code>: 用于记录DDS数据的服务。</li>
<li><code>rtirecordingservice_list_tags</code>: 用于列出DDS数据记录标签的工具。</li>
<li><code>rtireplayservice</code>: 用于回放DDS数据记录的服务。</li>
<li><code>rtiroutingservice</code>: 用于在DDS系统中提供数据路由的服务。</li>
<li><code>rtirssh</code>: 用于在DDS系统中提供安全的远程shell服务。</li>
<li><code>rtishapesdemo</code>: 一个用于演示DDS功能的图形界面工具。</li>
<li><code>rtisystemdesigner</code>: 一个用于设计DDS系统的图形界面工具。</li>
<li><code>rtiwebintegrationservice</code>: 用于将DDS数据集成到Web应用的服务。</li>
<li><code>rtixmlconverter</code>: 用于转换DDS XML配置文件的工具。</li>
</ul>
<h4 id="支持平台"><a href="#支持平台" class="headerlink" title="支持平台"></a>支持平台</h4><p><a href="https://github.com/eProsima/Fast-DDS/blob/master/PLATFORM_SUPPORT.md#platform-support">Platform Support</a></p>
<h3 id="eProsima-Fast-DDS"><a href="#eProsima-Fast-DDS" class="headerlink" title="eProsima Fast DDS"></a>eProsima Fast DDS</h3><h4 id="官方链接-1"><a href="#官方链接-1" class="headerlink" title="官方链接"></a>官方链接</h4><ul>
<li>官方网站：<a href="https://www.eprosima.com/index.php/products-all/eprosima-fast-dds">https://www.eprosima.com/index.php/products-all/eprosima-fast-dds</a></li>
<li>开发文档：<a href="https://github.com/eProsima/Fast-DDS-docs">https://github.com/eProsima/Fast-DDS-docs</a></li>
<li>源码仓库：<a href="https://github.com/eProsima/Fast-DDS">https://github.com/eProsima/Fast-DDS</a></li>
<li>版本下载：<a href="https://www.eprosima.com/index.php/component/ars/repository/eprosima-fast-dds/eprosima-fast-dds-2-13-0">eProsima Fast DDS 2.13.0</a></li>
</ul>
<h4 id="核心接口-1"><a href="#核心接口-1" class="headerlink" title="核心接口"></a>核心接口</h4><blockquote>
<p><strong>DomainParticipant</strong>：充当所有其他实体对象的容器，并充当发布者、订阅者和主题对象的工厂。<br><strong>Publisher</strong>：是负责创建 DataWriter的对象。<br><strong>DataWriter</strong>：允许应用程序设置要在给定主题下发布的数据的值。<br><strong>TypeSupport</strong>：为participant提供序列化、反序列化和获取特定数据类型的key的函数。<br><strong>DataWriterListener</strong>：允许重新定义 DataWriterListener 的功能。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建participant</span></span><br><span class="line">DomainParticipantQos participantQos;</span><br><span class="line">participantQos.<span class="built_in">name</span>(<span class="string">&quot;Participant_publisher&quot;</span>);</span><br><span class="line">participant_ = DomainParticipantFactory::<span class="built_in">get_instance</span>()-&gt;<span class="built_in">create_participant</span>(<span class="number">0</span>, participantQos);</span><br><span class="line"></span><br><span class="line"><span class="comment">// register数据类型并创建topic</span></span><br><span class="line">type_ = <span class="keyword">new</span> <span class="built_in">HelloWorldPubSubType</span>()</span><br><span class="line">type_.<span class="built_in">register_type</span>(participant_);</span><br><span class="line">topic_ = participant_-&gt;<span class="built_in">create_topic</span>(<span class="string">&quot;HelloWorldTopicName&quot;</span>, <span class="string">&quot;HelloWorld&quot;</span>, TOPIC_QOS_DEFAULT);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建publisher</span></span><br><span class="line">publisher_ = participant_-&gt;<span class="built_in">create_publisher</span>(PUBLISHER_QOS_DEFAULT, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建writer</span></span><br><span class="line">writer_ = publisher_-&gt;<span class="built_in">create_datawriter</span>(topic_, DATAWRITER_QOS_DEFAULT, &amp;listener_);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Publisher对象发送数据</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">publish</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    hello_.<span class="built_in">index</span>(hello_.<span class="built_in">index</span>() + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (writer_-&gt;<span class="built_in">write</span>(&amp;hello_))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>DomainParticipant</strong>：充当所有其他实体对象的容器，并充当发布者、订阅者和主题对象的工厂。<br><strong>Subscriber</strong>：是负责创建 DataReader 的对象。<br><strong>DataReader</strong>：它是负责实际接收数据的对象。<br><strong>TypeSupport</strong>：为participant提供序列化、反序列化和获取特定数据类型的key的函数。<br><strong>DataReaderListener</strong>：这是分配给数据读取器的侦听器。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建participant</span></span><br><span class="line">DomainParticipantQos participantQos;</span><br><span class="line">participantQos.<span class="built_in">name</span>(<span class="string">&quot;Participant_subscriber&quot;</span>);</span><br><span class="line">participant_ = DomainParticipantFactory::<span class="built_in">get_instance</span>()-&gt;<span class="built_in">create_participant</span>(<span class="number">0</span>, participantQos);</span><br><span class="line"></span><br><span class="line"><span class="comment">// register数据类型并创建topic</span></span><br><span class="line">type_ = <span class="keyword">new</span> <span class="built_in">HelloWorldPubSubType</span>()</span><br><span class="line">type_.<span class="built_in">register_type</span>(participant_);</span><br><span class="line">topic_ = participant_-&gt;<span class="built_in">create_topic</span>(<span class="string">&quot;HelloWorldTopicName&quot;</span>, <span class="string">&quot;HelloWorld&quot;</span>, TOPIC_QOS_DEFAULT);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建subscriber</span></span><br><span class="line">subscriber_ = participant_-&gt;<span class="built_in">create_subscriber</span>(SUBSCRIBER_QOS_DEFAULT, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建reader</span></span><br><span class="line">reader_ = subscriber_-&gt;<span class="built_in">create_datareader</span>(topic_, DATAREADER_QOS_DEFAULT, &amp;listener_);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Subscriber对象接收数据</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">on_data_available</span><span class="params">(DataReader* reader)</span> <span class="keyword">override</span> <span class="comment">//当datareader接收到datawriter发送的新数据时，会触发该回调函数。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SampleInfo info;</span><br><span class="line">    <span class="keyword">if</span> (reader-&gt;<span class="built_in">take_next_sample</span>(&amp;hello_, &amp;info) == ReturnCode_t::RETCODE_OK)&#123;</span><br><span class="line">        <span class="keyword">if</span> (info.valid_data)&#123;</span><br><span class="line">            samples_++;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Message: &quot;</span> &lt;&lt; hello_.<span class="built_in">message</span>() &lt;&lt; <span class="string">&quot; with index: &quot;</span> &lt;&lt; hello_.<span class="built_in">index</span>()&lt;&lt; <span class="string">&quot; RECEIVED.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="支持平台-1"><a href="#支持平台-1" class="headerlink" title="支持平台"></a>支持平台</h4><p><a href="https://community.rti.com/static/documentation/connext-dds/6.1.1/doc/manuals/connext_dds_professional/release_notes/index.htm#release_notes/Supported_Operating_Systems.htm">Supported Platform</a></p>
<h2 id="术语定义"><a href="#术语定义" class="headerlink" title="术语定义"></a>术语定义</h2><table>
<thead>
<tr>
<th>术语</th>
<th>定义</th>
</tr>
</thead>
<tbody><tr>
<td>DDS</td>
<td>Data Distribution Service，数据分发服务，提供了一种数据中心的通信方式，提供丰富的服务质量策略，允许数据的发布者和订阅者在时间和空间上解耦，从而保障数据进行实时且高效的分发。</td>
</tr>
<tr>
<td>ROS2</td>
<td>Robot Operating System 2，是一个用于编写机器人软件的框架，ROS 2选择了DDS作为其底层的消息传递中间件，这意味着ROS 2的节点（即ROS中的进程）均使用DDS来发布或订阅主题，以及进行服务调用。</td>
</tr>
<tr>
<td>OMG</td>
<td>Object Management Group，对象管理组织，是一个国际性的、开放的、非盈利的标准化组织，致力于建立对程序、系统和业务流程的建模标准，它制定了DDS的中间件协议和API标准。</td>
</tr>
<tr>
<td>AUTOSAR</td>
<td>Automotive Open System Architecture，是一个全球的汽车工业联盟，它定义了一个开放的、标准的汽车软件架构。AUTOSAR规范自R22-11开始引入了DDS内容，去年发布的R23-11标准对于DDS有更加具体的描述，能够作为模块开发的一个参考。</td>
</tr>
<tr>
<td>QoS</td>
<td>Quality of Service，是一个广泛用于网络通信中的概念，用于描述网络的性能水平，包括数据传输的错误率、带宽、延迟、抖动等。</td>
</tr>
</tbody></table>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://mp.weixin.qq.com/s/7c9dWrR1kCHn6F5Oan9eaA">SOA通信中间件常用的通信协议</a></li>
<li><a href="https://mp.weixin.qq.com/s/AazoBThS9xBi9KdBTeU3AQ">初识AUTOSAR CP平台下的DDS规范</a></li>
</ul>
]]></content>
      <categories>
        <category>Works</category>
      </categories>
  </entry>
  <entry>
    <title>动态规划</title>
    <url>/blog/dynamic-programming/</url>
    <content><![CDATA[<div class="note info">

<ul>
<li>动态规划是一种常用的优化算法的技术，是一种解决最优解问题的方法。</li>
<li>由于动态规划并不是某种具体的算法，而是一种解决特定问题的方法，因此它会出现在各式各样的数据结构中，与之相关的题目种类也更为繁杂。</li>
<li>这篇文章主要介绍DP的一些基本思想，各种类型问题中DP数组的建立方法，以及一些DP的优化技巧。</li>
</ul>
</div>

<span id="more"></span>

<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul>
<li><a href="https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92">动态规划(dynamic programming)</a>是运筹学的一个分支，是求解决策过程最优化的数学方法。</li>
<li>能用动态规划解决的问题，需要满足三个条件：最优子结构，无后效性和子问题重叠。<ul>
<li>一个问题的最优解包含其子问题的最优解，这个性质被称为<strong>最优子结构性质</strong>。</li>
<li>递归算法求解问题时，每次产生的子问题并不总是新问题，有些子问题被反复计算多次(overlap problem)。这种性质称为<strong>子问题的重叠性质</strong>。</li>
<li>已经求解的子问题，不会再受到后续决策的影响，这个性质被称为<strong>无后效性行性质</strong>。</li>
</ul>
</li>
<li>满足下面三个条件之一, 则极有可能是使用动态规划求解的：<ul>
<li>求最大值最小值</li>
<li>判断是否可行</li>
<li>统计方案个数</li>
</ul>
</li>
</ul>
<h2 id="关于动态规划的学习资源"><a href="#关于动态规划的学习资源" class="headerlink" title="关于动态规划的学习资源"></a>关于动态规划的学习资源</h2><ul>
<li>入门推荐灯神的<a href="https://youtu.be/1BAsAgdx7Ac">DP入门视频</a>，讲解十分通俗易懂，我阿嫲一听就会。</li>
<li>dd大佬的<a href="http://cuitianyi.com/Pack/">《背包九讲》</a>，是一个非常好的学习背包相关动态规划的资料，几乎涵盖了背包问题的所有内容。</li>
<li>labuladong 的算法笔记之<a href="https://labuladong.gitee.io/algo/di-er-zhan-a01c6/dong-tai-g-a223e/dong-tai-g-1e688/">动态规划解题套路框架</a>。</li>
<li>概念学会就可以开启实战了<a href="https://www.bilibili.com/video/BV1aa411f7uT/">动态规划入门50题</a>，<a href="https://leetcode.cn/studyplan/dynamic-programming/">LeetCode Study Plan</a>等。</li>
</ul>
<h2 id="动态规划解题五步曲"><a href="#动态规划解题五步曲" class="headerlink" title="动态规划解题五步曲"></a>动态规划解题五步曲</h2><ul>
<li>确定dp数组以及下标的含义</li>
<li>确定递推公式</li>
<li>dp数组如何初始化</li>
<li>确定遍历顺序</li>
<li>举例推导dp数组</li>
</ul>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>ECNU Dase Postgraduate Entrance Examination</title>
    <url>/blog/ecnu-dase-postgraduate-entrance-exam-contest/</url>
    <content><![CDATA[<div class="note info">

<ul>
<li>华东师范大学 数据科学与工程学院 2022年复试上机题分析:<ul>
<li>最大池化考察了二维数组的操作，滑动窗口，最大值查找等算法，同时需要对深度学习中池化概念有一定的了解。</li>
<li>去商场是一个典型的图搜索问题，可以使用BFS来解决。</li>
<li>表情拦截主要考察了二分搜索相关的知识点以及基本的C++的语法和特性。</li>
<li>其余题目基本都是对题目本身的理解和特定的业务逻辑的处理。</li>
</ul>
</li>
</ul>
</div>

<span id="more"></span>

<h1 id="2022"><a href="#2022" class="headerlink" title="2022"></a>2022</h1><h2 id="题目总览"><a href="#题目总览" class="headerlink" title="题目总览"></a>题目总览</h2><ul>
<li>OJ传送门: <a href="http://106.75.253.228/contest/64/problems">http://106.75.253.228/contest/64/problems</a></li>
<li>Problem Lists：<br><img src="https://s2.loli.net/2022/04/06/B1QUaoJgTWvZEKs.png" alt="image.png"></li>
</ul>
<h3 id="A-最大池化"><a href="#A-最大池化" class="headerlink" title="A 最大池化"></a>A 最大池化</h3><p><img src="https://s2.loli.net/2022/04/06/TznylKsgtvJiP1H.jpg" alt="A.jpeg"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> kx, ky, dx, dy;</span><br><span class="line"><span class="type">int</span> matrix[<span class="number">200</span>][<span class="number">200</span>];</span><br><span class="line"><span class="type">int</span> ans_matrix[<span class="number">200</span>][<span class="number">200</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InputMatrix</span><span class="params">()</span></span>&#123; <span class="comment">//输入原来的矩阵</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; dx; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; dy; j++)&#123;</span><br><span class="line">            cin &gt;&gt; matrix[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MaxPooling</span><span class="params">()</span></span>&#123;    <span class="comment">//最大池化操作</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> row = <span class="number">0</span>; row &lt;= dx-kx; row++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> col = <span class="number">0</span>; col &lt;= dy-ky; col++)&#123;</span><br><span class="line">            <span class="type">int</span> max_num = INT_MIN;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = row; i &lt; row+kx; i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = col; j &lt; col+ky; j++)&#123;</span><br><span class="line">                    max_num = <span class="built_in">max</span>(max_num, matrix[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans_matrix[row][col] = max_num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OutputMatrix</span><span class="params">()</span></span>&#123; <span class="comment">//输出池化后的矩阵</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= dx-kx; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= dy-ky; j++)&#123;</span><br><span class="line">            cout &lt;&lt; ans_matrix[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; kx &gt;&gt; ky &gt;&gt; dx &gt;&gt; dy;</span><br><span class="line">    <span class="built_in">InputMatrix</span>();</span><br><span class="line">    <span class="built_in">MaxPooling</span>();</span><br><span class="line">    <span class="built_in">OutputMatrix</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="B-去商场"><a href="#B-去商场" class="headerlink" title="B 去商场"></a>B 去商场</h3><p><img src="https://s2.loli.net/2022/04/06/LQoKcAgPD9lhTUi.jpg" alt="B.jpeg"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使用BFS从小明家开始搜索，每次尝试向上下左右四个方向移动，如果遇到障碍或者已经访问过的格子就跳过，如果遇到商店就停止搜索。最后输出从小明家到商店的最短步长，如果无法到达商店就输出-1。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> N, M, x;</span><br><span class="line"><span class="type">char</span> grid[MAXN][MAXN];</span><br><span class="line"><span class="type">bool</span> visited[MAXN][MAXN];</span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; start, end;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">BFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    queue&lt;pair&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, <span class="type">int</span>&gt;&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;start, <span class="number">0</span>&#125;);</span><br><span class="line">    visited[start.first][start.second] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> cur = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(cur.first == end) <span class="keyword">return</span> cur.second;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> nx = cur.first.first + dx[i], ny = cur.first.second + dy[i];</span><br><span class="line">            <span class="keyword">if</span>(nx &lt; <span class="number">0</span> || nx &gt;= N || ny &lt; <span class="number">0</span> || ny &gt;= M || visited[nx][ny]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(grid[nx][ny] == <span class="string">&#x27;#&#x27;</span> || (grid[nx][ny] == <span class="string">&#x27;%&#x27;</span> &amp;&amp; x == <span class="number">0</span>)) <span class="keyword">continue</span>;</span><br><span class="line">            visited[nx][ny] = <span class="literal">true</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(&#123;&#123;nx, ny&#125;, cur.second + <span class="number">1</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; x &gt;&gt; N &gt;&gt; M;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; M; j++) &#123;</span><br><span class="line">            cin &gt;&gt; grid[i][j];</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j] == <span class="string">&#x27;s&#x27;</span>) start = &#123;i, j&#125;;</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j] == <span class="string">&#x27;e&#x27;</span>) end = &#123;i, j&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">BFS</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="D-数组变换"><a href="#D-数组变换" class="headerlink" title="D 数组变换"></a>D 数组变换</h3><p><img src="https://s2.loli.net/2022/04/06/Hsyarh3Z1WAOeQu.jpg" alt="D.jpeg"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> nums[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Function</span><span class="params">()</span></span>&#123;    <span class="comment">//判断是否可以通过任意次操作，使数组变为不严格的升序数组</span></span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &gt; nums[i+<span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">if</span>((nums[i] % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; nums[i + <span class="number">1</span>] % <span class="number">2</span> != <span class="number">0</span>) || (nums[i] % <span class="number">2</span> != <span class="number">0</span> &amp;&amp; nums[i + <span class="number">1</span>] % <span class="number">2</span> == <span class="number">0</span>))&#123;</span><br><span class="line">                <span class="type">long</span> <span class="type">long</span> temp = nums[i];</span><br><span class="line">                nums[i] = nums[i + <span class="number">1</span>];</span><br><span class="line">                nums[i + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &gt; nums[i+<span class="number">1</span>])&#123;</span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag == <span class="number">1</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Function</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="E-表情拦截"><a href="#E-表情拦截" class="headerlink" title="E 表情拦截"></a>E 表情拦截</h3><p><img src="https://s2.loli.net/2022/04/06/BPGIrdF3h7Vivjn.jpg" alt="E.jpeg"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line">ll k, x;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; k &gt;&gt; x;</span><br><span class="line">    ll sum = k * (k + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= sum) &#123;</span><br><span class="line">        ll l = <span class="number">1</span>, r = k;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">            ll mid = (l + r + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(mid * (mid + <span class="number">1</span>) / <span class="number">2</span> &lt;= x) l = mid;</span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; l &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ll rest = x - sum;</span><br><span class="line">        ll rows = rest / k;</span><br><span class="line">        <span class="keyword">if</span>(rest % k != <span class="number">0</span>) rows++;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">min</span>(<span class="number">2</span> * k - <span class="number">1</span>, k + rows) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="F-拍照队形"><a href="#F-拍照队形" class="headerlink" title="F 拍照队形"></a>F 拍照队形</h3><p><img src="https://s2.loli.net/2022/04/06/2ohHVx61MqywYtG.jpg" alt="F.jpeg"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">string str;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isBeautiful</span><span class="params">(<span class="type">int</span> number_of_0, <span class="type">int</span> number_of_1)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((number_of_0 - <span class="number">1</span>) * <span class="number">2</span> == number_of_1)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Function</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> number_of_0 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> number_of_1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(str[i] == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">            number_of_0++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(str[i] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">            number_of_1++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//先判断是否是美观的</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isBeautiful</span>(number_of_0, number_of_1))&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;nobeautiful&quot;;</span></span><br><span class="line">        <span class="type">int</span> need = <span class="number">0</span>;</span><br><span class="line">        need = (number_of_0 - <span class="number">1</span>)*<span class="number">2</span> - number_of_1;</span><br><span class="line">        cout &lt;&lt; need;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    cin &gt;&gt; str;</span><br><span class="line">    <span class="built_in">Function</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="G-树上异或和"><a href="#G-树上异或和" class="headerlink" title="G 树上异或和"></a>G 树上异或和</h3><p><img src="https://s2.loli.net/2022/04/06/CTWxmpcEjJPA2sw.jpg" alt="G.jpeg"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">105</span>;</span><br><span class="line"><span class="type">int</span> pre[maxn], in[maxn], post[maxn], lch[maxn], rch[maxn], val[maxn], n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">build</span><span class="params">(<span class="type">int</span> L1, <span class="type">int</span> R1, <span class="type">int</span> L2, <span class="type">int</span> R2, <span class="type">int</span> dep)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L1 &gt; R1) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> root = pre[L1];</span><br><span class="line">    <span class="type">int</span> p = L2;</span><br><span class="line">    <span class="keyword">while</span>(in[p] != root) p++;</span><br><span class="line">    <span class="type">int</span> cnt = p - L2;</span><br><span class="line">    lch[root] = <span class="built_in">build</span>(L1 + <span class="number">1</span>, L1 + cnt, L2, p - <span class="number">1</span>, dep + <span class="number">1</span>);</span><br><span class="line">    rch[root] = <span class="built_in">build</span>(L1 + cnt + <span class="number">1</span>, R1, p + <span class="number">1</span>, R2, dep + <span class="number">1</span>);</span><br><span class="line">    val[root] = dep;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!u) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(!lch[u] &amp;&amp; !rch[u]) <span class="keyword">return</span> val[u];</span><br><span class="line">    <span class="keyword">if</span>(lch[u] &amp;&amp; rch[u]) <span class="keyword">return</span> <span class="built_in">dfs</span>(lch[u]) ^ <span class="built_in">dfs</span>(rch[u]);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(lch[u] ? lch[u] : rch[u]) * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; pre[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; in[i];</span><br><span class="line">    <span class="type">int</span> root = <span class="built_in">build</span>(<span class="number">1</span>, n, <span class="number">1</span>, n, <span class="number">0</span>);</span><br><span class="line">    cout &lt;&lt; <span class="built_in">dfs</span>(root) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="2021"><a href="#2021" class="headerlink" title="2021"></a>2021</h1><h2 id="题目总览-1"><a href="#题目总览-1" class="headerlink" title="题目总览"></a>题目总览</h2><ul>
<li>OJ传送门：<a href="http://47.100.233.213/">http://47.100.233.213/</a></li>
</ul>
<h3 id="ID-1-卷积"><a href="#ID-1-卷积" class="headerlink" title="ID.1 卷积"></a>ID.1 卷积</h3><p><img src="https://s2.loli.net/2022/02/08/XesSvDAiFNqjltn.png" alt="1卷积.png"></p>
<h3 id="ID-2-因数之和"><a href="#ID-2-因数之和" class="headerlink" title="ID.2 因数之和"></a>ID.2 因数之和</h3><p><img src="https://s2.loli.net/2022/02/08/KHlX14coWxzfCJr.png" alt="2因数之和.png"></p>
<h3 id="ID-3-原型蛋糕"><a href="#ID-3-原型蛋糕" class="headerlink" title="ID.3 原型蛋糕"></a>ID.3 原型蛋糕</h3><p><img src="https://s2.loli.net/2022/02/08/MkSlDUdo6hiXNc8.png" alt="3圆形蛋糕.png"></p>
<h3 id="ID-4-选课"><a href="#ID-4-选课" class="headerlink" title="ID.4 选课"></a>ID.4 选课</h3><p><img src="https://s2.loli.net/2022/02/08/3SjeIdPiswtGfkL.png" alt="4选课.png"></p>
<h3 id="ID-5-子树"><a href="#ID-5-子树" class="headerlink" title="ID.5 子树"></a>ID.5 子树</h3><p><img src="https://s2.loli.net/2022/02/08/RQPuFHJkzN3qYMv.png" alt="5子树.png"></p>
<h1 id="2019"><a href="#2019" class="headerlink" title="2019"></a>2019</h1><h2 id="题目总览-2"><a href="#题目总览-2" class="headerlink" title="题目总览"></a>题目总览</h2><ul>
<li>OJ传送门：<a href="http://47.100.233.213/">http://47.100.233.213/</a></li>
</ul>
<h3 id="A-数字排序"><a href="#A-数字排序" class="headerlink" title="A 数字排序"></a>A 数字排序</h3><p><img src="https://s2.loli.net/2022/02/08/SCpNkEhfPb8Hlr4.png" alt="A.png"></p>
<h3 id="B-找零钱"><a href="#B-找零钱" class="headerlink" title="B 找零钱"></a>B 找零钱</h3><p><img src="https://s2.loli.net/2022/02/08/GltYcFi8WuHTMpj.png" alt="B.png"></p>
<h3 id="C-斐波那契数列"><a href="#C-斐波那契数列" class="headerlink" title="C 斐波那契数列"></a>C 斐波那契数列</h3><p><img src="https://s2.loli.net/2022/02/08/Wk1g4dwOADfpc7j.png" alt="C.png"></p>
<h3 id="D-字符串拼接"><a href="#D-字符串拼接" class="headerlink" title="D 字符串拼接"></a>D 字符串拼接</h3><p><img src="https://s2.loli.net/2022/02/08/ktYylbqEP3FVfom.png" alt="D.png"></p>
<h3 id="E-矩阵求和"><a href="#E-矩阵求和" class="headerlink" title="E 矩阵求和"></a>E 矩阵求和</h3><p><img src="https://s2.loli.net/2022/02/08/noxwzDLZhP1jdF7.png" alt="E.png"></p>
<h3 id="F-阶乘"><a href="#F-阶乘" class="headerlink" title="F 阶乘"></a>F 阶乘</h3><p><img src="https://s2.loli.net/2022/02/08/bkaYFK8TzDS7fhu.png" alt="F.png"></p>
<h3 id="G-分石子"><a href="#G-分石子" class="headerlink" title="G 分石子"></a>G 分石子</h3><p><img src="https://s2.loli.net/2022/02/08/1fB326DXM9OW4JF.png" alt="G.png"></p>
<h3 id="H-小华的游戏"><a href="#H-小华的游戏" class="headerlink" title="H 小华的游戏"></a>H 小华的游戏</h3><p><img src="https://s2.loli.net/2022/02/08/PTIlf4qzHFr71pB.png" alt="H.png"></p>
<h3 id="I-消消乐"><a href="#I-消消乐" class="headerlink" title="I 消消乐"></a>I 消消乐</h3><p><img src="https://s2.loli.net/2022/02/08/69RLQkhySCtMTvZ.png" alt="I.png"></p>
<h1 id="m大的机试小tips"><a href="#m大的机试小tips" class="headerlink" title="m大的机试小tips"></a><a href="https://www.malic.xyz/">m大的机试小tips</a></h1><ul>
<li><p>必须<code>熟练掌握并会运用</code>一些<code>基本的算法</code>，例如<a href="https://github.com/sitJac/my-codes/tree/master/%E5%A4%8D%E8%AF%95%E6%8C%87%E5%8D%97">模拟, 二分, 递归, 分治, 数学, 贪心, 动态规划, DFS, BFS</a>，等等。</p>
</li>
<li><p>关于<code>参考书目</code>，市面上关于机试的参考书目也相当多。<br>王道系列<code>《计算机考研：机试指南》</code>内容非常详细，可惜针对此书的OJ已经关闭，<a href="http://www.cskaoyan.com/thread-647811-1-1.html">王道论坛官方便将此书pdf发布出来供大家下载</a>。不过，这类基础算法和上机考试书的内容都大同小异，胡凡、曾磊主编的《算法笔记》以PAT甲级和乙级的题目为实例，同样详细地讲解了各类基础算法。书上还提到C++ STL的简单使用方法，如果你只会用基本的C语言，没有接触过C++，那这本书可能会非常适合你，学着利用C++的STL提高做题效率，许多函数能省去自己编写的麻烦。百练OJ也有相应的参考书<code>《算法基础与在线实践》</code>。还有诸如<code>《挑战程序设计竞赛》</code>，<code>《算法竞赛入门经典》</code>等，当中有些内容针对ACM竞赛，其难度超过考研机试的水平，凡所种种不再列举。大家可以根据自己情况进行相应书目的参考和阅读。</p>
</li>
<li><p>建议学习一下 <code>C++</code> <code>标准模板库STL</code><br>机试支持的语言有C, C++, Java, python3。最建议使用C++。大家在准备初试考试时可能还是主要用的C语言。C++比C语言难的地方主要在于面向对象的特性，但这部分内容在比赛时是可以不用的，所以掌握入门的C++知识的难度与C语言相比并没有太大区别。由于C语言在一些语法细节上不如C++用起来方便，建议比赛时用C++写，可以理解成用的是经过稍许改进的C语言。更重要的是，C++有STL这个使用非常方便的库是C语言没有的，<br>例如，用STL写个整数的排序操作只要1行，而用C语言的写法，则需要六七行才能完成，而且还需要理解函数指针等复杂概念才可以。</p>
</li>
<li><p>还可以学习一下简单的Python，遇到<code>大数处理</code>时，Python可能对非常大的整数计算，如果是几十位几百位的整数的运算，在Python中就当普通的运算就可以正确，大数处理用C或C++会比较麻烦。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>ECNU</category>
      </categories>
  </entry>
  <entry>
    <title>Human Resource Machine Completion Guide</title>
    <url>/blog/game-guides-human-resource-machine/</url>
    <content><![CDATA[<div class="note info">

<ul>
<li><a href="https://tomorrowcorporation.com/humanresourcemachine">Human Resource Machine</a> is a <a href="https://en.wikipedia.org/wiki/Visual_programming_language">visual programming-based</a> puzzle video game developed by <a href="https://tomorrowcorporation.com/about">Tomorrow Corporation</a>. </li>
<li>In each level, your boss gives you a job. Automate it by programming your little office worker! If you succeed, you will be promoted up to the next level for another year of work in the vast office building. Congratulations!</li>
<li>This game is really interesting, especially the optimization as a programmer, and this blog is written as a technical document for myself to review in the future. It is not necessarily the best solution, I am just explaining my thoughts :)</li>
</ul>
<p><img src="/blog/images/human-resource-machine/HumanResourceMachine.jpg"></p>
</div>

<span id="more"></span>


<h2 id="Year-1-Mail-Room"><a href="#Year-1-Mail-Room" class="headerlink" title="Year 1: Mail Room"></a>Year 1: Mail Room</h2><div style="float: left; width: 49%">

<blockquote>
<p>– HUMAN RESOURCE MACHINE PROGRAM –</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INBOX   </span><br><span class="line">OUTBOX  </span><br><span class="line">INBOX   </span><br><span class="line">OUTBOX  </span><br><span class="line">INBOX   </span><br><span class="line">OUTBOX  </span><br></pre></td></tr></table></figure>
<blockquote>
<p>– Commands: 6&#x2F;6   Steps: 6&#x2F;6  –</p>
</blockquote>
<p>PS: 关于输入语句<code>INPUT</code>和输出语句<code>OUTPUT</code>如何使用的教程关卡，可以类比高级语言中的<code>std::cin</code>和<code>std::cout</code>。</p>
</div>

<div style="float: right; width: 50%">

<p><img src="/blog/images/human-resource-machine/1.jpg"></p>
</div>

<div style="clear: both;"></div>



<h2 id="Year-2-Busy-Mail-Room"><a href="#Year-2-Busy-Mail-Room" class="headerlink" title="Year 2: Busy Mail Room"></a>Year 2: Busy Mail Room</h2><div style="float: left; width: 49%">

<blockquote>
<p>– HUMAN RESOURCE MACHINE PROGRAM –</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a:</span><br><span class="line">    INBOX   </span><br><span class="line">    OUTBOX  </span><br><span class="line">    JUMP     a</span><br></pre></td></tr></table></figure>
<blockquote>
<p>– Commands: 3&#x2F;3   <del>Steps: 30&#x2F;25</del>  –</p>
</blockquote>
<p>PS: 关于循环语句<code>JUMP</code>的如何使用的教程关卡，可以类比高级语言中的<code>for</code>，<code>while</code>等循环控制语句。</p>
</div>

<div style="float: right; width: 50%">

<p><img src="/blog/images/human-resource-machine/2.jpg"></p>
</div>

<div style="clear: both;"></div>



<h2 id="Year-3-Copy-Floor"><a href="#Year-3-Copy-Floor" class="headerlink" title="Year 3: Copy Floor"></a>Year 3: Copy Floor</h2><div style="float: left; width: 49%">

<blockquote>
<p>– HUMAN RESOURCE MACHINE PROGRAM –</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">COPYFROM 4 -- &#x27;B&quot;</span><br><span class="line">OUTBOX  </span><br><span class="line">COPYFROM 0 -- &#x27;U&#x27;</span><br><span class="line">OUTBOX  </span><br><span class="line">COPYFROM 3 -- &#x27;G&#x27;</span><br><span class="line">OUTBOX  </span><br></pre></td></tr></table></figure>
<blockquote>
<p>– Commands: 6&#x2F;6   Steps: 6&#x2F;6  –</p>
</blockquote>
<p>PS: 关于获取指令<code>COPYFROM</code>如何使用的教程关卡，地板可以理解成内存，<code>COPYFROM</code>的作用是从内存中取对应位置的值，本关依次取出地面上对应值输出即可满足两个优化条件。</p>
</div>

<div style="float: right; width: 50%">

<p><img src="/blog/images/human-resource-machine/3.jpg"></p>
</div>

<div style="clear: both;"></div>



<h2 id="Year-4-Scrambler-Handler"><a href="#Year-4-Scrambler-Handler" class="headerlink" title="Year 4: Scrambler Handler"></a>Year 4: Scrambler Handler</h2><div style="float: left; width: 49%">

<blockquote>
<p>– HUMAN RESOURCE MACHINE PROGRAM –</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a:</span><br><span class="line">    INBOX   </span><br><span class="line">    COPYTO   0</span><br><span class="line">    INBOX   </span><br><span class="line">    OUTBOX  </span><br><span class="line">    COPYFROM 0</span><br><span class="line">    OUTBOX  </span><br><span class="line">    JUMP     a </span><br></pre></td></tr></table></figure>
<blockquote>
<p>– Commands: 7&#x2F;7   Steps: 21&#x2F;21  –</p>
</blockquote>
<p>PS: 关于设置指令<code>COPYTO</code>如何使用的教程关卡，<code>COPYTO</code>的作用是从将当前手中的值设置(拷贝)到内存中对应位置。</p>
</div>

<div style="float: right; width: 50%">

<p><img src="/blog/images/human-resource-machine/4.jpg"></p>
</div>

<div style="clear: both;"></div>



<h2 id="Year-5-Coffee-Time"><a href="#Year-5-Coffee-Time" class="headerlink" title="Year 5: Coffee Time"></a>Year 5: Coffee Time</h2><div style="float: right; width: 100%">

<p><img src="/blog/images/human-resource-machine/5.jpg"></p>
</div>

<div style="clear: both;"></div>



<h2 id="Year-6-Rainy-Summer"><a href="#Year-6-Rainy-Summer" class="headerlink" title="Year 6: Rainy Summer"></a>Year 6: Rainy Summer</h2><div style="float: left; width: 49%">

<blockquote>
<p>– HUMAN RESOURCE MACHINE PROGRAM –</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a:</span><br><span class="line">    INBOX   </span><br><span class="line">    COPYTO   0</span><br><span class="line">    INBOX   </span><br><span class="line">    ADD      0</span><br><span class="line">    OUTBOX  </span><br><span class="line">    JUMP     a</span><br></pre></td></tr></table></figure>
<blockquote>
<p>– Commands: 6&#x2F;6   Steps: 24&#x2F;24  –</p>
</blockquote>
<p>PS: 关于加法指令<code>ADD</code>如何使用的教程关卡，<code>ADD</code>的作用是从将当前手中的值和地板上指定位置的值相加后替换当前手中的值。</p>
</div>

<div style="float: right; width: 50%">

<p><img src="/blog/images/human-resource-machine/6.jpg"></p>
</div>

<div style="clear: both;"></div>



<h2 id="Year-7-Zero-Exterminator"><a href="#Year-7-Zero-Exterminator" class="headerlink" title="Year 7: Zero Exterminator"></a>Year 7: Zero Exterminator</h2><div style="float: left; width: 49%">

<blockquote>
<p>– HUMAN RESOURCE MACHINE PROGRAM –</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a:</span><br><span class="line">b:</span><br><span class="line">    INBOX   </span><br><span class="line">    JUMPZ    b</span><br><span class="line">    OUTBOX  </span><br><span class="line">    JUMP     a </span><br></pre></td></tr></table></figure>
<blockquote>
<p>– Commands: 4&#x2F;4   Steps: 23&#x2F;23  –</p>
</blockquote>
<p>PS: 关于条件判断跳转语句<code>JUMPZ</code>如何使用的教程关卡，类似高级语言中的条件判断，若满住当前手中的值为0则跳转执行相应的逻辑。</p>
</div>

<div style="float: right; width: 50%">

<p><img src="/blog/images/human-resource-machine/7.jpg"></p>
</div>

<div style="clear: both;"></div>



<h2 id="Year-8-Tripler-Room"><a href="#Year-8-Tripler-Room" class="headerlink" title="Year 8: Tripler Room"></a>Year 8: Tripler Room</h2><div style="float: left; width: 49%">

<blockquote>
<p>– HUMAN RESOURCE MACHINE PROGRAM –</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a:</span><br><span class="line">    INBOX   </span><br><span class="line">    COPYTO   0</span><br><span class="line">    ADD      0</span><br><span class="line">    ADD      0</span><br><span class="line">    OUTBOX  </span><br><span class="line">    JUMP     a</span><br></pre></td></tr></table></figure>
<blockquote>
<p>– Commands: 6&#x2F;6   Steps: 24&#x2F;24  –</p>
</blockquote>
<p>PS: 在没有乘法的世界里，将输入的值相加三次就是乘以三。</p>
</div>

<div style="float: right; width: 50%">

<p><img src="/blog/images/human-resource-machine/8.jpg"></p>
</div>

<div style="clear: both;"></div>



<h2 id="Year-9-Zero-Preservation-Initiative"><a href="#Year-9-Zero-Preservation-Initiative" class="headerlink" title="Year 9: Zero Preservation Initiative"></a>Year 9: Zero Preservation Initiative</h2><div style="float: left; width: 49%">

<blockquote>
<p>– HUMAN RESOURCE MACHINE PROGRAM –</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a:</span><br><span class="line">b:</span><br><span class="line">    INBOX   </span><br><span class="line">    JUMPZ    c</span><br><span class="line">    JUMP     b</span><br><span class="line">c:</span><br><span class="line">    OUTBOX  </span><br><span class="line">    JUMP     a</span><br></pre></td></tr></table></figure>
<blockquote>
<p>– Commands: 5&#x2F;5   <del>Steps: 28&#x2F;25</del>  –</p>
</blockquote>
<p>PS: 和第七关刚好相反，只要0，条件判断的简单应用。</p>
</div>

<div style="float: right; width: 50%">

<p><img src="/blog/images/human-resource-machine/9.jpg"></p>
</div>

<div style="clear: both;"></div>



<h2 id="Year-10-Octoplier-Suite"><a href="#Year-10-Octoplier-Suite" class="headerlink" title="Year 10: Octoplier Suite"></a>Year 10: Octoplier Suite</h2><div style="float: left; width: 49%">

<blockquote>
<p>– HUMAN RESOURCE MACHINE PROGRAM –</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a:</span><br><span class="line">    INBOX   </span><br><span class="line">    COPYTO   0</span><br><span class="line">    ADD      0</span><br><span class="line">    COPYTO   1</span><br><span class="line">    ADD      1</span><br><span class="line">    COPYTO   2</span><br><span class="line">    ADD      2</span><br><span class="line">    OUTBOX  </span><br><span class="line">    JUMP     a</span><br></pre></td></tr></table></figure>
<blockquote>
<p>– Commands: 9&#x2F;9   Steps: 36&#x2F;36  –</p>
</blockquote>
<p>PS: 题目要求只能用3个<code>ADD</code>实现乘以8，8的特别之处在于它是2的三次方，8 &#x3D; 2 * 2 * 2，所以转换为将输入进行三次翻倍操作即可。</p>
</div>

<div style="float: right; width: 50%">

<p><img src="/blog/images/human-resource-machine/10.jpg"></p>
</div>

<div style="clear: both;"></div>



<h2 id="Year-11-Sub-Hallway"><a href="#Year-11-Sub-Hallway" class="headerlink" title="Year 11: Sub Hallway"></a>Year 11: Sub Hallway</h2><div style="float: left; width: 49%">

<blockquote>
<p>– HUMAN RESOURCE MACHINE PROGRAM –</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a:</span><br><span class="line">    INBOX   </span><br><span class="line">    COPYTO   0</span><br><span class="line">    INBOX   </span><br><span class="line">    COPYTO   1</span><br><span class="line">    SUB      0</span><br><span class="line">    OUTBOX  </span><br><span class="line">    COPYFROM 0</span><br><span class="line">    SUB      1</span><br><span class="line">    OUTBOX  </span><br><span class="line">    JUMP     a</span><br></pre></td></tr></table></figure>
<blockquote>
<p>– Commands: 10&#x2F;10   Steps: 40&#x2F;40  –</p>
</blockquote>
<p>PS: 因为需要输出 a-b 和 b-a，所以两个输入都需要存储。</p>
</div>

<div style="float: right; width: 50%">

<p><img src="/blog/images/human-resource-machine/11.jpg"></p>
</div>

<div style="clear: both;"></div>



<h2 id="Year-12-Tetracontiplier"><a href="#Year-12-Tetracontiplier" class="headerlink" title="Year 12: Tetracontiplier"></a>Year 12: Tetracontiplier</h2><div style="float: left; width: 49%">

<blockquote>
<p>– HUMAN RESOURCE MACHINE PROGRAM –</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a:</span><br><span class="line">    INBOX   </span><br><span class="line">    COPYTO   0</span><br><span class="line">    ADD      0</span><br><span class="line">    COPYTO   1</span><br><span class="line">    ADD      1</span><br><span class="line">    COPYTO   2</span><br><span class="line">    ADD      2</span><br><span class="line">    COPYTO   3</span><br><span class="line">    ADD      3</span><br><span class="line">    ADD      4</span><br><span class="line">    ADD      4</span><br><span class="line">    ADD      3</span><br><span class="line">    OUTBOX  </span><br><span class="line">    JUMP     a</span><br></pre></td></tr></table></figure>
<blockquote>
<p>– Commands: 14&#x2F;14   Steps: 56&#x2F;56  –</p>
</blockquote>
<p>PS: 和第十题八倍放大是一样的思路，a * 40 &#x3D; (a * 16) + (a * 16) + (a * 8)，注意区分哪些倍数哪些数需要暂存。</p>
</div>

<div style="float: right; width: 50%">

<p><img src="/blog/images/human-resource-machine/12.jpg"></p>
</div>

<div style="clear: both;"></div>



<h2 id="Year-13-Equalization-Room"><a href="#Year-13-Equalization-Room" class="headerlink" title="Year 13: Equalization Room"></a>Year 13: Equalization Room</h2><div style="float: left; width: 49%">

<blockquote>
<p>– HUMAN RESOURCE MACHINE PROGRAM –</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    JUMP     b</span><br><span class="line">a:</span><br><span class="line">    COPYFROM 0</span><br><span class="line">    OUTBOX  </span><br><span class="line">b:</span><br><span class="line">c:</span><br><span class="line">    INBOX   </span><br><span class="line">    COPYTO   0</span><br><span class="line">    INBOX   </span><br><span class="line">    SUB      0</span><br><span class="line">    JUMPZ    a</span><br><span class="line">    JUMP     c</span><br></pre></td></tr></table></figure>
<blockquote>
<p>– Commands: 9&#x2F;9   Steps: 27&#x2F;27  –</p>
</blockquote>
<p>PS: 两个数是否相同，用<code>SUB</code>和<code>JUMPZ</code>命令在做判断。</p>
</div>

<div style="float: right; width: 50%">

<p><img src="/blog/images/human-resource-machine/13.jpg"></p>
</div>

<div style="clear: both;"></div>



<h2 id="Year-14-Maximization-Room"><a href="#Year-14-Maximization-Room" class="headerlink" title="Year 14: Maximization Room"></a>Year 14: Maximization Room</h2><div style="float: left; width: 49%">

<blockquote>
<p>– HUMAN RESOURCE MACHINE PROGRAM –</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a:</span><br><span class="line">    INBOX   </span><br><span class="line">    COPYTO   0</span><br><span class="line">    INBOX   </span><br><span class="line">    SUB      0</span><br><span class="line">    JUMPN    c</span><br><span class="line">    ADD      0</span><br><span class="line">b:</span><br><span class="line">    OUTBOX  </span><br><span class="line">    JUMP     a</span><br><span class="line">c:</span><br><span class="line">    COPYFROM 0</span><br><span class="line">    JUMP     b</span><br></pre></td></tr></table></figure>
<blockquote>
<p>– Commands: 10&#x2F;10   Steps: 33&#x2F;34  –</p>
</blockquote>
<p>PS: 判断两个值的大小关系（b-a是否为负，If a &lt; b, then a-b &lt; 0.）后回归原值输出：先将a储存，当a更大时可以直接读取a的值输出，而当b更大时则有b &#x3D; b-a+a，再用一个<code>ADD</code>指令即可。</p>
</div>

<div style="float: right; width: 50%">

<p><img src="/blog/images/human-resource-machine/14.jpg"></p>
</div>

<div style="clear: both;"></div>



<h2 id="Year-15-Employee-Morale-Insertion"><a href="#Year-15-Employee-Morale-Insertion" class="headerlink" title="Year 15: Employee Morale Insertion"></a>Year 15: Employee Morale Insertion</h2><div style="float: right; width: 100%">

<p><img src="/blog/images/human-resource-machine/15.jpg"></p>
</div>

<div style="clear: both;"></div>



<h2 id="Year-16-Absolute-Positivity"><a href="#Year-16-Absolute-Positivity" class="headerlink" title="Year 16: Absolute Positivity"></a>Year 16: Absolute Positivity</h2><div style="float: left; width: 49%">

<blockquote>
<p>– HUMAN RESOURCE MACHINE PROGRAM –</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    JUMP     c</span><br><span class="line">a:</span><br><span class="line">    COPYTO   0</span><br><span class="line">    SUB      0</span><br><span class="line">    SUB      0</span><br><span class="line">b:</span><br><span class="line">    OUTBOX  </span><br><span class="line">c:</span><br><span class="line">    INBOX   </span><br><span class="line">    JUMPN    a</span><br><span class="line">    JUMP     b</span><br></pre></td></tr></table></figure>
<blockquote>
<p>– Commands: 8&#x2F;8   Steps: 34&#x2F;36  –</p>
</blockquote>
<p>PS: 若输入为正数则直接输出，若输入为负数则-a为正数，其中-a &#x3D; a - a - a。</p>
</div>

<div style="float: right; width: 50%">

<p><img src="/blog/images/human-resource-machine/16.jpg"></p>
</div>

<div style="clear: both;"></div>



<h2 id="Year-17-Exclusive-Lounge"><a href="#Year-17-Exclusive-Lounge" class="headerlink" title="Year 17: Exclusive Lounge"></a>Year 17: Exclusive Lounge</h2><div style="float: left; width: 49%">

<blockquote>
<p>– HUMAN RESOURCE MACHINE PROGRAM –</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a:</span><br><span class="line">    INBOX   </span><br><span class="line">    JUMPN    c</span><br><span class="line">    INBOX   </span><br><span class="line">    JUMPN    d</span><br><span class="line">b:               -- +,+ or -,-</span><br><span class="line">    COPYFROM 4   -- Pick up a 0</span><br><span class="line">    OUTBOX  </span><br><span class="line">    JUMP     a</span><br><span class="line">c:               </span><br><span class="line">    INBOX   </span><br><span class="line">    JUMPN    b</span><br><span class="line">d:               -- +,- or -,+</span><br><span class="line">    COPYFROM 5   -- Pick up a 1</span><br><span class="line">    OUTBOX  </span><br><span class="line">    JUMP     a</span><br></pre></td></tr></table></figure>
<blockquote>
<p>– Commands: 12&#x2F;12   Steps: 28&#x2F;28  –</p>
</blockquote>
<p>PS: 需要用条件判断跳转语句实现四种条件的判断与跳转(++, +-, -+, and –)，a为正时，若b为正则输出0，若b为负则输出1；a为负时，若b为负则输出0，b为正则输出1；</p>
</div>

<div style="float: right; width: 50%">

<p><img src="/blog/images/human-resource-machine/17.jpg"></p>
</div>

<div style="clear: both;"></div>



<h2 id="Year-18：Sabbatical-Beach-Paradise"><a href="#Year-18：Sabbatical-Beach-Paradise" class="headerlink" title="Year 18：Sabbatical Beach Paradise"></a>Year 18：Sabbatical Beach Paradise</h2><div style="float: right; width: 100%">

<p><img src="/blog/images/human-resource-machine/18.jpg"></p>
</div>

<div style="clear: both;"></div>



<h2 id="Year-19-Countdown"><a href="#Year-19-Countdown" class="headerlink" title="Year 19: Countdown"></a>Year 19: Countdown</h2><div style="float: left; width: 49%">

<blockquote>
<p>– HUMAN RESOURCE MACHINE PROGRAM –</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a:</span><br><span class="line">    INBOX   </span><br><span class="line">    COPYTO   0</span><br><span class="line">b:</span><br><span class="line">c:</span><br><span class="line">    OUTBOX  </span><br><span class="line">    COPYFROM 0</span><br><span class="line">    JUMPZ    a</span><br><span class="line">    JUMPN    d</span><br><span class="line">    BUMPDN   0</span><br><span class="line">    JUMP     c</span><br><span class="line">d:</span><br><span class="line">    BUMPUP   0</span><br><span class="line">    JUMP     b</span><br></pre></td></tr></table></figure>
<blockquote>
<p>– Commands: 10&#x2F;10   <del>Steps: 114&#x2F;82</del>  –</p>
</blockquote>
<p>PS: 这一关引入了<code>BUMP+</code>(BUMPUP)和<code>BUMP-</code>(BUMPDN)两个指令，这两个指令可以实现对地板上指定位置的数值进行自增或自减，操作完成后更新手中的值和地板上的值。 </p>
</div>

<div style="float: right; width: 50%">

<p><img src="/blog/images/human-resource-machine/19.jpg"></p>
</div>

<div style="clear: both;"></div>



<h2 id="Year-20-Multiplication-Workshop"><a href="#Year-20-Multiplication-Workshop" class="headerlink" title="Year 20: Multiplication Workshop"></a>Year 20: Multiplication Workshop</h2><div style="float: left; width: 49%">

<blockquote>
<p>– HUMAN RESOURCE MACHINE PROGRAM –</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a:</span><br><span class="line">    INBOX   </span><br><span class="line">    COPYTO   0</span><br><span class="line">    COPYFROM 9    -- Tile 9 is preloaded with 0</span><br><span class="line">    COPYTO   2</span><br><span class="line">    INBOX   </span><br><span class="line">    COPYTO   1</span><br><span class="line">b:</span><br><span class="line">    BUMPDN   1</span><br><span class="line">    JUMPN    c</span><br><span class="line">    COPYFROM 0</span><br><span class="line">    ADD      2</span><br><span class="line">    COPYTO   2</span><br><span class="line">    JUMP     b</span><br><span class="line">c:</span><br><span class="line">    COPYFROM 2</span><br><span class="line">    OUTBOX  </span><br><span class="line">    JUMP     a</span><br></pre></td></tr></table></figure>
<blockquote>
<p>– Commands: 15&#x2F;15   Steps: 167&#x2F;109  –</p>
</blockquote>
<p>PS: 实现对两个输入值的乘法操作，只需将一个输入的值与另一个输入指定的次数相加即可。</p>
</div>

<div style="float: right; width: 50%">

<p><img src="/blog/images/human-resource-machine/20.jpg"></p>
</div>

<div style="clear: both;"></div>



<h2 id="Year-21-Zero-Terminated-Sum"><a href="#Year-21-Zero-Terminated-Sum" class="headerlink" title="Year 21: Zero Terminated Sum"></a>Year 21: Zero Terminated Sum</h2><div style="float: left; width: 49%">

<blockquote>
<p>– HUMAN RESOURCE MACHINE PROGRAM –</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a:</span><br><span class="line">    INBOX   </span><br><span class="line">    JUMPZ    d</span><br><span class="line">b:</span><br><span class="line">    COPYTO   0</span><br><span class="line">    INBOX   </span><br><span class="line">    JUMPZ    c</span><br><span class="line">    ADD      0</span><br><span class="line">    JUMP     b</span><br><span class="line">c:</span><br><span class="line">    COPYFROM 0</span><br><span class="line">d:</span><br><span class="line">    OUTBOX  </span><br><span class="line">    JUMP     a</span><br></pre></td></tr></table></figure>
<blockquote>
<p>– Commands: 10&#x2F;10   Steps: 72&#x2F;72  –</p>
</blockquote>
<p>PS: 这一关很直接，将0之前的数字全部相加输出即可。</p>
</div>

<div style="float: right; width: 50%">

<p><img src="/blog/images/human-resource-machine/21.jpg"></p>
</div>

<div style="clear: both;"></div>



<h2 id="Year-22-Fibonacci-Visitor"><a href="#Year-22-Fibonacci-Visitor" class="headerlink" title="Year 22: Fibonacci Visitor"></a>Year 22: Fibonacci Visitor</h2><div style="float: left; width: 49%">

<blockquote>
<p>– HUMAN RESOURCE MACHINE PROGRAM –</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a:</span><br><span class="line">    INBOX   </span><br><span class="line">    COPYTO   5</span><br><span class="line">    COPYFROM 9 -- &#x27;0&#x27;</span><br><span class="line">    COPYTO   0</span><br><span class="line">    COPYTO   1</span><br><span class="line">    BUMPUP   0</span><br><span class="line">    OUTBOX  </span><br><span class="line">b:</span><br><span class="line">    COPYFROM 0</span><br><span class="line">    COPYTO   2</span><br><span class="line">    ADD      1</span><br><span class="line">    COPYTO   0</span><br><span class="line">    COPYFROM 5</span><br><span class="line">    SUB      0</span><br><span class="line">    JUMPN    a</span><br><span class="line">    COPYFROM 2</span><br><span class="line">    COPYTO   1</span><br><span class="line">    COPYFROM 0</span><br><span class="line">    OUTBOX  </span><br><span class="line">    JUMP     b</span><br></pre></td></tr></table></figure>
<blockquote>
<p>– Commands: 19&#x2F;19   Steps: 156&#x2F;156  –</p>
</blockquote>
<p>PS: 一种简单的方法是开辟两个位置来存储斐波那契数列中的最后两个值，相加，然后使用新结果和先前结果更新这两个位置。根据需要重复循环，直到输出值大于输入。为了实现目标，要在循环开始之前输出第一个值。</p>
</div>

<div style="float: right; width: 50%">

<p><img src="/blog/images/human-resource-machine/22.jpg"></p>
</div>

<div style="clear: both;"></div>



<h2 id="Year-23-The-Littlest-Number"><a href="#Year-23-The-Littlest-Number" class="headerlink" title="Year 23: The Littlest Number"></a>Year 23: The Littlest Number</h2><div style="float: left; width: 49%">

<blockquote>
<p>– HUMAN RESOURCE MACHINE PROGRAM –</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a:</span><br><span class="line">    INBOX   </span><br><span class="line">    COPYTO   0</span><br><span class="line">b:</span><br><span class="line">c:</span><br><span class="line">    INBOX   </span><br><span class="line">    JUMPZ    e</span><br><span class="line">    SUB      0</span><br><span class="line">    JUMPN    d</span><br><span class="line">    JUMP     b</span><br><span class="line">d:</span><br><span class="line">    ADD      0</span><br><span class="line">    COPYTO   0</span><br><span class="line">    JUMP     c</span><br><span class="line">e:</span><br><span class="line">    COPYFROM 0</span><br><span class="line">    OUTBOX  </span><br><span class="line">    JUMP     a</span><br></pre></td></tr></table></figure>
<blockquote>
<p>– Commands: 13&#x2F;13   Steps: 75&#x2F;75  –</p>
</blockquote>
<p>PS: 略</p>
</div>

<div style="float: right; width: 50%">

<p><img src="/blog/images/human-resource-machine/23.jpg"></p>
</div>

<div style="clear: both;"></div>



<h2 id="Year-24-Mod-Module"><a href="#Year-24-Mod-Module" class="headerlink" title="Year 24: Mod Module"></a>Year 24: Mod Module</h2><div style="float: left; width: 49%">

<blockquote>
<p>– HUMAN RESOURCE MACHINE PROGRAM –</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a:</span><br><span class="line">    INBOX   </span><br><span class="line">    COPYTO   0</span><br><span class="line">    INBOX   </span><br><span class="line">    COPYTO   1</span><br><span class="line">    COPYFROM 0</span><br><span class="line">b:</span><br><span class="line">    SUB      1</span><br><span class="line">    JUMPN    c</span><br><span class="line">    JUMP     b</span><br><span class="line">c:</span><br><span class="line">    ADD      1</span><br><span class="line">    OUTBOX  </span><br><span class="line">    JUMP     a</span><br></pre></td></tr></table></figure>
<blockquote>
<p>– Commands: 11&#x2F;12   Steps: 53&#x2F;57  –</p>
</blockquote>
<p>PS: 略</p>
</div>

<div style="float: right; width: 50%">

<p><img src="/blog/images/human-resource-machine/24.jpg"></p>
</div>

<div style="clear: both;"></div>



<h2 id="Year-25-Cumulative-Countdown"><a href="#Year-25-Cumulative-Countdown" class="headerlink" title="Year 25: Cumulative Countdown"></a>Year 25: Cumulative Countdown</h2><div style="float: left; width: 49%">

<blockquote>
<p>– HUMAN RESOURCE MACHINE PROGRAM –</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a:</span><br><span class="line">    INBOX   </span><br><span class="line">    JUMPZ    d</span><br><span class="line">    COPYTO   1</span><br><span class="line">    COPYTO   0</span><br><span class="line">b:</span><br><span class="line">    BUMPDN   0</span><br><span class="line">    JUMPZ    c</span><br><span class="line">    ADD      1</span><br><span class="line">    COPYTO   1</span><br><span class="line">    JUMP     b</span><br><span class="line">c:</span><br><span class="line">    COPYFROM 1</span><br><span class="line">d:</span><br><span class="line">    OUTBOX  </span><br><span class="line">    JUMP     a</span><br></pre></td></tr></table></figure>
<blockquote>
<p>– Commands: 12&#x2F;12   Steps: 82&#x2F;82  –</p>
</blockquote>
<p>PS: 略</p>
</div>

<div style="float: right; width: 50%">

<p><img src="/blog/images/human-resource-machine/25.jpg"></p>
</div>

<div style="clear: both;"></div>



<h2 id="Year-26-Small-Divide"><a href="#Year-26-Small-Divide" class="headerlink" title="Year 26: Small Divide"></a>Year 26: Small Divide</h2><div style="float: left; width: 49%">

<blockquote>
<p>– HUMAN RESOURCE MACHINE PROGRAM –</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a:</span><br><span class="line">    INBOX   </span><br><span class="line">    COPYTO   0</span><br><span class="line">    INBOX</span><br><span class="line">    COPYTO   1</span><br><span class="line">    COPYFROM 9</span><br><span class="line">    COPYTO   8</span><br><span class="line">b:</span><br><span class="line">    COPYFROM 0</span><br><span class="line">    SUB      1</span><br><span class="line">    COPYTO   0</span><br><span class="line">    JUMPN    c</span><br><span class="line">    BUMPUP   8</span><br><span class="line">    JUMP     a </span><br><span class="line">c:</span><br><span class="line">    COPYFROM 8</span><br><span class="line">    OUTBOX  </span><br><span class="line">    JUMP     a</span><br></pre></td></tr></table></figure>
<blockquote>
<p>– Commands: 15&#x2F;15   <del>Steps: 76&#x2F;78</del>  –</p>
</blockquote>
<p>PS: 略</p>
</div>

<div style="float: right; width: 50%">

<p><img src="/blog/images/human-resource-machine/26.jpg"></p>
</div>

<div style="clear: both;"></div>



<h2 id="Year-27-Midnight-Petroleum"><a href="#Year-27-Midnight-Petroleum" class="headerlink" title="Year 27: Midnight Petroleum"></a>Year 27: Midnight Petroleum</h2><div style="float: right; width: 100%">

<p><img src="/blog/images/human-resource-machine/27.jpg"></p>
</div>

<div style="clear: both;"></div>



<h2 id="Year-28-Three-Sort"><a href="#Year-28-Three-Sort" class="headerlink" title="Year 28: Three Sort"></a>Year 28: Three Sort</h2><div style="float: left; width: 49%">

<blockquote>
<p>– HUMAN RESOURCE MACHINE PROGRAM –</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a:</span><br><span class="line">    INBOX   </span><br><span class="line">    COPYTO   0</span><br><span class="line">    INBOX   </span><br><span class="line">    COPYTO   1</span><br><span class="line">    INBOX   </span><br><span class="line">    COPYTO   2</span><br><span class="line">    COPYFROM 1</span><br><span class="line">    SUB      2</span><br><span class="line">    JUMPN    c</span><br><span class="line">b:</span><br><span class="line">    COPYFROM 2</span><br><span class="line">    COPYTO   3</span><br><span class="line">    COPYFROM 1</span><br><span class="line">    COPYTO   2</span><br><span class="line">    COPYFROM 3</span><br><span class="line">    COPYTO   1</span><br><span class="line">c:</span><br><span class="line">    COPYFROM 0</span><br><span class="line">    SUB      1</span><br><span class="line">    JUMPN    d</span><br><span class="line">    COPYFROM 1</span><br><span class="line">    COPYTO   3</span><br><span class="line">    COPYFROM 0</span><br><span class="line">    COPYTO   1</span><br><span class="line">    COPYFROM 3</span><br><span class="line">    COPYTO   0</span><br><span class="line">d:</span><br><span class="line">    COPYFROM 2</span><br><span class="line">    SUB      1</span><br><span class="line">    JUMPN    b</span><br><span class="line">    COPYFROM 0</span><br><span class="line">    OUTBOX  </span><br><span class="line">    COPYFROM 1</span><br><span class="line">    OUTBOX  </span><br><span class="line">    COPYFROM 2</span><br><span class="line">    OUTBOX  </span><br><span class="line">    JUMP     a</span><br></pre></td></tr></table></figure>
<blockquote>
<p>– Commands: 34&#x2F;34   Steps: 78&#x2F;134  –</p>
</blockquote>
<p>PS: 略</p>
</div>

<div style="float: right; width: 50%">

<p><img src="/blog/images/human-resource-machine/28.jpg"></p>
</div>

<div style="clear: both;"></div>



<h2 id="Year-29-Storage-Floor"><a href="#Year-29-Storage-Floor" class="headerlink" title="Year 29: Storage Floor"></a>Year 29: Storage Floor</h2><div style="float: left; width: 49%">

<blockquote>
<p>– HUMAN RESOURCE MACHINE PROGRAM –</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a:</span><br><span class="line">    INBOX   </span><br><span class="line">    COPYTO   10</span><br><span class="line">    COPYFROM [10]</span><br><span class="line">    OUTBOX  </span><br><span class="line">    JUMP     a</span><br></pre></td></tr></table></figure>
<blockquote>
<p>– Commands: 5&#x2F;5   Steps: 25&#x2F;25  –</p>
</blockquote>
<p>PS: 略</p>
</div>

<div style="float: right; width: 50%">

<p><img src="/blog/images/human-resource-machine/29.jpg"></p>
</div>

<div style="clear: both;"></div>



<h2 id="Year-30-String-Storage-Floor"><a href="#Year-30-String-Storage-Floor" class="headerlink" title="Year 30: String Storage Floor"></a>Year 30: String Storage Floor</h2><div style="float: left; width: 49%">

<blockquote>
<p>– HUMAN RESOURCE MACHINE PROGRAM –</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a:</span><br><span class="line">    INBOX   </span><br><span class="line">    COPYTO   24</span><br><span class="line">b:</span><br><span class="line">    COPYFROM [24]</span><br><span class="line">    JUMPZ    a</span><br><span class="line">    OUTBOX  </span><br><span class="line">    BUMPUP   24</span><br><span class="line">    JUMP     b</span><br></pre></td></tr></table></figure>
<blockquote>
<p>– Commands: 7&#x2F;7   Steps: 203&#x2F;203  –</p>
</blockquote>
<p>PS: 实现对两个输入值的乘法操作，只需将一个输入的值与另一个输入指定的次数相加即可。</p>
</div>

<div style="float: right; width: 50%">

<p><img src="/blog/images/human-resource-machine/30.jpg"></p>
</div>

<div style="clear: both;"></div>



<h2 id="Year-31-String-Reverse"><a href="#Year-31-String-Reverse" class="headerlink" title="Year 31: String Reverse"></a>Year 31: String Reverse</h2><div style="float: left; width: 49%">

<blockquote>
<p>– HUMAN RESOURCE MACHINE PROGRAM –</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a:</span><br><span class="line">    BUMPUP   14 -- &#x27;0&#x27; to &#x27;1&#x27;</span><br><span class="line">b:</span><br><span class="line">    INBOX   </span><br><span class="line">    JUMPZ    c</span><br><span class="line">    COPYTO   [14]</span><br><span class="line">    BUMPUP   14</span><br><span class="line">    JUMP     b</span><br><span class="line">c:</span><br><span class="line">d:</span><br><span class="line">    BUMPDN   14</span><br><span class="line">    JUMPZ    a</span><br><span class="line">    COPYFROM [14]</span><br><span class="line">    OUTBOX  </span><br><span class="line">    JUMP     d</span><br></pre></td></tr></table></figure>
<blockquote>
<p>– Commands: 11&#x2F;11   Steps: 121&#x2F;122  –</p>
</blockquote>
<p>PS: 略</p>
</div>

<div style="float: right; width: 50%">

<p><img src="/blog/images/human-resource-machine/31.jpg"></p>
</div>

<div style="clear: both;"></div>



<h2 id="Year-32-Inventory-Report"><a href="#Year-32-Inventory-Report" class="headerlink" title="Year 32: Inventory Report"></a>Year 32: Inventory Report</h2><div style="float: left; width: 49%">

<blockquote>
<p>– HUMAN RESOURCE MACHINE PROGRAM –</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a:</span><br><span class="line">    COPYFROM 14 -- &#x27;0&#x27;</span><br><span class="line">    COPYTO   16</span><br><span class="line">    COPYTO   17</span><br><span class="line">    INBOX   </span><br><span class="line">    COPYTO   15</span><br><span class="line">    JUMP     d</span><br><span class="line">b:</span><br><span class="line">    BUMPUP   17</span><br><span class="line">c:</span><br><span class="line">    BUMPUP   16</span><br><span class="line">d:</span><br><span class="line">    COPYFROM [16]</span><br><span class="line">    JUMPZ    e</span><br><span class="line">    SUB      15</span><br><span class="line">    JUMPZ    b</span><br><span class="line">    JUMP     c</span><br><span class="line">e:</span><br><span class="line">    COPYFROM 17</span><br><span class="line">    OUTBOX  </span><br><span class="line">    JUMP     a</span><br></pre></td></tr></table></figure>
<blockquote>
<p>– Commands: 16&#x2F;16   Steps: 282&#x2F;393  –</p>
</blockquote>
<p>PS: 略</p>
</div>

<div style="float: right; width: 50%">

<p><img src="/blog/images/human-resource-machine/32.jpg"></p>
</div>

<div style="clear: both;"></div>



<h2 id="Year-33-Where-is-Carol"><a href="#Year-33-Where-is-Carol" class="headerlink" title="Year 33: Where is Carol?"></a>Year 33: Where is Carol?</h2><div style="float: right; width: 100%">

<p><img src="/blog/images/human-resource-machine/33.jpg"></p>
</div>

<div style="clear: both;"></div>


<h2 id="Year-34-Vowel-Incinerator"><a href="#Year-34-Vowel-Incinerator" class="headerlink" title="Year 34: Vowel Incinerator"></a>Year 34: Vowel Incinerator</h2><div style="float: left; width: 49%">

<blockquote>
<p>– HUMAN RESOURCE MACHINE PROGRAM –</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a:</span><br><span class="line">b:</span><br><span class="line">    COPYFROM 5 -- &#x27;0&#x27;</span><br><span class="line">    COPYTO   7</span><br><span class="line">    INBOX   </span><br><span class="line">    COPYTO   6</span><br><span class="line">c:</span><br><span class="line">    COPYFROM [7]</span><br><span class="line">    JUMPZ    d</span><br><span class="line">    SUB      6</span><br><span class="line">    JUMPZ    a</span><br><span class="line">    BUMPUP   7</span><br><span class="line">    JUMP     c</span><br><span class="line">d:</span><br><span class="line">    COPYFROM 6</span><br><span class="line">    OUTBOX  </span><br><span class="line">    JUMP     b</span><br></pre></td></tr></table></figure>
<blockquote>
<p>– Commands: 13&#x2F;13   Steps: 323&#x2F;323  –</p>
</blockquote>
<p>PS: 略</p>
</div>

<div style="float: right; width: 50%">

<p><img src="/blog/images/human-resource-machine/34.jpg"></p>
</div>

<div style="clear: both;"></div>



<h2 id="Year-35-Duplicate-Removal"><a href="#Year-35-Duplicate-Removal" class="headerlink" title="Year 35: Duplicate Removal"></a>Year 35: Duplicate Removal</h2><div style="float: left; width: 49%">

<blockquote>
<p>– HUMAN RESOURCE MACHINE PROGRAM –</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    INBOX   </span><br><span class="line">    COPYTO   0</span><br><span class="line">a:</span><br><span class="line">    OUTBOX  </span><br><span class="line">b:</span><br><span class="line">    INBOX   </span><br><span class="line">    COPYTO   12</span><br><span class="line">    COPYFROM 14</span><br><span class="line">    COPYTO   13</span><br><span class="line">c:</span><br><span class="line">    COPYFROM [13]</span><br><span class="line">    SUB      12</span><br><span class="line">    JUMPZ    b</span><br><span class="line">    BUMPDN   13</span><br><span class="line">    JUMPN    d</span><br><span class="line">    JUMP     c</span><br><span class="line">d:</span><br><span class="line">    BUMPUP   14</span><br><span class="line">    COPYFROM 12</span><br><span class="line">    COPYTO   [14]</span><br><span class="line">    JUMP     a</span><br></pre></td></tr></table></figure>
<blockquote>
<p>– Commands: 17&#x2F;17   Steps: 159&#x2F;167  –</p>
</blockquote>
<p>PS: 略</p>
</div>

<div style="float: right; width: 50%">

<p><img src="/blog/images/human-resource-machine/35.jpg"></p>
</div>

<div style="clear: both;"></div>



<h2 id="Year-36-Alphabetizer"><a href="#Year-36-Alphabetizer" class="headerlink" title="Year 36: Alphabetizer"></a>Year 36: Alphabetizer</h2><div style="float: left; width: 49%">

<blockquote>
<p>– HUMAN RESOURCE MACHINE PROGRAM –</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a:</span><br><span class="line">b:</span><br><span class="line">c:</span><br><span class="line">d:</span><br><span class="line">    COPYFROM 23</span><br><span class="line">    COPYTO   22</span><br><span class="line">e: -- read in first word</span><br><span class="line">    INBOX   </span><br><span class="line">    COPYTO   [22]</span><br><span class="line">    JUMPZ    f</span><br><span class="line">    BUMPUP   22</span><br><span class="line">    JUMP     e</span><br><span class="line">f: -- read in second word</span><br><span class="line">    COPYFROM 23</span><br><span class="line">    COPYTO   22</span><br><span class="line">    INBOX   </span><br><span class="line">    JUMPZ    b</span><br><span class="line">g: -- compare letters</span><br><span class="line">    COPYTO   21</span><br><span class="line">    SUB      [22]</span><br><span class="line">    JUMPZ    i -- if equal, keep going</span><br><span class="line">    JUMPN    j -- 2nd word comes first</span><br><span class="line">h: -- output first word</span><br><span class="line">    COPYFROM [22]</span><br><span class="line">    JUMPZ    l</span><br><span class="line">    OUTBOX  </span><br><span class="line">    BUMPUP   22</span><br><span class="line">    JUMP     h</span><br><span class="line">i: -- letters same. output, get next</span><br><span class="line">    COPYFROM [22]</span><br><span class="line">    OUTBOX  </span><br><span class="line">    BUMPUP   22</span><br><span class="line">    COPYFROM [22]</span><br><span class="line">    JUMPZ    m</span><br><span class="line">    INBOX   </span><br><span class="line">    JUMPZ    a</span><br><span class="line">    JUMP     g</span><br><span class="line">j: -- write out rest of 2nd word</span><br><span class="line">    COPYFROM 21</span><br><span class="line">k:</span><br><span class="line">    OUTBOX  </span><br><span class="line">    INBOX   </span><br><span class="line">    JUMPZ    d</span><br><span class="line">    JUMP     k</span><br><span class="line">l: -- throw away rest of first word</span><br><span class="line">m:</span><br><span class="line">n:</span><br><span class="line">    INBOX   </span><br><span class="line">    JUMPZ    c</span><br><span class="line">    JUMP     n</span><br></pre></td></tr></table></figure>
<p>more clearly version:</p>
<figure class="highlight plaintext"><figcaption><span>HUMAN RESOURCE MACHINE PROGRAM --</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">begin:</span><br><span class="line">    COPYFROM 23</span><br><span class="line">    COPYTO   22</span><br><span class="line">readword1: </span><br><span class="line">    INBOX   </span><br><span class="line">    COPYTO   [22]</span><br><span class="line">    JUMPZ    readword2</span><br><span class="line">    BUMPUP   22</span><br><span class="line">    JUMP     readword1</span><br><span class="line">readword2: </span><br><span class="line">    COPYFROM 23</span><br><span class="line">    COPYTO   22</span><br><span class="line">    INBOX   </span><br><span class="line">    JUMPZ    begin</span><br><span class="line">checkletters:</span><br><span class="line">    COPYTO   21</span><br><span class="line">    SUB      [22]</span><br><span class="line">    JUMPZ    nextletter</span><br><span class="line">    JUMPN    writeword2</span><br><span class="line">writeword1: </span><br><span class="line">    COPYFROM [22]</span><br><span class="line">    JUMPZ    tossword2</span><br><span class="line">    OUTBOX  </span><br><span class="line">    BUMPUP   22</span><br><span class="line">    JUMP     writeword1</span><br><span class="line">nextletter: </span><br><span class="line">    COPYFROM [22]</span><br><span class="line">    OUTBOX  </span><br><span class="line">    BUMPUP   22</span><br><span class="line">    COPYFROM [22]</span><br><span class="line">    JUMPZ    tossword2</span><br><span class="line">    INBOX   </span><br><span class="line">    JUMPZ    begin</span><br><span class="line">    JUMP     checkletters</span><br><span class="line">writeword2: </span><br><span class="line">    COPYFROM 21</span><br><span class="line">loopword2:</span><br><span class="line">    OUTBOX  </span><br><span class="line">    INBOX   </span><br><span class="line">    JUMPZ    begin</span><br><span class="line">    JUMP     loopword2</span><br><span class="line">tossword2: </span><br><span class="line">    INBOX   </span><br><span class="line">    JUMPZ    begin</span><br><span class="line">    JUMP     tossword2</span><br></pre></td></tr></table></figure>
<blockquote>
<p>– Commands: 36&#x2F;39   Steps: 75&#x2F;109  –</p>
</blockquote>
<p>PS: 略</p>
</div>

<div style="float: right; width: 50%">

<p><img src="/blog/images/human-resource-machine/36.jpg"></p>
</div>

<div style="clear: both;"></div>



<h2 id="Year-37-Scavenger-Chain"><a href="#Year-37-Scavenger-Chain" class="headerlink" title="Year 37: Scavenger Chain"></a>Year 37: Scavenger Chain</h2><div style="float: left; width: 49%">

<blockquote>
<p>– HUMAN RESOURCE MACHINE PROGRAM –</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a:</span><br><span class="line">    INBOX   </span><br><span class="line">b:</span><br><span class="line">    COPYTO   5</span><br><span class="line">    COPYFROM [5]</span><br><span class="line">    OUTBOX  </span><br><span class="line">    BUMPUP   5</span><br><span class="line">    COPYFROM [5]</span><br><span class="line">    JUMPN    a</span><br><span class="line">    JUMP     b</span><br></pre></td></tr></table></figure>
<blockquote>
<p>– Commands: 8&#x2F;8   Steps: 63&#x2F;63  –</p>
</blockquote>
<p>PS: 略</p>
</div>

<div style="float: right; width: 50%">

<p><img src="/blog/images/human-resource-machine/37.jpg"></p>
</div>

<div style="clear: both;"></div>



<h2 id="Year-38-Digit-Exploder"><a href="#Year-38-Digit-Exploder" class="headerlink" title="Year 38: Digit Exploder"></a>Year 38: Digit Exploder</h2><div style="float: left; width: 49%">

<blockquote>
<p>– HUMAN RESOURCE MACHINE PROGRAM –</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a:</span><br><span class="line">    INBOX   </span><br><span class="line">    COPYTO   1</span><br><span class="line">    COPYFROM 9</span><br><span class="line">    COPYTO   3</span><br><span class="line">    COPYTO   4</span><br><span class="line">b:</span><br><span class="line">    COPYFROM 1</span><br><span class="line">    SUB      11</span><br><span class="line">    JUMPN    c</span><br><span class="line">    COPYTO   1</span><br><span class="line">    BUMPUP   3</span><br><span class="line">    JUMP     b</span><br><span class="line">c:</span><br><span class="line">    COPYFROM 3</span><br><span class="line">    JUMPZ    d</span><br><span class="line">    OUTBOX  </span><br><span class="line">d:</span><br><span class="line">e:</span><br><span class="line">    COPYFROM 1</span><br><span class="line">    SUB      10</span><br><span class="line">    JUMPN    f</span><br><span class="line">    COPYTO   1</span><br><span class="line">    BUMPUP   4</span><br><span class="line">    JUMP     e</span><br><span class="line">f:</span><br><span class="line">    COPYFROM 4</span><br><span class="line">    JUMPZ    i</span><br><span class="line">g:</span><br><span class="line">    OUTBOX  </span><br><span class="line">h:</span><br><span class="line">    COPYFROM 1</span><br><span class="line">    OUTBOX  </span><br><span class="line">    JUMP     a</span><br><span class="line">i:</span><br><span class="line">    COPYFROM 3</span><br><span class="line">    JUMPZ    h</span><br><span class="line">    COPYFROM 4</span><br><span class="line">    JUMP     g</span><br></pre></td></tr></table></figure>
<blockquote>
<p>– Commands: 30&#x2F;30   Steps: 214&#x2F;165  –</p>
</blockquote>
<p>PS: 略</p>
</div>

<div style="float: right; width: 50%">

<p><img src="/blog/images/human-resource-machine/38.jpg"></p>
</div>

<div style="clear: both;"></div>



<h2 id="Year-39-Re-Coordinator"><a href="#Year-39-Re-Coordinator" class="headerlink" title="Year 39: Re-Coordinator"></a>Year 39: Re-Coordinator</h2><div style="float: left; width: 49%">

<blockquote>
<p>– HUMAN RESOURCE MACHINE PROGRAM –</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a:</span><br><span class="line">    COPYFROM 14</span><br><span class="line">    COPYTO   0</span><br><span class="line">    INBOX   </span><br><span class="line">b:</span><br><span class="line">    SUB      15</span><br><span class="line">    JUMPN    c</span><br><span class="line">    COPYTO   1</span><br><span class="line">    BUMPUP   0</span><br><span class="line">    COPYFROM 1</span><br><span class="line">    JUMP     b</span><br><span class="line">c:</span><br><span class="line">    ADD      15</span><br><span class="line">    OUTBOX  </span><br><span class="line">    COPYFROM 0</span><br><span class="line">    OUTBOX  </span><br><span class="line">    JUMP     a</span><br></pre></td></tr></table></figure>
<blockquote>
<p>– Commands: 14&#x2F;14   Steps: 76&#x2F;76  –</p>
</blockquote>
<p>PS: 略</p>
</div>

<div style="float: right; width: 50%">

<p><img src="/blog/images/human-resource-machine/39.jpg"></p>
</div>

<div style="clear: both;"></div>



<h2 id="Year-40-Prime-Factory"><a href="#Year-40-Prime-Factory" class="headerlink" title="Year 40: Prime Factory"></a>Year 40: Prime Factory</h2><div style="float: left; width: 49%">

<blockquote>
<p>– HUMAN RESOURCE MACHINE PROGRAM –</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    COPYFROM 24</span><br><span class="line">    COPYTO   23</span><br><span class="line">    BUMPUP   23</span><br><span class="line">a:</span><br><span class="line">    INBOX   </span><br><span class="line">    COPYTO   0</span><br><span class="line">    COPYFROM 23</span><br><span class="line">    COPYTO   3</span><br><span class="line">b:</span><br><span class="line">    BUMPUP   3</span><br><span class="line">    COPYFROM 24</span><br><span class="line">    COPYTO   2</span><br><span class="line">    COPYFROM 0</span><br><span class="line">c:</span><br><span class="line">d:</span><br><span class="line">    SUB      3</span><br><span class="line">    COPYTO   1</span><br><span class="line">    JUMPN    b</span><br><span class="line">    JUMPZ    e</span><br><span class="line">    BUMPUP   2</span><br><span class="line">    COPYFROM 1</span><br><span class="line">    JUMP     d</span><br><span class="line">e:</span><br><span class="line">    COPYFROM 3</span><br><span class="line">    OUTBOX  </span><br><span class="line">    COPYFROM 2</span><br><span class="line">    JUMPZ    a</span><br><span class="line">    COPYTO   0</span><br><span class="line">    COPYFROM 24</span><br><span class="line">    COPYTO   2</span><br><span class="line">    BUMPUP   0</span><br><span class="line">    JUMP     c</span><br></pre></td></tr></table></figure>
<blockquote>
<p>– Commands: 27&#x2F;28   Steps: 426&#x2F;399  –</p>
</blockquote>
<p>PS: 略</p>
</div>

<div style="float: right; width: 50%">

<p><img src="/blog/images/human-resource-machine/40.jpg"></p>
</div>

<div style="clear: both;"></div>



<h2 id="Year-41-Sorting-Floor"><a href="#Year-41-Sorting-Floor" class="headerlink" title="Year 41: Sorting Floor"></a>Year 41: Sorting Floor</h2><div style="float: left; width: 49%">

<blockquote>
<p>– HUMAN RESOURCE MACHINE PROGRAM –</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a:</span><br><span class="line">b:</span><br><span class="line">    BUMPUP   24</span><br><span class="line">    INBOX   </span><br><span class="line">    JUMPZ    d</span><br><span class="line">    COPYTO   [24]</span><br><span class="line">    JUMP     b</span><br><span class="line">c:</span><br><span class="line">    COPYFROM [21]</span><br><span class="line">    OUTBOX  </span><br><span class="line">    COPYFROM [24]</span><br><span class="line">    COPYTO   [21]</span><br><span class="line">d:</span><br><span class="line">    BUMPDN   24</span><br><span class="line">    JUMPZ    a</span><br><span class="line">    COPYTO   21</span><br><span class="line">    COPYTO   22</span><br><span class="line">e:</span><br><span class="line">f:</span><br><span class="line">    BUMPDN   22</span><br><span class="line">    JUMPZ    c</span><br><span class="line">    COPYFROM [21]</span><br><span class="line">    SUB      [22]</span><br><span class="line">    JUMPN    f</span><br><span class="line">    COPYFROM 22</span><br><span class="line">    COPYTO   21</span><br><span class="line">    JUMP     e</span><br></pre></td></tr></table></figure>
<blockquote>
<p>– Commands: 21&#x2F;34   Steps: 648&#x2F;714  –</p>
</blockquote>
<p>PS: 略</p>
</div>

<div style="float: right; width: 50%">

<p><img src="/blog/images/human-resource-machine/41.jpg"></p>
</div>

<div style="clear: both;"></div>



<h2 id="Year-42-End-Program-Congratulations"><a href="#Year-42-End-Program-Congratulations" class="headerlink" title="Year 42: End Program. Congratulations."></a>Year 42: End Program. Congratulations.</h2><div style="float: right; width: 100%">

<p><img src="/blog/images/human-resource-machine/42.jpg"></p>
</div>

<div style="clear: both;"></div>]]></content>
      <categories>
        <category>Games</category>
      </categories>
  </entry>
  <entry>
    <title>C/C++项目构建教程</title>
    <url>/blog/cpp-project-build-tutorial/</url>
    <content><![CDATA[<div class="note info">

<ul>
<li>构建工具有助于管理和简化构建过程，自动化的构建程序，多用于大型和复杂的项目中。</li>
<li>本文介绍Makefile、CMake、XMake等构建工具。</li>
<li>本文将以C&#x2F;C++的源码作为基础，所以必然涉及一些关于C&#x2F;C++的编译的知识，关于这方面的内容，还请各位<a href="https://www.bilibili.com/video/BV1TN4y1375q">自行学习</a>。😘</li>
</ul>
</div>

<span id="more"></span>

<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li>运行大型项目需要确定不同代码模块或库文件如何编译链接在一起，这需要开发者用项目构建工具来实现。</li>
<li>本文所述构建工具，如Makefile、CMake、XMake等，是为了简化编译和链接过程，以下是使用它们的一些主要原因：<ul>
<li>自动化：构建工具可以自动执行编译、链接和其他构建步骤，无需手动运行每个步骤。</li>
<li>依赖管理：构建工具可以跟踪源文件之间的依赖关系，并确保在源文件更改时只重新编译必要的文件。</li>
<li>跨平台：构建工具可以生成针对不同平台和编译器的构建文件，使得源代码可以在不同的环境中构建。</li>
<li>可扩展：对于大型项目，构建工具可以帮助组织和管理多个源文件和库，使得构建过程更加可控。</li>
<li>一致性：构建工具可以确保每次构建的过程都是一致的，无论是在哪个平台或环境中。</li>
<li>集成其他工具：构建工具可以与其他工具集成，如测试框架、包管理器等，提供更完整的构建解决方案。</li>
</ul>
</li>
</ul>
<h2 id="Make"><a href="#Make" class="headerlink" title="Make"></a>Make</h2><h3 id="Makefile是什么"><a href="#Makefile是什么" class="headerlink" title="Makefile是什么"></a>Makefile是什么</h3><ul>
<li>Make: 是最早的构建工具之一，它使用Makefile来描述如何构建你的项目。</li>
<li>Makefile文件按照特定语法进行编写，用以说明<strong>如何编译各个源文件</strong>并<strong>链接生成可执行文件</strong>，同时<strong>定义了源文件之间的依赖关系</strong>。</li>
<li>尽管Makefile的语法可能有些复杂，但它在C++社区中仍然广泛使用。</li>
</ul>
<h3 id="Makefile工作流程"><a href="#Makefile工作流程" class="headerlink" title="Makefile工作流程"></a>Makefile工作流程</h3><pre><code>1.查找当前目录下的Makefile文件  
2.初始化文件中的变量  
3.分析Makefile中的所有规则  
4.为所有的目标文件创建依赖关系  
5.根据依赖关系，决定哪些目标文件要重新生成  
6.执行生成命令
</code></pre>
<h3 id="Makefile书写规范"><a href="#Makefile书写规范" class="headerlink" title="Makefile书写规范"></a>Makefile书写规范</h3><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">目标文件：依赖文件列表</span><br><span class="line">  &lt;Tab&gt;  命令列表</span><br></pre></td></tr></table></figure>

<p><code>目标文件(target)</code>即为最终的可执行文件<code>test</code>(可自定义名称)<br>中间目标文件test1.o test2.o<br>每个目标文件和它的依赖文件用：隔开<br>每个.o文件都有一组依赖文件</p>
<p>调用make命令可输入：<code>make target</code></p>
<p>如果省略<code>target</code>，make就将生成Makefile文件中定义的第一个目标</p>
<h3 id="Makefile中的变量"><a href="#Makefile中的变量" class="headerlink" title="Makefile中的变量"></a>Makefile中的变量</h3><p>Linux下的Makefile文件里面可能会使用非常多的变量，远不像前面示例Makefile文件那样简单。这些变量对大小写敏感，一般使用<strong>大写宇母</strong>。</p>
<p>定义变量的语法：<code>VARNAME=string</code></p>
<p>使用时，把变量用括号括起来，并在前面加上<code>$</code>符号，就可以引用变量的值：<code>$(VARNAME)</code></p>
<p>Makefile中的变量分为</p>
<ul>
<li>用户自定义变量</li>
<li>预定义变量</li>
<li>自动变量</li>
<li>环境变量</li>
</ul>
<h3 id="Makefile中的隐含规则"><a href="#Makefile中的隐含规则" class="headerlink" title="Makefile中的隐含规则"></a>Makefile中的隐含规则</h3><p>一些默认的动作，称作隐含规则的内置的规则，这些规则告诉make当用户没有完整地给出某些命令的时候，应该怎样执行。</p>
<p>在我们使用Makefile时，有一些我们会经常使用，而且使用频率非常高的东西，比如，我们编译C&#x2F;C++的源程序为中间目标文件（Unix下是[.o]文件，Windows下是[.obj]文件）。这里讲述的就是一些在Makefile中的“隐含的”，早先约定了的，不需要我们再写出来的规则。</p>
<p>“隐含规则”也就是一种惯例，make会按照这种“惯例”心照不喧地来运行，那怕我们的Makefile中没有书写这样的规则。例如，把[.c]文件编译成[.o]文件这一规则，你根本就不用写出来，make会自动推导出这种规则，并生成我们需要的[.o]文件。</p>
<h3 id="Makefile的编写实例"><a href="#Makefile的编写实例" class="headerlink" title="Makefile的编写实例"></a>Makefile的编写实例</h3><p>现在有一个c程序，实现输入姓名，输入hello+用户的输入</p>
<p>共有以下文件：input.h input.c output.h output.c main.c</p>
<p>Makefile的编写如下</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">main:input.o output.o main.o</span></span><br><span class="line">    gcc -Wall -O -g -o main main.o input.o output.o</span><br><span class="line"><span class="section">input.o:input.c input.h</span></span><br><span class="line">    gcc -Wall -O -g -o input.o input.c</span><br><span class="line"><span class="section">output.o:output.c output.h</span></span><br><span class="line">    gcc -Wall -O -g -o output.o output.c</span><br><span class="line"><span class="section">main.o:main.c input.h output.h</span></span><br><span class="line">    gcc -Wall -O -g -o main.o main.c</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -rf test *.o</span><br></pre></td></tr></table></figure>

<h3 id="Makefile的简化"><a href="#Makefile的简化" class="headerlink" title="Makefile的简化"></a>Makefile的简化</h3><p>通过上面的代码我们可以发现，我们在编写Makefile文件的时候有大量重复语句，可以通过<code>自定义变量</code>、<code>自动变量</code>、<code>隐含规则</code>等方式简化</p>
<p>第一次优化：<code>自定义变量</code></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">CC=gcc</span><br><span class="line">CFLAGS=-Wall -O -g</span><br><span class="line">OBJ=input.o output.o main.o</span><br><span class="line"></span><br><span class="line"><span class="section">main:<span class="variable">$(OBJ)</span></span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -o main main.o input.o output.o</span><br><span class="line"><span class="section">input.o:input.c input.h</span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -o input.o input.c</span><br><span class="line"><span class="section">output.o:output.c output.h</span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -o output.o output.c</span><br><span class="line"><span class="section">main.o:main.c input.h output.h</span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -o main.o main.c</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -rf test *.o</span><br></pre></td></tr></table></figure>

<p>通过<code>自定义变量</code>，我们将原本冗长的语句进行缩短</p>
<p>第二次优化：<code>自动变量</code></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">CC=gcc</span><br><span class="line">CFLAGS=-Wall -O -g</span><br><span class="line">OBJ=input.o output.o main.o</span><br><span class="line"></span><br><span class="line"><span class="section">main:<span class="variable">$(OBJ)</span></span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"><span class="section">input.o:input.c input.h</span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"><span class="section">output.o:output.c output.h</span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"><span class="section">main.o:main.c input.h output.h</span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -rf test *.o</span><br></pre></td></tr></table></figure>

<p>第三次优化：<code>隐含规则</code></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">CC=gcc</span><br><span class="line">CFLAGS=-Wall -O -g</span><br><span class="line">OBJ=input.o output.o m</span><br><span class="line"></span><br><span class="line"><span class="section">main:<span class="variable">$(OBJ)</span></span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -rf test *.o</span><br></pre></td></tr></table></figure>

<h2 id="CMake"><a href="#CMake" class="headerlink" title="CMake"></a>CMake</h2><blockquote>
<p>TBD……</p>
</blockquote>
<h2 id="XMake"><a href="#XMake" class="headerlink" title="XMake"></a>XMake</h2><blockquote>
<p>TBD……</p>
</blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://www.gnu.org/software/make/manual/make.html">GNU Make Manual</a></li>
<li><a href="https://www.bilibili.com/video/BV188411L7d2">Makefile 20分钟入门，简简单单，展示如何使用Makefile管理和编译C++代码</a></li>
<li><a href="https://www.bilibili.com/video/BV1bg411p7oS">CMake 6分钟入门，不用再写复杂的Makefile</a></li>
</ul>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
  </entry>
  <entry>
    <title>GoogleTest 快速入门</title>
    <url>/blog/gtest-tutorial/</url>
    <content><![CDATA[<div class="note info">

<ul>
<li>在项目中使用 GTest 编写单测以保证代码质量是必要的，通过构造各种单元测试的case，可以测试功能是否正确，发现肉眼不容易发现的bug。</li>
<li><a href="https://github.com/google/googletest">GTest</a> 是 Google 发布的一款非常优秀的开源 C&#x2F;C++ 单元测试框架，它简单易用，功能完善，已被应用于多个开源项目及Google内部项目中：<a href="https://www.chromium.org/">ChromeWeb浏览器</a>、<a href="https://llvm.org/">LLVM编译器</a>、<a href="https://github.com/google/protobuf">ProtocolBuffers数据交换格式</a>等。</li>
<li>本文分享 GTest 的核心用法、常用技巧以及单测编写的思路，包含最必要、最常用的内容，能覆盖大部分场景的单测需求，同时会引用外部文档供扩展阅读。</li>
</ul>
</div>

<span id="more"></span>

<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>官方传送门：<a href="https://github.com/google/googletest">GoogleTest - Google Testing and Mocking Framework</a><br>现在官方已经把 GoogleTest 和 GoogleMock 一起维护，所以这个 git 仓库还包含了 GoogleMock。</p>
<h3 id="GitHub-源码仓库安装"><a href="#GitHub-源码仓库安装" class="headerlink" title="GitHub 源码仓库安装"></a>GitHub 源码仓库安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  ~ wget https://github.com/google/googletest/archive/refs/tags/v1.14.0.tar.gz</span><br><span class="line">➜  ~ tar xf v1.14.0.tar.gz</span><br><span class="line">➜  ~ cd googletest-1.14.0</span><br><span class="line">➜  googletest-1.14.0 cmake -DBUILD_SHARED_LIBS=ON .</span><br><span class="line">➜  googletest-1.14.0 make</span><br><span class="line">➜  googletest-1.14.0 sudo cp -a googletest/include /usr/include</span><br><span class="line">➜  googletest-1.14.0 sudo cp -a lib/libgtest_main.so lib/libgtest.so /usr/lib/</span><br></pre></td></tr></table></figure>

<p>这样就 OK 了，可以用 <code>sudo ldconfig -v | grep gtest</code> 检查，看到下面就 OK 了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">libgtest.so -&gt; libgtest.so</span><br><span class="line">libgtest_main.so -&gt; libgtest_main.so</span><br></pre></td></tr></table></figure>

<h3 id="Ubuntu-apt-源码安装"><a href="#Ubuntu-apt-源码安装" class="headerlink" title="Ubuntu apt 源码安装"></a>Ubuntu apt 源码安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  ~ sudo apt-get install libgtest-dev</span><br><span class="line">➜  ~ cd /usr/src/gtest</span><br><span class="line">➜  gtest sudo cmake CMakeLists.txt</span><br><span class="line">➜  gtest sudo make</span><br><span class="line">➜  gtest sudo cp *.a /usr/lib</span><br></pre></td></tr></table></figure>
<p>上述步骤OK后就可以使用<code>-lgtest</code>选项编译测试代码了。</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="Test-Suite"><a href="#Test-Suite" class="headerlink" title="Test Suite"></a>Test Suite</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">TEST</span>(TestSuiteName, TestCaseName) &#123;</span><br><span class="line">    <span class="comment">// 单测代码</span></span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(<span class="built_in">func</span>(<span class="number">0</span>), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>TestSuiteName</code> 用来汇总 test case，相关的 test case 应该是相同的 <code>TestSuiteName</code>。一个文件里只能有一个 <code>TestSuiteName</code>，建议命名为这个文件测试的类名。</li>
<li><code>TestCaseName</code> 是测试用例的名称。建议有意义，比如“被测试的函数名称”，或者被测试的函数名的不同输入的情况。</li>
<li><code>TestSuiteName_TestCaseName</code> 的组合应该是唯一的。</li>
<li>GTest 生成的类名是带下划线的，所以上面这些名字里不建议有下划线。</li>
</ul>
<h3 id="Test-Case"><a href="#Test-Case" class="headerlink" title="Test Case"></a>Test Case</h3><p>一个 <code>TEST(Foo, Bar)&#123;...&#125;</code> 就是一个 Test Case。考虑到构造输入有成本，通常一个 <code>TEST(Foo, Bar)</code> 里会反复修改输入，构造多个 case，测试不同的执行流程。这里建议<strong>用大括号分隔不同的 case</strong>，整体更条理。另一个好处在于：<strong>每个变量的生命周期仅限于大括号内</strong>。这样就可以反复使用相同的变量名，而不用给变量名编号。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">TEST</span>(Foo, bar) &#123;</span><br><span class="line">    <span class="comment">// case 1: enable = true</span></span><br><span class="line">    &#123;</span><br><span class="line">        Context ctx;</span><br><span class="line">        params.enable_refresh = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">ASSERT_EQ</span>(ctx-&gt;<span class="built_in">is_enable_fresh</span>(), <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// case 2: enable = false</span></span><br><span class="line">    &#123;</span><br><span class="line">        Context ctx;</span><br><span class="line">        params.enable_refresh = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">ASSERT_EQ</span>(ctx-&gt;<span class="built_in">is_enable_fresh</span>(), <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果待测函数十分复杂，建议拆分多个 <code>TEST(Foo, Bar)&#123;...&#125;</code>，避免 Test Case 代码膨胀。比如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 待测函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">(TarAddr ta)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!ta)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">switch</span>(ta.did) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x193b</span>:</span><br><span class="line">            ...</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x1204</span>:</span><br><span class="line">            ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(Foo, IsNil) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(Foo, <span class="number">0x193b</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(Foo, <span class="number">0x1204</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>官方 WIKI：<a href="https://github.com/google/googletest/blob/master/googletest/docs/Primer.md">GTest</a></p>
<h3 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h3><p>GTest 使用一系列<a href="http://google.github.io/googletest/reference/assertions.html">断言</a>的宏来检查返回值是否符合预期、是否抛出预期的异常等。主要分为两类：<code>ASSERT</code> 和 <code>EXPECT</code>。区别在于 ASSERT 不通过的时候会认为是一个 fatal 的错误，退出当前函数（只是函数）。而 EXPECT 失败的话会继续运行当前函数，所以对于函数内几个失败可以同时报告出来。</p>
<p>通常我们用 EXPECT 级别的断言就好，除非你认为当前检查点失败后函数的后续检查没有意义:</p>
<ul>
<li>如果某个判断不通过时，会影响后续步骤，要使用 ASSERT。常见的是空指针，或者数组访问越界。</li>
<li>其他情况，可以使用 EXPECT，尽可能多测试几个用例。</li>
</ul>
<h4 id="基础的断言"><a href="#基础的断言" class="headerlink" title="基础的断言"></a>基础的断言</h4><table>
<thead>
<tr>
<th align="left"><strong>Fatal assertion</strong></th>
<th align="left"><strong>Nonfatal assertion</strong></th>
<th align="left"><strong>Verifies</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>ASSERT_TRUE(_condition_)</code>;</td>
<td align="left"><code>EXPECT_TRUE(_condition_)</code>;</td>
<td align="left"><em>condition</em> is true</td>
</tr>
<tr>
<td align="left"><code>ASSERT_FALSE(_condition_)</code>;</td>
<td align="left"><code>EXPECT_FALSE(_condition_)</code>;</td>
<td align="left"><em>condition</em> is false</td>
</tr>
</tbody></table>
<h4 id="数值比较"><a href="#数值比较" class="headerlink" title="数值比较"></a>数值比较</h4><table>
<thead>
<tr>
<th align="left"><strong>Fatal assertion</strong></th>
<th align="left"><strong>Nonfatal assertion</strong></th>
<th align="left"><strong>Verifies</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>ASSERT_EQ(_val1_, _val2_);</code></td>
<td align="left"><code>EXPECT_EQ(_val1_, _val2_);</code></td>
<td align="left"><em>val1</em> <code>==</code> <em>val2</em></td>
</tr>
<tr>
<td align="left"><code>ASSERT_NE(_val1_, _val2_);</code></td>
<td align="left"><code>EXPECT_NE(_val1_, _val2_);</code></td>
<td align="left"><em>val1</em> <code>!=</code> <em>val2</em></td>
</tr>
<tr>
<td align="left"><code>ASSERT_LT(_val1_, _val2_);</code></td>
<td align="left"><code>EXPECT_LT(_val1_, _val2_);</code></td>
<td align="left"><em>val1</em> <code>&lt;</code> <em>val2</em></td>
</tr>
<tr>
<td align="left"><code>ASSERT_LE(_val1_, _val2_);</code></td>
<td align="left"><code>EXPECT_LE(_val1_, _val2_);</code></td>
<td align="left"><em>val1</em> <code>&lt;=</code> <em>val2</em></td>
</tr>
<tr>
<td align="left"><code>ASSERT_GT(_val1_, _val2_);</code></td>
<td align="left"><code>EXPECT_GT(_val1_, _val2_);</code></td>
<td align="left"><em>val1</em> <code>&gt;</code> <em>val2</em></td>
</tr>
<tr>
<td align="left"><code>ASSERT_GE(_val1_, _val2_);</code></td>
<td align="left"><code>EXPECT_GE(_val1_, _val2_);</code></td>
<td align="left"><em>val1</em> <code>&gt;=</code> <em>val2</em></td>
</tr>
</tbody></table>
<h4 id="浮点数比较"><a href="#浮点数比较" class="headerlink" title="浮点数比较"></a>浮点数比较</h4><table>
<thead>
<tr>
<th align="left"><strong>Fatal assertion</strong></th>
<th align="left"><strong>Nonfatal assertion</strong></th>
<th align="left"><strong>Verifies</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>ASSERT_FLOAT_EQ(_val1_, _val2_);</code></td>
<td align="left"><code>EXPECT_FLOAT_EQ(_val1_, _val2_);</code></td>
<td align="left"><em>val1</em> &#x3D;&#x3D; <em>val2</em> (within 4 ULPs)</td>
</tr>
<tr>
<td align="left"><code>ASSERT_DOUBLE_EQ(_val1_, _val2_);</code></td>
<td align="left"><code>EXPECT_DOUBLE_EQ(_val1_, _val2_);</code></td>
<td align="left"><em>val1</em> &#x3D;&#x3D; <em>val2</em> (within 4 ULPs)</td>
</tr>
<tr>
<td align="left"><code>ASSERT_NEAR(_val1_, _val2_, _abs_error_);</code></td>
<td align="left"><code>EXPECT_NEAR(_val1_, _val2_, _abs_error_);</code></td>
<td align="left">判断两个数字的绝对值相差是否小于等于 abs_val</td>
</tr>
</tbody></table>
<h4 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h4><table>
<thead>
<tr>
<th align="left"><strong>Fatal assertion</strong></th>
<th align="left"><strong>Nonfatal assertion</strong></th>
<th align="left"><strong>Verifies</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>ASSERT_STREQ(_str1_, _str2_);</code></td>
<td align="left"><code>EXPECT_STREQ(_str1_, _str_2);</code></td>
<td align="left">the two C strings have the same content</td>
</tr>
<tr>
<td align="left"><code>ASSERT_STRNE(_str1_, _str2_);</code></td>
<td align="left"><code>EXPECT_STRNE(_str1_, _str2_);</code></td>
<td align="left">the two C strings have different content</td>
</tr>
<tr>
<td align="left"><code>ASSERT_STRCASEEQ(_str1_, _str2_);</code></td>
<td align="left"><code>EXPECT_STRCASEEQ(_str1_, _str2_);</code></td>
<td align="left">the two C strings have the same content, ignoring case</td>
</tr>
<tr>
<td align="left"><code>ASSERT_STRCASENE(_str1_, _str2_);</code></td>
<td align="left"><code>EXPECT_STRCASENE(_str1_, _str2_);</code></td>
<td align="left">the two C strings have different content, ignoring case</td>
</tr>
</tbody></table>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>创建一个简单的C++类，例如<code>MyClass</code>:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MyClass.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Subtract</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a - b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>创建一个测试文件，例如<code>MyClassTest.cpp</code>:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MyClassTest.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyClass.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gtest/gtest.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(MyClassTest, AddTest) &#123;</span><br><span class="line">    MyClass my_class;</span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(my_class.<span class="built_in">Add</span>(<span class="number">1</span>, <span class="number">2</span>), <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(my_class.<span class="built_in">Add</span>(<span class="number">1</span>, <span class="number">1</span>), <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(MyClassTest, SubtractTest) &#123;</span><br><span class="line">    MyClass my_class;</span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(my_class.<span class="built_in">Subtract</span>(<span class="number">1</span>, <span class="number">2</span>), <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(my_class.<span class="built_in">Subtract</span>(<span class="number">1</span>, <span class="number">1</span>), <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    ::testing::<span class="built_in">InitGoogleTest</span>(&amp;argc, argv);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">RUN_ALL_TESTS</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译运行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  cd demo</span><br><span class="line">➜  demo g++ -std=c++11 -pthread MyClassTest.cpp -lgtest -o MyClassTest</span><br><span class="line">➜  demo ./MyClassTest</span><br><span class="line">[==========] Running 2 tests from 1 test suite.</span><br><span class="line">[----------] Global test environment set-up.</span><br><span class="line">[----------] 2 tests from MyClassTest</span><br><span class="line">[ RUN      ] MyClassTest.AddTest</span><br><span class="line">MyClassTest.cpp:7: Failure</span><br><span class="line">Expected equality of these values:</span><br><span class="line">  my_class.Add(1, 1)</span><br><span class="line">    Which is: 2</span><br><span class="line">  3</span><br><span class="line">[  FAILED  ] MyClassTest.AddTest (0 ms)</span><br><span class="line">[ RUN      ] MyClassTest.SubtractTest</span><br><span class="line">MyClassTest.cpp:13: Failure</span><br><span class="line">Expected equality of these values:</span><br><span class="line">  my_class.Subtract(1, 1)</span><br><span class="line">    Which is: 0</span><br><span class="line">  3</span><br><span class="line">[  FAILED  ] MyClassTest.SubtractTest (0 ms)</span><br><span class="line">[----------] 2 tests from MyClassTest (0 ms total)</span><br><span class="line"></span><br><span class="line">[----------] Global test environment tear-down</span><br><span class="line">[==========] 2 tests from 1 test suite ran. (0 ms total)</span><br><span class="line">[  PASSED  ] 0 tests.</span><br><span class="line">[  FAILED  ] 2 tests, listed below:</span><br><span class="line">[  FAILED  ] MyClassTest.AddTest</span><br><span class="line">[  FAILED  ] MyClassTest.SubtractTest</span><br><span class="line"></span><br><span class="line"> 2 FAILED TESTS</span><br></pre></td></tr></table></figure>

<h2 id="编写规范"><a href="#编写规范" class="headerlink" title="编写规范"></a>编写规范</h2><div class="note info"><p>💡 单测代码也需要经过 Code Review。单测代码和线上代码同等重要。</p></div>

<h3 id="目录结构、文件与命名规范"><a href="#目录结构、文件与命名规范" class="headerlink" title="目录结构、文件与命名规范"></a>目录结构、文件与命名规范</h3><h4 id="单测的目录结构，要和源码的目录结构一致"><a href="#单测的目录结构，要和源码的目录结构一致" class="headerlink" title="单测的目录结构，要和源码的目录结构一致"></a>单测的目录结构，要和源码的目录结构一致</h4><p>单测文件的路径名，等价于源码的文件名加上 <code>_test</code> 后缀。</p>
<p>目的在于：让写单测的人能很快定位是否已经有这个文件或这个类的单测，让新增代码更聚合，避免写重复单测。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line">src/</span><br><span class="line">  common/</span><br><span class="line">    item_data.cpp</span><br><span class="line">  frame/</span><br><span class="line">    request_context.cpp</span><br><span class="line">unittest/</span><br><span class="line">  item_data_test.cpp</span><br><span class="line">  request_context_test.cpp</span><br><span class="line">  </span><br><span class="line"><span class="comment">// good</span></span><br><span class="line">src/</span><br><span class="line">  common/</span><br><span class="line">    item_data.cpp</span><br><span class="line">  frame/</span><br><span class="line">    request_context.cpp</span><br><span class="line">unittest/</span><br><span class="line">  common/</span><br><span class="line">    item_data_test.cpp</span><br><span class="line">  frame/</span><br><span class="line">    request_context_test.cpp</span><br></pre></td></tr></table></figure>

<h4 id="TestSuite、TestCase-命名规范"><a href="#TestSuite、TestCase-命名规范" class="headerlink" title="TestSuite、TestCase 命名规范"></a>TestSuite、TestCase 命名规范</h4><p>TestSuite 建议命名为被测试的类名加上 <code>Test</code> 后缀：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="built_in">TEST</span>(MyTest, foo) &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="built_in">TEST</span>(RequestContextTest, foo) &#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>TestCase 建议命名为被测试的函数名，不要随意起名，也不需要增加不必要的前缀：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line">TEST(RequestContextTest<span class="punctuation">,</span> test_uav) <span class="punctuation">&#123;</span></span><br><span class="line">    ASSERT_EQ(ctx-&gt;init_uav_to_group_bid()<span class="punctuation">,</span> <span class="number">1</span>);</span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line">TEST(RequestContextTest<span class="punctuation">,</span> init_uav_to_group_bid) <span class="punctuation">&#123;</span></span><br><span class="line">    ASSERT_EQ(ctx-&gt;init_uav_to_group_bid()<span class="punctuation">,</span> <span class="number">1</span>);</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>GTest 生成的类名是带下划线的，所以上面这些名字建议用驼峰形式。</p>
<h3 id="单元测试代码编写规范"><a href="#单元测试代码编写规范" class="headerlink" title="单元测试代码编写规范"></a>单元测试代码编写规范</h3><h4 id="不要用-std-cout-输出变量值，改为用-ASSERT-x2F-EXPECT-检查"><a href="#不要用-std-cout-输出变量值，改为用-ASSERT-x2F-EXPECT-检查" class="headerlink" title="不要用 std::cout 输出变量值，改为用 ASSERT &#x2F; EXPECT 检查"></a>不要用 std::cout 输出变量值，改为用 <code>ASSERT</code> &#x2F; <code>EXPECT</code> 检查</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad </span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;ads_size = &quot;</span> &lt;&lt; rsp.ads.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line"><span class="built_in">EXPECT_EQ</span>(rsp.ads.<span class="built_in">size</span>(), <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="built_in">EXPECT_EQ</span>(rsp.<span class="built_in">size</span>(), <span class="number">1</span>); <span class="comment">// 这一行在检测失败时，会打印 rsp.size() 的值</span></span><br><span class="line"><span class="built_in">EXPECT_EQ</span>(rsp.<span class="built_in">size</span>(), <span class="number">1</span>) &lt;&lt; rsp.ads.<span class="built_in">debug_string</span>() &lt;&lt; std::endl;  <span class="comment">// 可以在检测失败时，打印更多 debug 日志</span></span><br></pre></td></tr></table></figure>

<h4 id="不要直接写数值，要写清楚这个数字是怎么算的"><a href="#不要直接写数值，要写清楚这个数字是怎么算的" class="headerlink" title="不要直接写数值，要写清楚这个数字是怎么算的"></a>不要直接写数值，要写清楚这个数字是怎么算的</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line">params.alpha = <span class="number">2</span>;</span><br><span class="line">params.beta = <span class="number">2.5</span>;</span><br><span class="line"><span class="built_in">ASSERT_EQ</span>(params.<span class="built_in">get_score</span>(), <span class="number">2965</span>); <span class="comment">// 这 2965 咋算的？</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line">params.alpha = <span class="number">2</span>;</span><br><span class="line">params.beta = <span class="number">2.5</span>;</span><br><span class="line"><span class="built_in">ASSERT_EQ</span>(params.<span class="built_in">get_score</span>(), <span class="number">2</span> * <span class="number">2.5</span> * <span class="number">593</span>); <span class="comment">// alpha * beta * ctx.bid</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// good: 把变量名直接注释在字面量后面</span></span><br><span class="line"><span class="built_in">ASSERT_EQ</span>(params.<span class="built_in">get_score</span>(), <span class="number">2</span> <span class="comment">/* alpha */</span> * <span class="number">2.5</span> <span class="comment">/* beta */</span> * <span class="number">593</span> <span class="comment">/* ctx.bid */</span>);</span><br></pre></td></tr></table></figure>

<h4 id="使用大括号分隔、缩进不同的-Test-Case"><a href="#使用大括号分隔、缩进不同的-Test-Case" class="headerlink" title="使用大括号分隔、缩进不同的 Test Case"></a>使用大括号分隔、缩进不同的 Test Case</h4><p>一个 <code>TEST(Foo, Bar)&#123;...&#125;</code> 就是一个 Test Case。考虑到构造输入有成本，通常一个 <code>TEST(Foo, Bar)</code> 里会反复修改输入，构造多个 case，测试不同的执行流程。这里建议<strong>用大括号分隔不同的 case</strong>，整体更条理。另一个好处在于：<strong>每个变量的生命周期仅限于大括号内</strong>。这样就可以反复使用相同的变量名，而不用给变量名编号。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="built_in">TEST</span>(Foo, bar) &#123;</span><br><span class="line">    Context ctx1;</span><br><span class="line">    params.enable_refresh = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">ASSERT_EQ</span>(ctx1-&gt;<span class="built_in">is_enable_fresh</span>(), <span class="literal">true</span>);</span><br><span class="line">    </span><br><span class="line">    Context ctx2;</span><br><span class="line">    params.enable_refresh = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">ASSERT_EQ</span>(ctx2-&gt;<span class="built_in">is_enable_fresh</span>(), <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="built_in">TEST</span>(Foo, bar) &#123;</span><br><span class="line">    <span class="comment">// case 1: enable = true</span></span><br><span class="line">    &#123;</span><br><span class="line">        Context ctx;</span><br><span class="line">        params.enable_refresh = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">ASSERT_EQ</span>(ctx-&gt;<span class="built_in">is_enable_fresh</span>(), <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// case 2: enable = false</span></span><br><span class="line">    &#123;</span><br><span class="line">        Context ctx;</span><br><span class="line">        params.enable_refresh = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">ASSERT_EQ</span>(ctx-&gt;<span class="built_in">is_enable_fresh</span>(), <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="为单测补充详细的注释"><a href="#为单测补充详细的注释" class="headerlink" title="为单测补充详细的注释"></a>为单测补充详细的注释</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line">req.type = Type::foo;</span><br><span class="line">req.from = <span class="string">&quot;localhost&quot;</span>;</span><br><span class="line"><span class="built_in">EXPECT_EQ</span>(ctx.<span class="built_in">get_value</span>(), <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// good：补充注释</span></span><br><span class="line">req.type = Type::foo;  <span class="comment">// is_foo()</span></span><br><span class="line">req.from = <span class="string">&quot;localhost&quot;</span>;  <span class="comment">// is_local_req()</span></span><br><span class="line"><span class="built_in">EXPECT_EQ</span>(ctx.<span class="built_in">get_value</span>(), <span class="number">5</span>);  <span class="comment">// 本地请求，默认值是 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// best：代码即注释</span></span><br><span class="line">req.type = Type::foo;</span><br><span class="line"><span class="built_in">ASSERT_TRUE</span>(ctx-&gt;<span class="built_in">is_foo</span>());</span><br><span class="line">req.from = <span class="string">&quot;localhost&quot;</span>;</span><br><span class="line"><span class="built_in">ASSERT_TRUE</span>(ctx-&gt;<span class="built_in">is_local_req</span>());</span><br><span class="line"><span class="built_in">EXPECT_EQ</span>(ctx.<span class="built_in">get_value</span>(), <span class="number">5</span>);  <span class="comment">// 本地请求，默认值是 5</span></span><br></pre></td></tr></table></figure>

<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="http://google.github.io/googletest/primer.html">GTest 官方手册 (Google Test Primer)</a><br><a href="https://imageslr.com/2023/gtest">C++ 研发基本功 - GTest &#x2F; GMock 单元测试实践手册</a></p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
  </entry>
  <entry>
    <title>Git 使用手册</title>
    <url>/blog/git-manual/</url>
    <content><![CDATA[<div class="note info">

<p>本手册整理于<a href="https://learngitbranching.js.org/?demo=&locale=zh_CN">Learning Git Branching</a>，用过关的形式来逐步练习，并用动画来呈现git中的关系，非常直观有趣。常用本地和远程指令讲解练习都有，几个小时就可以做完。</p>
</div>

<span id="more"></span>

<h2 id="规范化git更新日志"><a href="#规范化git更新日志" class="headerlink" title="规范化git更新日志"></a>规范化git更新日志</h2><p>在下面这个例子中，格式的各个部分含义如下：</p>
<ul>
<li><p><code>Features</code>: 这部分列出了新版本中添加的新功能。每一项都包含一个提交的哈希值、一个简短的描述和一个可能的问题编号。</p>
</li>
<li><p><code>Bug fixes</code>: 这部分列出了新版本中修复的错误。格式与 Features 部分相同。</p>
</li>
<li><p>提交的哈希值（<code>e6a1db2</code>）: 这是 Git 提交的唯一标识符，可以用来在 Git 历史中找到这个提交。</p>
</li>
<li><p>方括号中的内容（<code>[bgnotify]</code>）: 这通常表示这个提交影响的是哪个部分或者模块。</p>
</li>
<li><p>描述（<code>Add support to wayland</code>）: 这是对这个提交做的更改的简短描述。</p>
</li>
<li><p>问题编号（<code>#12045</code>）: 如果这个提交是为了解决一个在问题跟踪系统中报告的问题，这个编号可以用来找到那个问题的详细信息。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Features:</span><br><span class="line"></span><br><span class="line"> - e6a1db2 [bgnotify] Add support to wayland (#12045)</span><br><span class="line"> - e021334 [vi-mode]  Add option to disable clipboard (#12037)</span><br><span class="line"></span><br><span class="line">Bug fixes:</span><br><span class="line"></span><br><span class="line"> - c8e600f [direnv]   Initialize properly direnv</span><br><span class="line"> - 6165c25 [grc]      Source grc.zsh on gentoo (#12050)</span><br><span class="line"> - 22f9a8d [juju]     Add `public-address` fallback to `jaddr` (#12046)</span><br></pre></td></tr></table></figure>

<h2 id="本地git操作"><a href="#本地git操作" class="headerlink" title="本地git操作"></a>本地git操作</h2><h3 id="1-建立分支，commit操作"><a href="#1-建立分支，commit操作" class="headerlink" title="1. 建立分支，commit操作"></a>1. 建立分支，commit操作</h3><ol>
<li><p><code>git commit</code>：在当前分支下留下commit。</p>
</li>
<li><p><code>git branch &lt;b-name&gt;</code>：建立新分支。</p>
</li>
<li><p><code>git checkout &lt;b-name&gt;</code>：从当前分支切换新分支。</p>
<p>2和3也可以联合起来用一个<code>git checkout -b &lt;b-name&gt;</code>实现，表示建立并直接切换至新分支。</p>
</li>
</ol>
<h3 id="2-合并分支"><a href="#2-合并分支" class="headerlink" title="2. 合并分支"></a>2. 合并分支</h3><ol>
<li><p><code>git merge &lt;b-name&gt;</code>：合并分支到main（或者master）上（当前在main上）。</p>
<p>如果需要吧main合并到分支b1上，则：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout b1</span><br><span class="line">git merge main</span><br></pre></td></tr></table></figure>

<p>先切换分支，然后把main合并过去。</p>
</li>
<li><p><code>git rebase &lt;b-name&gt;</code>: rebase的第一个作用是合并多个commit为一个commit，第二个作用是将一段commits粘贴到另一个分支上。假设现在在b1分支上，如果执行<code>git rebase main</code>则会把main当前HEAD的commits都复制到b1上，并且还保有main。</p>
</li>
</ol>
<h3 id="3-分支内操作"><a href="#3-分支内操作" class="headerlink" title="3. 分支内操作"></a>3. 分支内操作</h3><ol>
<li>HEAD为路径下指向的最近提交，在当前路径上可以用<code>git checkout &lt;node name&gt;</code>来移动HEAD的位置。</li>
<li><code>^数字</code>：表示在当前分支或HEAD处向上移动数字n个提交记录。<code>引用^</code>这时放在引用后面表示寻找引用的父节点，比如<code>main^</code>表示main的父节点，<code>main^^</code>表示main^的父节点。</li>
<li><code>~</code>:表示向上移动，<code>~n</code>表示向上移动n个点，n最小为1。</li>
<li><code>git branch -f main HEAD~3</code>：表示切换到main路径并指向HEAD的向上3级父提交。</li>
<li>撤销变更<code>git reset HEAD~1</code>和<code>git revert HEAD</code>。reset直接倒退回上一次提交，这样会导致commit不可见，所以一般用在本地。revert一般用在远程，也是返回上一次提交，但是他是延伸出一个节点并表示上一次提交，是可见的撤销。</li>
</ol>
<h3 id="4-自由修改提交树"><a href="#4-自由修改提交树" class="headerlink" title="4. 自由修改提交树"></a>4. 自由修改提交树</h3><ol>
<li><code>git cherry-pick &lt;n1,n2...&gt;</code>：表示把节点n1，n2等等直接接到当前路径的HEAD下。</li>
<li><code>git rebase -i HEAD~3</code>：当想修改当前路径下多个commits时，可以在<code>rebase -i</code>来打开交互界面，通过omit来隐藏不需要的节点，通过拖动改变节点顺序，确认之后就可以按照交互操作生成一个新的分支。</li>
</ol>
<h3 id="5-本地提交杂项"><a href="#5-本地提交杂项" class="headerlink" title="5. 本地提交杂项"></a>5. 本地提交杂项</h3><ol>
<li>快速提交，可以用<code>rebase -i</code>或者<code>cherry-pick</code>来选择需要提交的commit，补充一条<code>git rebase branch1 main</code>就相当于<code>git checkout main</code>加上<code>git rebase branch1</code>，也就是从branch1跳到main后再将branch1接到main候面。</li>
<li>在一个分支上b1又建立了新分支b2，并且已经有提交，现在想返回老分支b1做修改。<ul>
<li><code>git rebase -i HEAD~2</code>：调整顺序并建立新分支。</li>
<li><code>git commit --amend</code>：对HEAD节点加入修改。</li>
<li><code>git rebase -i HEAD~2</code>：在对当前分支把顺序调回来并生成新分支。</li>
<li><code>git rebase b1 main</code>：把main移动到b1最前端。</li>
</ul>
</li>
<li>上面的操作会导致排序太多，所以还可以用<code>cherry-pick</code>来操作：<ul>
<li><code>git checkout main</code>：返回main。</li>
<li><code>git cherry-pick C2</code>：只把原本的C2点拿出来加到main下面。</li>
<li><code>git commit --amend</code>：在C2点上做修改。</li>
<li><code>git cherry-pick C3</code>：再把原本C2的子节点C3也拿过来接在C2上。</li>
</ul>
</li>
<li>可以用<code>git tag &lt;tag-name&gt; &lt;n-name&gt;</code>来给node添加tag，也可以用checkout找到node再直接tag。</li>
<li><code>git describe &lt;ref&gt;</code>的返回值是<code>&lt;tag&gt;_&lt;numCommits&gt;_g&lt;hash&gt;</code>，其作用是查询离当前最近tag差多少个提交记录，hash表示给定的ref的前几位。</li>
</ol>
<h3 id="6-本地进阶"><a href="#6-本地进阶" class="headerlink" title="6. 本地进阶"></a>6. 本地进阶</h3><ol>
<li>多项rebase, 使用<code>git rebase b1 b2</code>来把b2接到b1上并且路径设为b2.</li>
<li><code>main^2</code>表示main的另一个父递交，此外^和~可以链式操作。</li>
</ol>
<h2 id="远程仓库git操作"><a href="#远程仓库git操作" class="headerlink" title="远程仓库git操作"></a>远程仓库git操作</h2><h3 id="1-基本操作"><a href="#1-基本操作" class="headerlink" title="1. 基本操作"></a>1. 基本操作</h3><ol>
<li><p><code>git clone </code>: 从远程仓库复制到本地，或者把本地很远程连接。一般复制完本地会有<code>o/main</code>的分支，这个是远程分支。远程分支的命名规范是<code>&lt;remote name&gt;/&lt;branch name&gt;</code>，所以这里的o是origin。</p>
</li>
<li><p>远程分支在检出时，会进入分离HEAD状态。为的是不让main的操作直接留在o&#x2F;main上。在本地上要注意做提交时所处的分支。</p>
</li>
<li><p><code>git fetch</code>：从远程仓库获取数据（通信，或者就是下载），获得本地仓库缺失的提交记录，并更新远程分支指针（如：o&#x2F;main）。但是并不会改变本地仓库的状态，也不会更新main分支，也不会修改磁盘上的文件。</p>
<p>通常通过互联网（<code>http://</code>或者<code>git://</code>与远程仓库通信）。</p>
</li>
<li><p><code>git pull</code>：先抓取更新在进行合并。其作用和<code>git  fetch</code>加上<code>git merge</code>是一样的效果。</p>
</li>
<li><p><code>git push</code>：将我的变更上传到指定远程仓库，并在远程仓库上合并我的新提交记录，也就是说在push之后小组其他成员就可以从远程仓库上下载我的推送成果了。</p>
<p>push不带参数时的行为与<code>git default</code>配置有关。默认值取决于正在使用的git版本。</p>
</li>
<li><p>提交偏离得问题会导致在push得时候跟不上远程仓库的版本，git会强制开发者先合并最新的代码，然后才能push。</p>
<ul>
<li>可以先fetch远程仓库，然后rebase到本地的o&#x2F;main上，把个人工作移动到最新提交记录下，然后再用push（简写指令为<code>git pull --rebase</code>）。</li>
<li>fetch-merge-push的顺序也可以，这种与rebase的不同在于，将本地的提交与o&#x2F;main无抹除合并（以分支的形式），然后提交到远程仓库时也是分支得形式(简写<code>git pull</code>)。</li>
</ul>
</li>
<li><p>但是一般都不允许直接在master上进行push，需要配置pull requests来提交更新。</p>
<p>具体操作：</p>
<ul>
<li><code>git reset --hard o/main</code>把o&#x2F;main与本地的main重置到一起。</li>
<li>然后<code>git checkout -b feature C2</code>建立新的分支节点。</li>
<li>最后<code>git push origin feature</code>到远程仓库。</li>
</ul>
</li>
</ol>
<h3 id="2-高级操作"><a href="#2-高级操作" class="headerlink" title="2. 高级操作"></a>2. 高级操作</h3><ol>
<li><p>推送主分支：在个人本地仓库分之多的情况下，需要把所有分支做集成，然后统一推送。</p>
<ul>
<li><code>git fetch</code>：抓取更新</li>
<li><code>git rebase o/main side1</code>：合并并定位到side1</li>
<li><code>git rebase side1 main1</code>：合并并定位到main</li>
<li><code>git push</code>：将集成完毕的记录推送到远程仓库</li>
</ul>
</li>
<li><p>在合并远程仓库中，既可以选择rebase也可以选择merge，rebase的优点是提交树干净，所有提交都在一条线上。缺点是修改了提交树的历史。merge能够保留提交历史。</p>
<ul>
<li><code>git checkout main</code>：移到本地main上。</li>
<li><code>git pull</code>：抓取远程仓库并与之合并。</li>
<li><code>git merge side1</code>：合并side1到main上（此时head在main并且main和o&#x2F;main一起联动）。</li>
<li><code>git push</code>：保留所有提交历史将相同的提交记录推送到远程仓库。</li>
</ul>
</li>
<li><p>远程跟踪，在clone得时候git就会在本地创造一个远程分支（如o&#x2F;main），以及跟踪远程仓库中活动分支的本地分支（如main）。</p>
<p>可以通过自型设定任意分支来跟踪远程分支，这样在push得时候merge目标就是你设定的分支。</p>
<ul>
<li>可通过如下第一种方法设定属性</li>
</ul>
<p><code>git checkout -b foo o/main</code></p>
<p>这样foo在pull或者push得时候就可以直接跟踪远程仓库的main分支。</p>
<ul>
<li>或者用第二种方法：</li>
</ul>
<p><code>git branch -u o/main foo</code></p>
<p>这样foo就会跟踪o&#x2F;main，如果本身就在foo上，可以直接省略foo。</p>
</li>
<li><p><code>git push &lt;remote&gt; &lt;place&gt;</code>：对push指定参数，切换本地分支<place>获取所有提交，并在远程仓库origin中找到这个分支并添加上去。如果不指定参数，则会以HEAD的位置进行push。同样可用于pull指令。</p>
</li>
<li><p><code>&lt;place&gt;</code>参数：上面的参数可以指定来源和目的地<code>&lt;source&gt;:&lt;destination&gt;</code>。在push指令的情况下，source为本地，destionation为远程仓库的指定位置。当使用push如果远程不存在，可以自动生成新分支。</p>
</li>
<li><p>接第五条，在使用fetch指令时，source和destination刚好和上面相反，前者是远程，后者是本地。同样在fetch时本地不存在分支，则会自动生成新分支。如果<code>git fetch</code>没有指定参数，则会下载提交记录到所有分支。</p>
</li>
<li><p><code>&lt;source&gt;</code>：在push和fetch时也可以不指定任何source，仅保留冒号和destionation。</p>
<p><code>git push origin :foo</code>传一个空值给source，则直接删除了远程的foo。</p>
<p><code>git fetch origin :bar</code>则会在本地创建一个新分支。</p>
</li>
<li><p><code>git pull</code>就等于<code>git fetch</code>加上<code>git merge</code>，而pull唯一关注的时是提交最终合并到哪里（也就是fetch所提供的destination参数）</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/blog/hello-world/</url>
    <content><![CDATA[<div class="note info">

<p>Welcome to my blog site build on <a href="https://hexo.io/">Hexo</a>! This is my very first post! (ゝ∀･)</p>
</div>

<span id="more"></span>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server --debug</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p>Check follow links for more info. </p>
<ul>
<li><a href="https://hexo.io/docs/">Documentation</a></li>
<li><a href="https://hexo.io/docs/troubleshooting.html">Troubleshooting</a></li>
<li><a href="https://github.com/hexojs/hexo/issues">GitHub</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>华为对象云存储OBS开发记录</title>
    <url>/blog/huawei-obs/</url>
    <content><![CDATA[<div class="note info">

<ul>
<li>对象存储是一种存储结构，它将数据作为对象进行管理，而不是文件或块，每个对象包括数据、元数据和唯一标识符。</li>
<li>在软件开发中，对象存储通常用于存储非结构化数据，如图片、视频、日志文件等。</li>
<li>使用对象存储，可以通过RESTful API从任何地方访问数据，这使得对象存储非常适合用于构建<a href="https://c.biancheng.net/view/9857.html">云原生</a>应用，或者需要大规模数据存储和访问的应用。</li>
<li>国内外许多云服务提供商，都提供对象存储服务：<ul>
<li>国内<ul>
<li><a href="https://www.aliyun.com/product/oss/">阿里云OSS</a></li>
<li><a href="https://cloud.tencent.com/product/cos">腾讯云COS</a></li>
<li><a href="https://www.huaweicloud.com/product/obs.html">华为云OBS</a></li>
<li><a href="https://cloud.baidu.com/product/bos.html">百度云BOS</a></li>
</ul>
</li>
<li>国外<ul>
<li><a href="https://aws.amazon.com/cn/s3/">Amazon S3（Simple Storage Service）</a></li>
<li><a href="https://cloud.google.com/storage">Google Cloud Storage</a></li>
<li><a href="https://azure.microsoft.com/en-us/products/storage/blobs">Microsoft Azure Blob Storage</a></li>
<li><a href="https://www.ibm.com/products/cloud-object-storage">IBM Cloud Object Storage</a></li>
</ul>
</li>
</ul>
</li>
<li>本文基于OBS Java API，从头开始实现了一个最简单的分段上传大文件的功能。</li>
</ul>
</div>

<span id="more"></span>


<h2 id="开发指南"><a href="#开发指南" class="headerlink" title="开发指南"></a>开发指南</h2><p><a href="https://support.huaweicloud.com/obs/index.html">对象存储服务 开发指南</a></p>
<p>OBS提供了REST（Representational State Transfer）风格API，支持通过HTTP&#x2F;HTTPS请求调用，调用方法请参见<a href="https://support.huaweicloud.com/api-obs/obs_04_0006.html">如何调用API</a>。</p>
<p>同时OBS还提供多种编程语言的SDK，SDK的使用方法请参见<a href="https://support.huaweicloud.com/sdkreference-obs/obs_02_0001.html">SDK参考</a>。</p>
<h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><p>首先，需要在项目中添加华为云OBS的Java SDK依赖。如果项目是Maven项目，可以在pom.xml文件中添加以下依赖：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.moses.obs&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-start-obs&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">1.0</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>


<h2 id="鉴权方式"><a href="#鉴权方式" class="headerlink" title="鉴权方式"></a>鉴权方式</h2><p>OBS通过用户帐号中的AK和SK进行签名验证，确保通过授权的帐号才能访问指定的OBS资源。</p>
<ul>
<li>AK：Access Key ID，接入键标识，用户在对象存储服务系统中的接入键标识，一个接入键标识唯一对应一个用户，一个用户可以同时拥有多个接入键标识。对象存储服务系统通过接入键标识识别访问系统的用户。</li>
<li>SK：Secret Access Key，安全接入键，用户在对象存储服务系统中的安全接入键，是用户访问对象存储服务系统的密钥，用户根据安全接入键和请求头域生成鉴权信息。安全接入键和接入键标识一一对应。</li>
</ul>
<h2 id="分段上传"><a href="#分段上传" class="headerlink" title="分段上传"></a>分段上传</h2><p>对于超过5G的大文件采用分段上传方式，分段上传分为如下3个步骤：</p>
<ul>
<li>步骤1 初始化分段上传任务（ObsClient.initiateMultipartUpload）。</li>
<li>步骤2 逐个或并行上传段（ObsClient.uploadPart）。</li>
<li>步骤3 合并段（ObsClient.completeMultipartUpload）或<br>  取消分段上传任务（ObsClient.abortMultipartUpload）。</li>
</ul>
<h3 id="初始化上传任务"><a href="#初始化上传任务" class="headerlink" title="初始化上传任务"></a>初始化上传任务</h3><ul>
<li>使用分段上传方式传输数据前，必须先通知OBS初始化一个分段上传任务。该操作会返回一个OBS服务端创建的全局唯一标识（Upload ID），用于标识本次分段上传任务，可以根据这个唯一标识来发起相关的操作，如取消分段上传任务、列举分段上传任务、列举已上传的段等。</li>
<li>通过ObsClient.initiateMultipartUpload初始化一个分段上传任务：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Endpoint以北京四为例，其他地区请按实际情况填写。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">endPoint</span> <span class="operator">=</span> <span class="string">&quot;https://obs.cn-north-4.myhuaweicloud.com&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">ak</span> <span class="operator">=</span> System.getenv(<span class="string">&quot;ACCESS_KEY_ID&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">sk</span> <span class="operator">=</span> System.getenv(<span class="string">&quot;SECRET_ACCESS_KEY_ID&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建ObsClient实例</span></span><br><span class="line"><span class="type">ObsClient</span> <span class="variable">obsClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObsClient</span>(ak, sk, endPoint);</span><br><span class="line"></span><br><span class="line"><span class="type">InitiateMultipartUploadRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InitiateMultipartUploadRequest</span>(<span class="string">&quot;bucketname&quot;</span>, <span class="string">&quot;objectname&quot;</span>);</span><br><span class="line"><span class="type">ObjectMetadata</span> <span class="variable">metadata</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMetadata</span>();</span><br><span class="line">metadata.addUserMetadata(<span class="string">&quot;property&quot;</span>, <span class="string">&quot;property-value&quot;</span>);</span><br><span class="line">metadata.setContentType(<span class="string">&quot;text/plain&quot;</span>);</span><br><span class="line">request.setMetadata(metadata);</span><br><span class="line"><span class="type">InitiateMultipartUploadResult</span> <span class="variable">result</span> <span class="operator">=</span> obsClient.initiateMultipartUpload(request);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">uploadId</span> <span class="operator">=</span> result.getUploadId();</span><br><span class="line">System.out.println(<span class="string">&quot;\t&quot;</span> + uploadId);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="上传段"><a href="#上传段" class="headerlink" title="上传段"></a>上传段</h3><ul>
<li>初始化一个分段上传任务之后，可以根据指定的对象名和Upload ID来分段上传数据。</li>
<li>每一个上传的段都有一个标识它的号码——分段号（Part Number，范围是1~10000）。</li>
<li>对于同一个Upload ID，该分段号不但唯一标识这一段数据，也标识了这段数据在整个对象内的相对位置。</li>
<li>如果同一个分段号上传了新的数据，那么OBS上已有的这个段号的数据将被覆盖。除了最后一段以外，其他段的大小范围是100KB-5GB，最后段大小范围是0-5GB。</li>
<li>每个段不需要按顺序上传，甚至可以在不同进程、不同机器上上传，OBS会按照分段号排序组成最终对象。</li>
<li>通过ObsClient.uploadPart上传段：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Endpoint以北京四为例，其他地区请按实际情况填写。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">endPoint</span> <span class="operator">=</span> <span class="string">&quot;https://obs.cn-north-4.myhuaweicloud.com&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">ak</span> <span class="operator">=</span> System.getenv(<span class="string">&quot;ACCESS_KEY_ID&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">sk</span> <span class="operator">=</span> System.getenv(<span class="string">&quot;SECRET_ACCESS_KEY_ID&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">uploadId</span> <span class="operator">=</span> <span class="string">&quot;upload id from initiateMultipartUpload&quot;</span>;</span><br><span class="line"><span class="comment">// 创建ObsClient实例</span></span><br><span class="line"><span class="type">ObsClient</span> <span class="variable">obsClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObsClient</span>(ak, sk, endPoint);</span><br><span class="line"></span><br><span class="line">List&lt;PartEtag&gt; partEtags = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;PartEtag&gt;();</span><br><span class="line"><span class="comment">// 上传第一段</span></span><br><span class="line"><span class="type">UploadPartRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UploadPartRequest</span>(<span class="string">&quot;bucketname&quot;</span>, <span class="string">&quot;objectname&quot;</span>);</span><br><span class="line"><span class="comment">// 设置Upload ID</span></span><br><span class="line">request.setUploadId(uploadId);</span><br><span class="line"><span class="comment">// 设置分段号，范围是1~10000，</span></span><br><span class="line">request.setPartNumber(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 设置将要上传的大文件</span></span><br><span class="line">request.setFile(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;localfile&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置分段大小</span></span><br><span class="line">request.setPartSize(<span class="number">5</span> * <span class="number">1024</span> * <span class="number">1024L</span>);</span><br><span class="line"><span class="type">UploadPartResult</span> <span class="variable">result</span> <span class="operator">=</span> obsClient.uploadPart(request);</span><br><span class="line">partEtags.add(<span class="keyword">new</span> <span class="title class_">PartEtag</span>(result.getEtag(), result.getPartNumber()));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上传第二段</span></span><br><span class="line">request = <span class="keyword">new</span> <span class="title class_">UploadPartRequest</span>(<span class="string">&quot;bucketname&quot;</span>, <span class="string">&quot;objectname&quot;</span>);</span><br><span class="line"><span class="comment">// 设置Upload ID</span></span><br><span class="line">request.setUploadId(uploadId);</span><br><span class="line"><span class="comment">// 设置分段号</span></span><br><span class="line">request.setPartNumber(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 设置将要上传的大文件</span></span><br><span class="line">request.setFile(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;localfile&quot;</span>));</span><br><span class="line"><span class="comment">// 设置第二段的段偏移量</span></span><br><span class="line">request.setOffset(<span class="number">5</span> * <span class="number">1024</span> * <span class="number">1024L</span>);</span><br><span class="line"><span class="comment">// 设置分段大小</span></span><br><span class="line">request.setPartSize(<span class="number">5</span> * <span class="number">1024</span> * <span class="number">1024L</span>);</span><br><span class="line">result = obsClient.uploadPart(request);</span><br><span class="line">partEtags.add(<span class="keyword">new</span> <span class="title class_">PartEtag</span>(result.getEtag(), result.getPartNumber()));</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="合并段"><a href="#合并段" class="headerlink" title="合并段"></a>合并段</h3><ul>
<li>所有分段上传完成后，需要调用合并段接口来在OBS服务端生成最终对象。</li>
<li>在执行该操作时，需要提供所有有效的分段列表（包括分段号和分段ETag值）；OBS收到提交的分段列表后，会逐一验证每个段的有效性。当所有段验证通过后，OBS将把这些分段组合成最终的对象。</li>
<li>通过ObsClient.completeMultipartUpload合并段：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Endpoint以北京四为例，其他地区请按实际情况填写。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">endPoint</span> <span class="operator">=</span> <span class="string">&quot;https://obs.cn-north-4.myhuaweicloud.com&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">ak</span> <span class="operator">=</span> System.getenv(<span class="string">&quot;ACCESS_KEY_ID&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">sk</span> <span class="operator">=</span> System.getenv(<span class="string">&quot;SECRET_ACCESS_KEY_ID&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">uploadId</span> <span class="operator">=</span> <span class="string">&quot;upload id from initiateMultipartUpload&quot;</span>;</span><br><span class="line"><span class="comment">// 创建ObsClient实例</span></span><br><span class="line"><span class="type">ObsClient</span> <span class="variable">obsClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObsClient</span>(ak, sk, endPoint);</span><br><span class="line"></span><br><span class="line">List&lt;PartEtag&gt; partEtags = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;PartEtag&gt;();</span><br><span class="line"><span class="comment">// 第一段</span></span><br><span class="line"><span class="type">PartEtag</span> <span class="variable">part1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PartEtag</span>();</span><br><span class="line">part1.setPartNumber(<span class="number">1</span>);</span><br><span class="line">part1.seteTag(<span class="string">&quot;etag1&quot;</span>);</span><br><span class="line">partEtags.add(part1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二段</span></span><br><span class="line"><span class="type">PartEtag</span> <span class="variable">part2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PartEtag</span>();</span><br><span class="line">part2.setPartNumber(<span class="number">2</span>);</span><br><span class="line">part2.setEtag(<span class="string">&quot;etag2&quot;</span>);</span><br><span class="line">partEtags.add(part2);</span><br><span class="line"></span><br><span class="line"><span class="type">CompleteMultipartUploadRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CompleteMultipartUploadRequest</span>(<span class="string">&quot;bucketname&quot;</span>, <span class="string">&quot;objectname&quot;</span>, uploadId, partEtags);</span><br><span class="line"></span><br><span class="line">obsClient.completeMultipartUpload(request);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.obs.services.ObsClient;</span><br><span class="line"><span class="keyword">import</span> com.obs.services.model.InitiateMultipartUploadRequest;</span><br><span class="line"><span class="keyword">import</span> com.obs.services.model.InitiateMultipartUploadResult;</span><br><span class="line"><span class="keyword">import</span> com.obs.services.model.UploadPartRequest;</span><br><span class="line"><span class="keyword">import</span> com.obs.services.model.UploadPartResult;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MultipartUploadSample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">endPoint</span> <span class="operator">=</span> <span class="string">&quot;your-endpoint&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">accessKey</span> <span class="operator">=</span> <span class="string">&quot;your-access-key&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">secretKey</span> <span class="operator">=</span> <span class="string">&quot;your-secret-key&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">bucketName</span> <span class="operator">=</span> <span class="string">&quot;your-bucket-name&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">objectKey</span> <span class="operator">=</span> <span class="string">&quot;your-object-key&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;your-file-path&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">partSize</span> <span class="operator">=</span> <span class="number">5</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ObsClient</span> <span class="variable">obsClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObsClient</span>(accessKey, secretKey, endPoint);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Step 1: Initialize.</span></span><br><span class="line">            <span class="type">InitiateMultipartUploadRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InitiateMultipartUploadRequest</span>(bucketName, objectKey);</span><br><span class="line">            <span class="type">InitiateMultipartUploadResult</span> <span class="variable">result</span> <span class="operator">=</span> obsClient.initiateMultipartUpload(request);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Step 2: Upload parts.</span></span><br><span class="line">            <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(filePath);</span><br><span class="line">            <span class="type">long</span> <span class="variable">fileLength</span> <span class="operator">=</span> file.length();</span><br><span class="line">            <span class="type">long</span> <span class="variable">partCount</span> <span class="operator">=</span> fileLength % partSize == <span class="number">0</span> ? fileLength / partSize : fileLength / partSize + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (partCount &gt; <span class="number">10000</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Total parts count should not exceed 10000&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Total parts count &quot;</span> + partCount + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            List&lt;UploadPartResult&gt; parts = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; partCount; i++) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">offset</span> <span class="operator">=</span> i * partSize;</span><br><span class="line">                <span class="type">long</span> <span class="variable">currPartSize</span> <span class="operator">=</span> (i + <span class="number">1</span> == partCount) ? fileLength - offset : partSize;</span><br><span class="line">                uploadPart(obsClient, bucketName, objectKey, result.getUploadId(), file, offset, currPartSize, i + <span class="number">1</span>, parts);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Step 3: Complete.</span></span><br><span class="line">            obsClient.completeMultipartUpload(bucketName, objectKey, result.getUploadId(), parts);</span><br><span class="line">            System.out.println(<span class="string">&quot;Multipart upload success. \n&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            obsClient.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">uploadPart</span><span class="params">(ObsClient obsClient, String bucketName, String objectKey, String uploadId, File file, <span class="type">long</span> offset, <span class="type">long</span> partSize, <span class="type">int</span> partNumber, List&lt;UploadPartResult&gt; parts)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fis.skip(offset);</span><br><span class="line">            <span class="type">UploadPartRequest</span> <span class="variable">uploadPartRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UploadPartRequest</span>();</span><br><span class="line">            uploadPartRequest.setBucketName(bucketName);</span><br><span class="line">            uploadPartRequest.setObjectKey(objectKey);</span><br><span class="line">            uploadPartRequest.setUploadId(uploadId);</span><br><span class="line">            uploadPartRequest.setFile(fis);</span><br><span class="line">            uploadPartRequest.setPartSize(partSize);</span><br><span class="line">            uploadPartRequest.setPartNumber(partNumber);</span><br><span class="line">            <span class="type">UploadPartResult</span> <span class="variable">uploadPartResult</span> <span class="operator">=</span> obsClient.uploadPart(uploadPartRequest);</span><br><span class="line">            parts.add(uploadPartResult);</span><br><span class="line">            System.out.println(<span class="string">&quot;Part#&quot;</span> + partNumber + <span class="string">&quot; done\n&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            fis.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Works</category>
      </categories>
  </entry>
  <entry>
    <title>LaTex 使用手册</title>
    <url>/blog/latex-tutorial/</url>
    <content><![CDATA[<div class="note info"><p>该文章会持续更新！😘</p></div>

<span id="more"></span>

<h2 id="安装教程"><a href="#安装教程" class="headerlink" title="安装教程"></a>安装教程</h2><h3 id="发行版"><a href="#发行版" class="headerlink" title="发行版"></a>发行版</h3><p>常用的Tex发行版一般有两个：Tex Live和MikTex。</p>
<ul>
<li><p><a href="https://www.tug.org/texlive/acquire-iso.html">Tex Live</a></p>
<p>提供的包很全，但占用空间较大。</p>
</li>
<li><p><a href="https://miktex.org/download">MikTex</a></p>
<p>占用空间小，安装速度快，但遇到本地缺少的包需要联网下载。</p>
</li>
</ul>
<h3 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h3><ul>
<li><p><a href="https://code.visualstudio.com/">Visual Studio Code</a>+插件<a href="https://github.com/James-Yu/LaTeX-Workshop">LaTeX Workshop</a></p>
<p>简洁，自行配置，适合轻度用户和喜欢动手的用户。</p>
</li>
<li><p><a href="https://github.com/texstudio-org/texstudio/">TeXstudio</a></p>
<p>开箱即用，适合新手；功能多，重度用户使用。</p>
</li>
</ul>
<h3 id="在线工具"><a href="#在线工具" class="headerlink" title="在线工具"></a>在线工具</h3><ul>
<li>在线LaTeX编辑器：<a href="https://www.overleaf.com/">https://www.overleaf.com</a></li>
<li>在线LaTex公式编辑器：<a href="https://www.latexlive.com/">https://www.latexlive.com</a></li>
<li>数学公式提取神器：<a href="https://mathpix.com/">https://mathpix.com/</a></li>
<li>LaTeX 公式编辑器：<a href="https://latex.codecogs.com/eqneditor/editor.php">https://latex.codecogs.com/eqneditor/editor.php</a></li>
<li>一份不太简短的LaTeX介绍：<a href="https://github.com/CTeX-org/lshort-zh-cn">https://github.com/CTeX-org/lshort-zh-cn</a></li>
<li>cmd Markdown公式指导手册：<a href="https://ericp.cn/cmd">https://ericp.cn/cmd</a></li>
</ul>
<h2 id="插入数学公式"><a href="#插入数学公式" class="headerlink" title="插入数学公式"></a>插入数学公式</h2><blockquote>
<p>应用场景：写Markdown的时候用<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.488ex;" xmlns="http://www.w3.org/2000/svg" width="6.293ex" height="2.108ex" role="img" focusable="false" viewBox="0 -716.3 2781.3 931.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D43F" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 217 683Q271 680 344 680Q485 680 506 683H518Q524 677 524 674T522 656Q517 641 513 637H475Q406 636 394 628Q387 624 380 600T313 336Q297 271 279 198T252 88L243 52Q243 48 252 48T311 46H328Q360 46 379 47T428 54T478 72T522 106T564 161Q580 191 594 228T611 270Q616 273 628 273H641Q647 264 647 262T627 203T583 83T557 9Q555 4 553 3T537 0T494 -1Q483 -1 418 -1T294 0H116Q32 0 32 10Q32 17 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"></path></g><g data-mml-node="mspace" transform="translate(681,0)"></g><g data-mml-node="mpadded" transform="translate(356,0)"><g transform="translate(0,210)"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mstyle" transform="scale(0.707)"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"></path></g></g></g></g></g></g><g data-mml-node="mspace" transform="translate(886.3,0)"></g><g data-mml-node="mi" transform="translate(716.3,0)"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"></path></g><g data-mml-node="mspace" transform="translate(1420.3,0)"></g><g data-mml-node="mpadded" transform="translate(1280.3,0)"><g transform="translate(0,-215.5)"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D438" d="M492 213Q472 213 472 226Q472 230 477 250T482 285Q482 316 461 323T364 330H312Q311 328 277 192T243 52Q243 48 254 48T334 46Q428 46 458 48T518 61Q567 77 599 117T670 248Q680 270 683 272Q690 274 698 274Q718 274 718 261Q613 7 608 2Q605 0 322 0H133Q31 0 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H757Q764 676 764 669Q764 664 751 557T737 447Q735 440 717 440H705Q698 445 698 453L701 476Q704 500 704 528Q704 558 697 578T678 609T643 625T596 632T532 634H485Q397 633 392 631Q388 629 386 622Q385 619 355 499T324 377Q347 376 372 376H398Q464 376 489 391T534 472Q538 488 540 490T557 493Q562 493 565 493T570 492T572 491T574 487T577 483L544 351Q511 218 508 216Q505 213 492 213Z"></path></g></g></g></g><g data-mml-node="mspace" transform="translate(2044.3,0)"></g><g data-mml-node="mi" transform="translate(1929.3,0)"><path data-c="1D44B" d="M42 0H40Q26 0 26 11Q26 15 29 27Q33 41 36 43T55 46Q141 49 190 98Q200 108 306 224T411 342Q302 620 297 625Q288 636 234 637H206Q200 643 200 645T202 664Q206 677 212 683H226Q260 681 347 681Q380 681 408 681T453 682T473 682Q490 682 490 671Q490 670 488 658Q484 643 481 640T465 637Q434 634 411 620L488 426L541 485Q646 598 646 610Q646 628 622 635Q617 635 609 637Q594 637 594 648Q594 650 596 664Q600 677 606 683H618Q619 683 643 683T697 681T738 680Q828 680 837 683H845Q852 676 852 672Q850 647 840 637H824Q790 636 763 628T722 611T698 593L687 584Q687 585 592 480L505 384Q505 383 536 304T601 142T638 56Q648 47 699 46Q734 46 734 37Q734 35 732 23Q728 7 725 4T711 1Q708 1 678 1T589 2Q528 2 496 2T461 1Q444 1 444 10Q444 11 446 25Q448 35 450 39T455 44T464 46T480 47T506 54Q523 62 523 64Q522 64 476 181L429 299Q241 95 236 84Q232 76 232 72Q232 53 261 47Q262 47 267 47T273 46Q276 46 277 46T280 45T283 42T284 35Q284 26 282 19Q279 6 276 4T261 1Q258 1 243 1T201 2T142 2Q64 2 42 0Z"></path></g></g></g></svg></mjx-container>内联公式写数学公式</p>
</blockquote>
<p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.488ex;" xmlns="http://www.w3.org/2000/svg" width="6.293ex" height="2.108ex" role="img" focusable="false" viewBox="0 -716.3 2781.3 931.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D43F" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 217 683Q271 680 344 680Q485 680 506 683H518Q524 677 524 674T522 656Q517 641 513 637H475Q406 636 394 628Q387 624 380 600T313 336Q297 271 279 198T252 88L243 52Q243 48 252 48T311 46H328Q360 46 379 47T428 54T478 72T522 106T564 161Q580 191 594 228T611 270Q616 273 628 273H641Q647 264 647 262T627 203T583 83T557 9Q555 4 553 3T537 0T494 -1Q483 -1 418 -1T294 0H116Q32 0 32 10Q32 17 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"></path></g><g data-mml-node="mspace" transform="translate(681,0)"></g><g data-mml-node="mpadded" transform="translate(356,0)"><g transform="translate(0,210)"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mstyle" transform="scale(0.707)"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"></path></g></g></g></g></g></g><g data-mml-node="mspace" transform="translate(886.3,0)"></g><g data-mml-node="mi" transform="translate(716.3,0)"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"></path></g><g data-mml-node="mspace" transform="translate(1420.3,0)"></g><g data-mml-node="mpadded" transform="translate(1280.3,0)"><g transform="translate(0,-215.5)"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D438" d="M492 213Q472 213 472 226Q472 230 477 250T482 285Q482 316 461 323T364 330H312Q311 328 277 192T243 52Q243 48 254 48T334 46Q428 46 458 48T518 61Q567 77 599 117T670 248Q680 270 683 272Q690 274 698 274Q718 274 718 261Q613 7 608 2Q605 0 322 0H133Q31 0 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H757Q764 676 764 669Q764 664 751 557T737 447Q735 440 717 440H705Q698 445 698 453L701 476Q704 500 704 528Q704 558 697 578T678 609T643 625T596 632T532 634H485Q397 633 392 631Q388 629 386 622Q385 619 355 499T324 377Q347 376 372 376H398Q464 376 489 391T534 472Q538 488 540 490T557 493Q562 493 565 493T570 492T572 491T574 487T577 483L544 351Q511 218 508 216Q505 213 492 213Z"></path></g></g></g></g><g data-mml-node="mspace" transform="translate(2044.3,0)"></g><g data-mml-node="mi" transform="translate(1929.3,0)"><path data-c="1D44B" d="M42 0H40Q26 0 26 11Q26 15 29 27Q33 41 36 43T55 46Q141 49 190 98Q200 108 306 224T411 342Q302 620 297 625Q288 636 234 637H206Q200 643 200 645T202 664Q206 677 212 683H226Q260 681 347 681Q380 681 408 681T453 682T473 682Q490 682 490 671Q490 670 488 658Q484 643 481 640T465 637Q434 634 411 620L488 426L541 485Q646 598 646 610Q646 628 622 635Q617 635 609 637Q594 637 594 648Q594 650 596 664Q600 677 606 683H618Q619 683 643 683T697 681T738 680Q828 680 837 683H845Q852 676 852 672Q850 647 840 637H824Q790 636 763 628T722 611T698 593L687 584Q687 585 592 480L505 384Q505 383 536 304T601 142T638 56Q648 47 699 46Q734 46 734 37Q734 35 732 23Q728 7 725 4T711 1Q708 1 678 1T589 2Q528 2 496 2T461 1Q444 1 444 10Q444 11 446 25Q448 35 450 39T455 44T464 46T480 47T506 54Q523 62 523 64Q522 64 476 181L429 299Q241 95 236 84Q232 76 232 72Q232 53 261 47Q262 47 267 47T273 46Q276 46 277 46T280 45T283 42T284 35Q284 26 282 19Q279 6 276 4T261 1Q258 1 243 1T201 2T142 2Q64 2 42 0Z"></path></g></g></g></svg></mjx-container> 的数学公式有两种：行中公式和独立公式。行中公式放在文中与其它文字混编，独立公式单独成行。</p>
<h3 id="行中公式"><a href="#行中公式" class="headerlink" title="行中公式"></a>行中公式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ 数学公式 $</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ D(x) = \begin{cases}</span><br><span class="line">            \lim\limits_{x \to 0} \frac{a^x}{b+c}, &amp; x &lt; 0 \\</span><br><span class="line">            \int_a^{3b}(x_{ij}+e^2) \mathrm{d}x, &amp; x \ge 0 \\</span><br><span class="line">         \end{cases} </span><br><span class="line">$ </span><br></pre></td></tr></table></figure>
<p>公式显示在文字同行：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -1.469ex;" xmlns="http://www.w3.org/2000/svg" width="49.936ex" height="4.07ex" role="img" focusable="false" viewBox="0 -1149.5 22071.9 1799"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D437" d="M287 628Q287 635 230 637Q207 637 200 638T193 647Q193 655 197 667T204 682Q206 683 403 683Q570 682 590 682T630 676Q702 659 752 597T803 431Q803 275 696 151T444 3L430 1L236 0H125H72Q48 0 41 2T33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM703 469Q703 507 692 537T666 584T629 613T590 629T555 636Q553 636 541 636T512 636T479 637H436Q392 637 386 627Q384 623 313 339T242 52Q242 48 253 48T330 47Q335 47 349 47T373 46Q499 46 581 128Q617 164 640 212T683 339T703 469Z"></path></g><g data-mml-node="mo" transform="translate(828,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1217,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(1789,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(2455.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mrow" transform="translate(3511.6,0)"><g data-mml-node="mo" transform="translate(0 -0.5)"><path data-c="7B" d="M547 -643L541 -649H528Q515 -649 503 -645Q324 -582 293 -466Q289 -449 289 -428T287 -200L286 42L284 53Q274 98 248 135T196 190T146 222L121 235Q119 239 119 250Q119 262 121 266T133 273Q262 336 284 449L286 460L287 701Q287 737 287 794Q288 949 292 963Q293 966 293 967Q325 1080 508 1148Q516 1150 527 1150H541L547 1144V1130Q547 1117 546 1115T536 1109Q480 1086 437 1046T381 950L379 940L378 699Q378 657 378 594Q377 452 374 438Q373 437 373 436Q350 348 243 282Q192 257 186 254L176 251L188 245Q211 236 234 223T287 189T340 135T373 65Q373 64 374 63Q377 49 378 -93Q378 -156 378 -198L379 -438L381 -449Q393 -504 436 -544T536 -608Q544 -611 545 -613T547 -629V-643Z"></path></g><g data-mml-node="mtable" transform="translate(667,0)"><g data-mml-node="mtr" transform="translate(0,115.1)"><g data-mml-node="mtd"><g data-mml-node="munder"><g data-mml-node="mo" transform="translate(38.1,0)"><path data-c="6C" d="M42 46H56Q95 46 103 60V68Q103 77 103 91T103 124T104 167T104 217T104 272T104 329Q104 366 104 407T104 482T104 542T103 586T103 603Q100 622 89 628T44 637H26V660Q26 683 28 683L38 684Q48 685 67 686T104 688Q121 689 141 690T171 693T182 694H185V379Q185 62 186 60Q190 52 198 49Q219 46 247 46H263V0H255L232 1Q209 2 183 2T145 3T107 3T57 1L34 0H26V46H42Z"></path><path data-c="69" d="M69 609Q69 637 87 653T131 669Q154 667 171 652T188 609Q188 579 171 564T129 549Q104 549 87 564T69 609ZM247 0Q232 3 143 3Q132 3 106 3T56 1L34 0H26V46H42Q70 46 91 49Q100 53 102 60T104 102V205V293Q104 345 102 359T88 378Q74 385 41 385H30V408Q30 431 32 431L42 432Q52 433 70 434T106 436Q123 437 142 438T171 441T182 442H185V62Q190 52 197 50T232 46H255V0H247Z" transform="translate(278,0)"></path><path data-c="6D" d="M41 46H55Q94 46 102 60V68Q102 77 102 91T102 122T103 161T103 203Q103 234 103 269T102 328V351Q99 370 88 376T43 385H25V408Q25 431 27 431L37 432Q47 433 65 434T102 436Q119 437 138 438T167 441T178 442H181V402Q181 364 182 364T187 369T199 384T218 402T247 421T285 437Q305 442 336 442Q351 442 364 440T387 434T406 426T421 417T432 406T441 395T448 384T452 374T455 366L457 361L460 365Q463 369 466 373T475 384T488 397T503 410T523 422T546 432T572 439T603 442Q729 442 740 329Q741 322 741 190V104Q741 66 743 59T754 49Q775 46 803 46H819V0H811L788 1Q764 2 737 2T699 3Q596 3 587 0H579V46H595Q656 46 656 62Q657 64 657 200Q656 335 655 343Q649 371 635 385T611 402T585 404Q540 404 506 370Q479 343 472 315T464 232V168V108Q464 78 465 68T468 55T477 49Q498 46 526 46H542V0H534L510 1Q487 2 460 2T422 3Q319 3 310 0H302V46H318Q379 46 379 62Q380 64 380 200Q379 335 378 343Q372 371 358 385T334 402T308 404Q263 404 229 370Q202 343 195 315T187 232V168V108Q187 78 188 68T191 55T200 49Q221 46 249 46H265V0H257L234 1Q210 2 183 2T145 3Q42 3 33 0H25V46H41Z" transform="translate(556,0)"></path></g><g data-mml-node="TeXAtom" transform="translate(0,-637.9) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(572,0)"><path data-c="2192" d="M56 237T56 250T70 270H835Q719 357 692 493Q692 494 692 496T691 499Q691 511 708 511H711Q720 511 723 510T729 506T732 497T735 481T743 456Q765 389 816 336T935 261Q944 258 944 250Q944 244 939 241T915 231T877 212Q836 186 806 152T761 85T740 35T732 4Q730 -6 727 -8T711 -11Q691 -11 691 0Q691 7 696 25Q728 151 835 230H70Q56 237 56 250Z"></path></g><g data-mml-node="mn" transform="translate(1572,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g></g><g data-mml-node="mfrac" transform="translate(1631.8,0)"><g data-mml-node="msup" transform="translate(440.5,394) scale(0.707)"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(562,363) scale(0.707)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g></g><g data-mml-node="mrow" transform="translate(220,-345) scale(0.707)"><g data-mml-node="mi"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><g data-mml-node="mo" transform="translate(429,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(1207,0)"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"></path></g></g><rect width="1359.7" height="60" x="120" y="220"></rect></g><g data-mml-node="mo" transform="translate(3231.4,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g></g><g data-mml-node="mtd" transform="translate(4509.4,0)"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(849.8,0)"><path data-c="3C" d="M694 -11T694 -19T688 -33T678 -40Q671 -40 524 29T234 166L90 235Q83 240 83 250Q83 261 91 266Q664 540 678 540Q681 540 687 534T694 519T687 505Q686 504 417 376L151 250L417 124Q686 -4 687 -5Q694 -11 694 -19Z"></path></g><g data-mml-node="mn" transform="translate(1905.6,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g><g data-mml-node="mtext" transform="translate(2405.6,0)"><path data-c="A0" d=""></path></g><g data-mml-node="msubsup" transform="translate(2822.2,0)"><g data-mml-node="mo" transform="translate(0 0.5)"><path data-c="222B" d="M113 -244Q113 -246 119 -251T139 -263T167 -269Q186 -269 199 -260Q220 -247 232 -218T251 -133T262 -15T276 155T297 367Q300 390 305 438T314 512T325 580T340 647T361 703T390 751T428 784T479 804Q481 804 488 804T501 805Q552 802 581 769T610 695Q610 669 594 657T561 645Q542 645 527 658T512 694Q512 705 516 714T526 729T538 737T548 742L552 743Q552 745 545 751T525 762T498 768Q475 768 460 756T434 716T418 652T407 559T398 444T387 300T369 133Q349 -38 337 -102T303 -207Q256 -306 169 -306Q119 -306 87 -272T55 -196Q55 -170 71 -158T104 -146Q123 -146 138 -159T153 -195Q153 -206 149 -215T139 -230T127 -238T117 -242L113 -244Z"></path></g><g data-mml-node="TeXAtom" transform="translate(699.9,532.6) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path></g><g data-mml-node="mi" transform="translate(500,0)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g></g><g data-mml-node="mi" transform="translate(505,-340.9) scale(0.707)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g></g><g data-mml-node="mo" transform="translate(4229,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="msub" transform="translate(4618,0)"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="TeXAtom" transform="translate(605,-150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(345,0)"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"></path></g></g></g><g data-mml-node="mo" transform="translate(6030.5,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="msup" transform="translate(7030.7,0)"><g data-mml-node="mi"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"></path></g><g data-mml-node="mn" transform="translate(499,363) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g><g data-mml-node="mo" transform="translate(7933.3,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(8322.3,0)"><g data-mml-node="mi"><path data-c="64" d="M376 495Q376 511 376 535T377 568Q377 613 367 624T316 637H298V660Q298 683 300 683L310 684Q320 685 339 686T376 688Q393 689 413 690T443 693T454 694H457V390Q457 84 458 81Q461 61 472 55T517 46H535V0Q533 0 459 -5T380 -11H373V44L365 37Q307 -11 235 -11Q158 -11 96 50T34 215Q34 315 97 378T244 442Q319 442 376 393V495ZM373 342Q328 405 260 405Q211 405 173 369Q146 341 139 305T131 211Q131 155 138 120T173 59Q203 26 251 26Q322 26 373 103V342Z"></path></g></g><g data-mml-node="mi" transform="translate(8878.3,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(9450.3,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g></g><g data-mml-node="mtd" transform="translate(15237.7,0)"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(849.8,0)"><path data-c="2265" d="M83 616Q83 624 89 630T99 636Q107 636 253 568T543 431T687 361Q694 356 694 346T687 331Q685 329 395 192L107 56H101Q83 58 83 76Q83 77 83 79Q82 86 98 95Q117 105 248 167Q326 204 378 228L626 346L360 472Q291 505 200 548Q112 589 98 597T83 616ZM84 -118Q84 -108 99 -98H678Q694 -104 694 -118Q694 -130 679 -138H98Q84 -131 84 -118Z"></path></g><g data-mml-node="mn" transform="translate(1905.6,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g><g data-mml-node="mtext" transform="translate(2405.6,0)"><path data-c="A0" d=""></path></g></g></g></g><g data-mml-node="mo" transform="translate(18560.3,0) translate(0 250)"></g></g></g></g></svg></mjx-container> </p>
<h3 id="独立公式"><a href="#独立公式" class="headerlink" title="独立公式"></a>独立公式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$$ 数学公式 $$</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$$ J_\alpha(x) = \sum_{m=0}^\infty </span><br><span class="line">        \frac{(-1)^m} {m! \Gamma (m + \alpha + 1)} </span><br><span class="line">        {\left({ \frac{x}{2} }\right)}^{2m + \alpha} </span><br><span class="line">$$</span><br></pre></td></tr></table></figure>
<p>公式另起一行居中显示：<br><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -2.819ex;" xmlns="http://www.w3.org/2000/svg" width="38.899ex" height="6.354ex" role="img" focusable="false" viewBox="0 -1562.5 17193.3 2808.5"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D43D" d="M447 625Q447 637 354 637H329Q323 642 323 645T325 664Q329 677 335 683H352Q393 681 498 681Q541 681 568 681T605 682T619 682Q633 682 633 672Q633 670 630 658Q626 642 623 640T604 637Q552 637 545 623Q541 610 483 376Q420 128 419 127Q397 64 333 21T195 -22Q137 -22 97 8T57 88Q57 130 80 152T132 174Q177 174 182 130Q182 98 164 80T123 56Q115 54 115 53T122 44Q148 15 197 15Q235 15 271 47T324 130Q328 142 387 380T447 625Z"></path></g><g data-mml-node="mi" transform="translate(588,-150) scale(0.707)"><path data-c="1D6FC" d="M34 156Q34 270 120 356T309 442Q379 442 421 402T478 304Q484 275 485 237V208Q534 282 560 374Q564 388 566 390T582 393Q603 393 603 385Q603 376 594 346T558 261T497 161L486 147L487 123Q489 67 495 47T514 26Q528 28 540 37T557 60Q559 67 562 68T577 70Q597 70 597 62Q597 56 591 43Q579 19 556 5T512 -10H505Q438 -10 414 62L411 69L400 61Q390 53 370 41T325 18T267 -2T203 -11Q124 -11 79 39T34 156ZM208 26Q257 26 306 47T379 90L403 112Q401 255 396 290Q382 405 304 405Q235 405 183 332Q156 292 139 224T121 120Q121 71 146 49T208 26Z"></path></g></g><g data-mml-node="mo" transform="translate(1090.5,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1479.5,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(2051.5,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(2718.3,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="munderover" transform="translate(3774.1,0)"><g data-mml-node="mo" transform="translate(40.3,0)"><path data-c="2211" d="M60 948Q63 950 665 950H1267L1325 815Q1384 677 1388 669H1348L1341 683Q1320 724 1285 761Q1235 809 1174 838T1033 881T882 898T699 902H574H543H251L259 891Q722 258 724 252Q725 250 724 246Q721 243 460 -56L196 -356Q196 -357 407 -357Q459 -357 548 -357T676 -358Q812 -358 896 -353T1063 -332T1204 -283T1307 -196Q1328 -170 1348 -124H1388Q1388 -125 1381 -145T1356 -210T1325 -294L1267 -449L666 -450Q64 -450 61 -448Q55 -446 55 -439Q55 -437 57 -433L590 177Q590 178 557 222T452 366T322 544L56 909L55 924Q55 945 60 948Z"></path></g><g data-mml-node="TeXAtom" transform="translate(0,-1087.9) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(878,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(1656,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g><g data-mml-node="mi" transform="translate(408.7,1150) scale(0.707)"><path data-c="221E" d="M55 217Q55 305 111 373T254 442Q342 442 419 381Q457 350 493 303L507 284L514 294Q618 442 747 442Q833 442 888 374T944 214Q944 128 889 59T743 -11Q657 -11 580 50Q542 81 506 128L492 147L485 137Q381 -11 252 -11Q166 -11 111 57T55 217ZM907 217Q907 285 869 341T761 397Q740 397 720 392T682 378T648 359T619 335T594 310T574 285T559 263T548 246L543 238L574 198Q605 158 622 138T664 94T714 61T765 51Q827 51 867 100T907 217ZM92 214Q92 145 131 89T239 33Q357 33 456 193L425 233Q364 312 334 337Q285 380 233 380Q171 380 132 331T92 214Z"></path></g></g><g data-mml-node="mfrac" transform="translate(5465.3,0)"><g data-mml-node="mrow" transform="translate(2351,710)"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mo" transform="translate(389,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(1167,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="msup" transform="translate(1667,0)"><g data-mml-node="mo"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mi" transform="translate(422,363) scale(0.707)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g></g></g><g data-mml-node="mrow" transform="translate(220,-710)"><g data-mml-node="mi"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(878,0)"><path data-c="21" d="M78 661Q78 682 96 699T138 716T180 700T199 661Q199 654 179 432T158 206Q156 198 139 198Q121 198 119 206Q118 209 98 431T78 661ZM79 61Q79 89 97 105T141 121Q164 119 181 104T198 61Q198 31 181 16T139 1Q114 1 97 16T79 61Z"></path></g><g data-mml-node="mi" transform="translate(1156,0)"><path data-c="393" d="M128 619Q121 626 117 628T101 631T58 634H25V680H554V676Q556 670 568 560T582 444V440H542V444Q542 445 538 478T523 545T492 598Q454 634 349 634H334Q264 634 249 633T233 621Q232 618 232 339L233 61Q240 54 245 52T270 48T333 46H360V0H348Q324 3 182 3Q51 3 36 0H25V46H58Q100 47 109 49T128 61V619Z"></path></g><g data-mml-node="mo" transform="translate(1781,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(2170,0)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(3270.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(4270.4,0)"><path data-c="1D6FC" d="M34 156Q34 270 120 356T309 442Q379 442 421 402T478 304Q484 275 485 237V208Q534 282 560 374Q564 388 566 390T582 393Q603 393 603 385Q603 376 594 346T558 261T497 161L486 147L487 123Q489 67 495 47T514 26Q528 28 540 37T557 60Q559 67 562 68T577 70Q597 70 597 62Q597 56 591 43Q579 19 556 5T512 -10H505Q438 -10 414 62L411 69L400 61Q390 53 370 41T325 18T267 -2T203 -11Q124 -11 79 39T34 156ZM208 26Q257 26 306 47T379 90L403 112Q401 255 396 290Q382 405 304 405Q235 405 183 332Q156 292 139 224T121 120Q121 71 146 49T208 26Z"></path></g><g data-mml-node="mo" transform="translate(5132.7,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mn" transform="translate(6132.9,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(6632.9,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g><rect width="7221.9" height="60" x="120" y="220"></rect></g><g data-mml-node="msup" transform="translate(12927.2,0)"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mrow"><g data-mml-node="mo" transform="translate(0 -0.5)"><path data-c="28" d="M180 96T180 250T205 541T266 770T353 944T444 1069T527 1150H555Q561 1144 561 1141Q561 1137 545 1120T504 1072T447 995T386 878T330 721T288 513T272 251Q272 133 280 56Q293 -87 326 -209T399 -405T475 -531T536 -609T561 -640Q561 -643 555 -649H527Q483 -612 443 -568T353 -443T266 -270T205 -41Z"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(597,0)"><g data-mml-node="mfrac"><g data-mml-node="mi" transform="translate(220,676)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mn" transform="translate(256,-686)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><rect width="772" height="60" x="120" y="220"></rect></g></g><g data-mml-node="mo" transform="translate(1609,0) translate(0 -0.5)"><path data-c="29" d="M35 1138Q35 1150 51 1150H56H69Q113 1113 153 1069T243 944T330 771T391 541T416 250T391 -40T330 -270T243 -443T152 -568T69 -649H56Q43 -649 39 -647T35 -637Q65 -607 110 -548Q283 -316 316 56Q324 133 324 251Q324 368 316 445Q278 877 48 1123Q36 1137 35 1138Z"></path></g></g></g><g data-mml-node="TeXAtom" transform="translate(2239,876.6) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mi" transform="translate(500,0)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(1378,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(2156,0)"><path data-c="1D6FC" d="M34 156Q34 270 120 356T309 442Q379 442 421 402T478 304Q484 275 485 237V208Q534 282 560 374Q564 388 566 390T582 393Q603 393 603 385Q603 376 594 346T558 261T497 161L486 147L487 123Q489 67 495 47T514 26Q528 28 540 37T557 60Q559 67 562 68T577 70Q597 70 597 62Q597 56 591 43Q579 19 556 5T512 -10H505Q438 -10 414 62L411 69L400 61Q390 53 370 41T325 18T267 -2T203 -11Q124 -11 79 39T34 156ZM208 26Q257 26 306 47T379 90L403 112Q401 255 396 290Q382 405 304 405Q235 405 183 332Q156 292 139 224T121 120Q121 71 146 49T208 26Z"></path></g></g></g></g></g></svg></mjx-container></p>
<h2 id="公式指导手册"><a href="#公式指导手册" class="headerlink" title="公式指导手册"></a>公式指导手册</h2><ul>
<li><a href="https://1024th.github.io/MathJax_Tutorial_CN/#/">Latex中文手册</a></li>
</ul>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
  </entry>
  <entry>
    <title>Probability Tutorial Zero</title>
    <url>/blog/probability-preliminaries-2022/</url>
    <content><![CDATA[<div class="note info">

<ul>
<li>统计和机器学习 - 2022秋季研究生课程预备知识</li>
<li>概率论基础：<ul>
<li>随机现象、随机事件、随机变量、概率、分布函数、期望、方差等概念</li>
<li>常见的一元和多元随机变量的分布和性质</li>
</ul>
</li>
<li>点估计和区间估计：<ul>
<li>估计的三种思想（替换、似然、拟合）</li>
<li>最大似然估计</li>
<li>利用枢轴量法构造区间估计</li>
<li>区间估计与假设检验的对应关系</li>
</ul>
</li>
<li>假设检验：<ul>
<li>假设检验的基本步骤和方法</li>
<li>如何利用检验统计量、拒绝域和 p 值进行检验</li>
<li>如何对单个正态分布和两个正态分布的参数进行假设检验</li>
</ul>
</li>
</ul>
</div>

<span id="more"></span>

<h1 id="Tutorial-Zero-Preliminaries"><a href="#Tutorial-Zero-Preliminaries" class="headerlink" title="Tutorial Zero: Preliminaries"></a>Tutorial Zero: Preliminaries</h1><h2 id="Part-One：Statistics-and-Sampling-Distribution"><a href="#Part-One：Statistics-and-Sampling-Distribution" class="headerlink" title="Part One：Statistics and Sampling Distribution"></a>Part One：Statistics and Sampling Distribution</h2><ul>
<li>数据： ${x_i: i&#x3D;1,2,\cdots,n}$</li>
<li>常见假定：独立同分布，也就是说，<br>$$<br>x_i \overset{i.i.d}{\sim} X<br>$$<br>其中，$X$是一个随机变量。</li>
</ul>
<h3 id="随机变量的定义及常见分布"><a href="#随机变量的定义及常见分布" class="headerlink" title="随机变量的定义及常见分布"></a>随机变量的定义及常见分布</h3><h4 id="随机变量的定义"><a href="#随机变量的定义" class="headerlink" title="随机变量的定义"></a>随机变量的定义</h4><ul>
<li>随机现象：出现的结果不唯一，事前无法得知哪种结果出现的现象。</li>
</ul>
<ol>
<li>投掷骰子的结果；</li>
<li>抽签分组的结果；</li>
<li>从家到学校所花费的时间；</li>
<li>明天的上证指数；</li>
</ol>
<ul>
<li><p>样本空间：随机现象的所有结果。常用$\Omega$来表示。</p>
</li>
<li><p>随机事件：样本空间中的一个我们所关心的子集，常用大写的英文字母来表示，如A,B,C等。特别的随机事件类型有：</p>
</li>
<li><p>必然事件：一定会发生的事件，$\Omega$；</p>
</li>
<li><p>不可能事件：一定不会发生的事件，$\emptyset$;</p>
</li>
<li><p>概率：一个随机事件发生的可能性；</p>
</li>
<li><p>概率的公理化定义：在一个样本空间$\Omega$及其<span style="border-bottom:2px solid lightgreen;">事件域</span>$\mathcal{F}$中，对于任意随机事件$A \in \mathcal{F}$，其概率$P(A)$是一个实数，且满足：</p>
</li>
</ul>
<ol>
<li>非负性：$P(A) \geq 0$.</li>
<li>正则性：对于必然事件$\Omega$， $P(\Omega) &#x3D; 1$；</li>
<li>可列可加性：若$A_1,A_2,\cdots,A_n,\cdots$是两两互不相容的事件，即对任意$i \neq j$，有$A_i \cap A_j &#x3D; \emptyset$，则有<br>$$<br>P\left(\cup_{i&#x3D;1}^\infty A_i\right) &#x3D; \sum_{i&#x3D;1}^\infty P(A_i).<br>$$</li>
</ol>
<ul>
<li>随机变量：随机事件的数量表现，是随机事件<strong>实数化</strong>的结果。常用$X,Y,Z$等来表示。随机变量的值域往往是实数或其子集。</li>
</ul>
<p>例一：在投掷两枚均匀硬币的过程中，样本空间为$\Omega &#x3D; {\text{正正，正反，反正，反反}}$。我们关心的是硬币投掷的结果是否均为正面，或硬币投掷的结果是否不同。设随机事件$A$表示“硬币投掷的结果均为正面”，即$A &#x3D; {\text{正正}}$。设随机事件$B$表示“硬币投掷的结果不同”，即$B &#x3D; {\text{正反，反正}}$。设$X$表示出现硬币正面朝上的次数。于是<br>$$<br>X &#x3D; \begin{cases}<br>0 &amp; \text{两反}\<br>1 &amp; \text{一正一反}\<br>2 &amp; \text{两正}\<br>\end{cases}<br>$$<br>设$Y$表示出现两枚硬币是否均为正面。于是<br>$$<br>X &#x3D; \begin{cases}<br>1 &amp; \text{是}\<br>0 &amp; \text{否}\<br>\end{cases}<br>$$<br>我们可以发现，${X&#x3D;2}$和${Y&#x3D;1}$都表示两枚硬币均出现正面的现象，但所构造的随机变量不同。这表明，随机变量可以根据问题本身而构造，而且构造方式不唯一。</p>
<h4 id="随机变量的表示方式"><a href="#随机变量的表示方式" class="headerlink" title="随机变量的表示方式"></a>随机变量的表示方式</h4><p>因为随机变量用来刻画不确定性的结果的，所以，如何量化表示随机变量所代表的不确定性是一个重要的问题。通常，我们采用累积分布函数（c.d.f.）来刻画随机变量，即<br>$$<br>F_X(x) &#x3D; P(X\leq x).<br>$$<br>也就是说，$F_{X}(x)$表示的是随机变量$X$小于等于$x$的概率，前面的$X$表示随机变量，后面的$x$表示的是一个实数。</p>
<p>根据概率的性质，累积分布函数满足：（1）单调性；（2）有界性；和（3）右连续性。</p>
<p>除了累积分布函数之外，还有其他常用的方式来刻画随机变量。</p>
<ul>
<li>分布列&#x2F;概率质量函数$P(X&#x3D;x)$：常常用于刻画离散的随机变量；</li>
<li>概率密度函数$p(x)$：常常用于刻画连续的随机变量；<br>两者均满足：（1）非负性；（2）正则性。</li>
</ul>
<h4 id="常见的一元随机变量"><a href="#常见的一元随机变量" class="headerlink" title="常见的一元随机变量"></a>常见的一元随机变量</h4><h5 id="二项分布"><a href="#二项分布" class="headerlink" title="二项分布"></a>二项分布</h5><ul>
<li>刻画$n$次伯努利试验中成功的次数。</li>
<li>典型例子：抛硬币。</li>
<li>记为 $b(n,p)$，其中，$n$表示试验次数，$p$表示单次伯努利试验成功的概率。</li>
<li>分布列为<br>$$<br>P(X &#x3D; k) &#x3D; C_n^k p^{k} (1-p)^{n-k}, k&#x3D;0,1,2,\cdots,n.<br>$$</li>
<li>特例：二点分布&#x2F;伯努利分布$b(1,p)$。</li>
</ul>
<h5 id="负二项分布"><a href="#负二项分布" class="headerlink" title="负二项分布"></a>负二项分布</h5><ul>
<li>刻画在伯努利试验中第$r$次成功所需要的试验次数。</li>
<li>记为$Nb(r,p)$，其中，$r$表示试验的成功次数，$p$表示单次伯努利试验成功的概率。</li>
<li>分布列为<br>$$<br>P(X&#x3D;k) &#x3D; C_{k-1}^{r-1} p^{r} (1-p)^{k-r-1}<br>$$</li>
<li>特例：几何分布$Ge(p)&#x3D; Nb(1,p)$。</li>
<li>无记忆性：$P(X &gt; m+n|X&gt;m) &#x3D; P(X&gt;n)$。</li>
</ul>
<h5 id="泊松分布"><a href="#泊松分布" class="headerlink" title="泊松分布"></a>泊松分布</h5><ul>
<li>刻画一个单位内某事件发生的次数。</li>
<li>记为$P(\lambda)$，其中，$\lambda&gt;0$参数。</li>
<li>分布列为<br>$$<br>P(X&#x3D;k) &#x3D;\frac{\lambda^{k}}{k!} \exp{-\lambda}.<br>$$</li>
<li>泊松分布可以看作二项分布的一种极限状况（$n$趋于无穷）。</li>
</ul>
<h5 id="均匀分布"><a href="#均匀分布" class="headerlink" title="均匀分布"></a>均匀分布</h5><ul>
<li>刻画定义在区间$(a,b)$上等概率的取值。</li>
<li>记为$U(a,b)$，其中，$a,b$是两个参数。</li>
<li>密度函数为<br>$$<br>p(x) &#x3D; \frac{1}{b-a} I(a&lt; x&lt; b).<br>$$</li>
</ul>
<h5 id="正态分布"><a href="#正态分布" class="headerlink" title="正态分布"></a>正态分布</h5><ul>
<li>刻画误差的分布。</li>
<li>记为$N(\mu,\sigma^2)$，其中，$\mu\in R$和$\sigma^2&gt;0$是两个参数。</li>
<li>密度函数为<br>$$<br>p(x) &#x3D; \frac{1}{\sqrt{2\pi \sigma^2}} \exp{-(x-\mu)^2&#x2F;(2\sigma^2)}, x\in R.<br>$$</li>
<li>特例：标准正态分布$N(0,1)$。</li>
</ul>
<h5 id="卡方分布"><a href="#卡方分布" class="headerlink" title="卡方分布"></a>卡方分布</h5><ul>
<li>$n$个独立标准的平方和，即$\chi^2 &#x3D; \sum_{i&#x3D;1}^n Z_{i}^2$，其中$Z_i\overset{i.i.d}{\sim} N(0,1)$。</li>
<li>记为$\chi^2 \sim \chi^2(n)$。</li>
<li>$\chi^{2}(n) &#x3D; Ga(n&#x2F;2,1&#x2F;2)$。</li>
</ul>
<h5 id="F-分布"><a href="#F-分布" class="headerlink" title="$F$分布"></a>$F$分布</h5><ul>
<li>两个卡方分布的比值，即$F &#x3D; \frac{\chi^2_1&#x2F;m}{\chi^2_2&#x2F;n}$，其中$\chi_1^2\sim \chi^2(m)$和$\chi_2^2\sim \chi^2(n)$且$\chi^2_1$和$\chi_2^2$独立。</li>
<li>记为$F \sim F(m,n)$。</li>
</ul>
<h5 id="t-分布"><a href="#t-分布" class="headerlink" title="$t$分布"></a>$t$分布</h5><ul>
<li>一个标准正态分布与一个卡方分布的平方根的比值，即$t &#x3D; \frac{Z}{\sqrt{\chi^2&#x2F;n}}$，其中$Z\sim N(0,1)$和$\chi^2\sim \chi^2(n)$且$Z$和$\chi^2$独立。</li>
<li>记为$t \sim t(n)$。</li>
</ul>
<h5 id="指数分布"><a href="#指数分布" class="headerlink" title="指数分布"></a>指数分布</h5><ul>
<li>刻画寿命。</li>
<li>记为$Exp(\lambda)$，其中，$\lambda&gt;0$是参数。</li>
<li>密度函数为<br>$$<br>p(x) &#x3D; \lambda \exp{-\lambda x}, x&gt;0.<br>$$</li>
<li>无记忆性。</li>
</ul>
<h5 id="Gamma-分布"><a href="#Gamma-分布" class="headerlink" title="Gamma 分布"></a>Gamma 分布</h5><ul>
<li>Gamma函数 $\Gamma(\alpha) &#x3D; \int_{0}^{\infty} x^{\alpha-1} \exp{-x} \text{d} x$。</li>
<li>Gamma函数的性质：</li>
</ul>
<ol>
<li>$\Gamma(1) &#x3D; 1$；</li>
<li>$\Gamma(1&#x2F;2) &#x3D; \sqrt{\pi}$；</li>
<li>$\Gamma(\alpha+1) &#x3D; \alpha \Gamma(\alpha)$；</li>
<li>$\Gamma(n+1) &#x3D; n\Gamma(n) &#x3D; n!$；</li>
</ol>
<ul>
<li>记为$Ga(\alpha,\lambda)$, 其中，$\alpha&gt;0$是形状参数,$\lambda&gt;0$是尺度参数。</li>
<li>密度函数为<br>$$<br>p(x) &#x3D; \frac{\lambda^{\alpha}}{\Gamma(\alpha)} x^{\alpha-1} \exp{-\lambda x}, x&gt;0<br>$$</li>
<li>特例：$Exp(\lambda) &#x3D; Ga(1,\lambda)$。</li>
</ul>
<h5 id="Beta-分布"><a href="#Beta-分布" class="headerlink" title="Beta 分布"></a>Beta 分布</h5><ul>
<li>Beta函数 $B(a,b) &#x3D; \int_{0}^1 x^{a-1} (1-x)^{b-1} \text{d}x, a,b&gt;0$。</li>
<li>Beta函数的性质：</li>
</ul>
<ol>
<li>$B(a,b) &#x3D; B(b,a)$；</li>
<li>$B(a,b) &#x3D; \frac{\Gamma(a)\Gamma(b)}{\Gamma(a+b)}$</li>
</ol>
<ul>
<li>记为$Be(a,b)$，其中，$a,b&gt;0$是两个参数。</li>
<li>密度函数为<br>$$<br>p(x) &#x3D; \frac{\Gamma(a+b)}{\Gamma(a)\Gamma(b)} x^{a-1} (1-x)^{b-1}, 0&lt;x&lt;1.<br>$$</li>
</ul>
<h4 id="随机向量"><a href="#随机向量" class="headerlink" title="随机向量"></a>随机向量</h4><ul>
<li><p>$\mathbf{X} &#x3D; (X_1,X_2,\cdots,X_p)’$是基于同一个样本空间而定义的$p$维随机向量，其中每一维$X_i$是第$i$个随机变量。</p>
</li>
<li><p>联合分布函数为<br>$$<br>F(x_1,x_2,\cdots,x_p) &#x3D; P(X_1\leq x_1, X_2 \leq x_2,\cdots,X_p \leq x_p).<br>$$</p>
</li>
<li><p>联合分布列为$P(X_1 &#x3D; x_1,X_2&#x3D;x_2,\cdots,X_p &#x3D; x_p).$</p>
</li>
<li><p>联合分布列为$p(x_1,x_2,\cdots,x_p)$满足<br>$$<br>F(x_1,x_2,\cdots,x_p) &#x3D; \int_{-\infty}^{x_1}\int_{-\infty}^{x_2}\cdots \int_{-\infty}^{x_p} p(t_1,t_2,\cdots,t_p) \text{d}t_p \cdots \text{d}x_2 \text{d}x_1.<br>$$</p>
</li>
<li><p>边际分布函数为$F_{X_i}(x_i) &#x3D; P(X_i\leq x_i)$；</p>
</li>
<li><p>边际分布列为$P(X_i &#x3D; x_i)$；</p>
</li>
<li><p>边际密度函数为$p(x_i)$；</p>
</li>
<li><p>独立性满足</p>
</li>
</ul>
<ol>
<li>$F(x_1,x_2,\cdots,x_p) &#x3D; \prod_{i&#x3D;1}^p F(x_i)$；</li>
<li>$P(X_1 &#x3D; x_1,X_2&#x3D;x_2,\cdots,X_p &#x3D; x_p) &#x3D; \prod_{i&#x3D;1}^p P(X_i &#x3D; x_i)$；</li>
<li>$p(x_1,x_2,\cdots,x_p) &#x3D; \prod_{i&#x3D;1}^p p(x_i)$。</li>
</ol>
<ul>
<li>$X$与$Y$独立，指的是$X$发生与否与$Y$发生与否是无关的。</li>
</ul>
<h4 id="随机变量的数字特征"><a href="#随机变量的数字特征" class="headerlink" title="随机变量的数字特征"></a>随机变量的数字特征</h4><h5 id="期望"><a href="#期望" class="headerlink" title="期望"></a>期望</h5><ul>
<li>衡量随机变量的平均水平。</li>
<li>计算方式为<br>$$<br>E(X) &#x3D; \begin{cases}<br>\int_{-\infty}^{\infty} x p(x) \text{d}x, \text{$X$是连续随机变量}\<br>\sum_{x_i} x_i P(X&#x3D;x_i) , \text{$X$是离散随机变量}<br>\end{cases}<br>$$</li>
<li>期望的性质：</li>
</ul>
<ol>
<li>$E(aX) &#x3D; aE(X)$，$a$是一个常数。</li>
<li>$E(a) &#x3D; a$，$a$是一个常数。</li>
<li>$E(X+Y) &#x3D; E(X) + E(Y)$。</li>
<li>若$X$和$Y$独立， 有$E(XY) &#x3D; E(X)E(Y)$。</li>
</ol>
<h5 id="方差"><a href="#方差" class="headerlink" title="方差"></a>方差</h5><ul>
<li>衡量随机变量的波动情况。</li>
<li>计算方式为<br>$$<br>Var(X) &#x3D; \begin{cases}<br>\int_{-\infty}^{\infty} (x-E(X))^2 p(x) \text{d}x, \text{$X$是连续随机变量}\<br>\sum_{x_i} (x_i-E(X))^2 P(X&#x3D;x_i) , \text{$X$是离散随机变量}<br>\end{cases}<br>$$</li>
<li>方差的性质：</li>
</ul>
<ol>
<li>$Var(X) &#x3D; E(X^2) - (E(X))^2$.</li>
<li>$Var(aX+b) &#x3D; a^2E(X)$，$a$是一个常数。</li>
<li>$Var(a) &#x3D; 0$，$a$是一个常数。</li>
<li>切比雪夫不等式：$P(|X-E(X)|\geq \epsilon) \leq \frac{Var(X)}{\epsilon^2}$。</li>
<li>若$X$和$Y$独立，有$Var(X\pm Y) &#x3D; Var(X) + Var(Y)$。</li>
</ol>
<h5 id="常见分布的期望与方差"><a href="#常见分布的期望与方差" class="headerlink" title="常见分布的期望与方差"></a>常见分布的期望与方差</h5><table width = 300>
    <tr>
        <td> 常见分布                  </td>
        <td> 期望                      </td>
        <td> 方差                      </td>
    </tr>
    <tr>
        <td> $b(n,p)$                  </td>
        <td> $np$                      </td>
        <td> $np(1-p)$                 </td>
    </tr>
    <tr>
        <td> $Nb(r,p)$                 </td>
        <td> $r/p$                     </td>
        <td> $r(1-p)/p^2$              </td>
    </tr>
    <tr>
        <td> $P(\lambda)$              </td>
        <td> $\lambda$                 </td>
        <td> $\lambda$                 </td>
    </tr>
    <tr>
        <td> $U(a,b)$                  </td>
        <td> $(a+b)/2$                 </td>
        <td> $(b-a)^2/12$              </td>
    </tr>
    <tr>
        <td> $N(\mu,\sigma^2)$         </td>
        <td> $\mu$                     </td>
        <td> $\sigma^2$                </td>
    </tr>
    <tr>
        <td> $Exp(\lambda)$            </td>
        <td> $1/\lambda$               </td>
        <td> $1/\lambda^2$             </td>
    </tr>
    <tr>
        <td> $Ga(\alpha,\lambda)$      </td>
        <td> $\alpha/\lambda$          </td>
        <td> $\alpha/\lambda^2$        </td>
    </tr>
    <tr>
        <td> $Be(a,b)$                 </td>
        <td> $a/(a+b)$                 </td>
        <td> $\frac{a(a+b)}{(a+b+1)^2(a+b+2)}$ </td>
    </tr>
</table>

<h5 id="协方差与相关系数"><a href="#协方差与相关系数" class="headerlink" title="协方差与相关系数"></a>协方差与相关系数</h5><ul>
<li><p>协方差：$Cov(X,Y) &#x3D; E(X-E(X))(Y-E(Y)) &#x3D; E(XY)- E(X)E(Y)$；</p>
</li>
<li><p>特例：$Cov(X,X) &#x3D; Var(X)$；</p>
</li>
<li><p>若$X$和$Y$独立，有$Cov(X,Y)&#x3D;0$；</p>
</li>
<li><p>$Var(X\pm Y) &#x3D; Var(X) + Var(Y) \pm 2 Cov(X,Y)$；</p>
</li>
<li><p>$Cov(X,Y) &#x3D; Cov(Y,X)$；</p>
</li>
<li><p>$Cov(X,a) &#x3D; 0$，$a$是一个常数；</p>
</li>
<li><p>$Cov(aX,bY) &#x3D; ab Cov(X,Y) $，$a,b$是常数；</p>
</li>
<li><p>$Cov(X+Y,Z) &#x3D; Cov(X,Z) + Cov(Y,Z)$。</p>
</li>
<li><p>相关系数为<br>$$<br>Corr(X,Y) &#x3D; \frac{Cov(X,Y)}{\sqrt{Var(X)Var(Y)}}.<br>$$</p>
</li>
<li><p>$-1 \leq Corr(X,Y)\leq 1$；</p>
</li>
<li><p>若$ Corr(X,Y)&gt;0$，则$X$和$Y$是正（线性）相关；</p>
</li>
<li><p>若$ Corr(X,Y)&lt;0$，则$X$和$Y$是负（线性）相关；</p>
</li>
<li><p>若$ Corr(X,Y)&#x3D;0$，则$X$和$Y$是不相关；</p>
</li>
</ul>
<h5 id="分位数"><a href="#分位数" class="headerlink" title="分位数"></a>分位数</h5><ul>
<li>$p$分位数定义为$x_p$满足$ p &#x3D; \int_{-\infty}^{x_p} p(x) \text{d}x$。</li>
</ul>
<h5 id="常见分布的分位数"><a href="#常见分布的分位数" class="headerlink" title="常见分布的分位数"></a>常见分布的分位数</h5><table width = 300>
    <tr>
        <td> 常见分布                  </td>
        <td> 分位数                    </td>
    </tr>
    <tr>
        <td> $N(0,1)$                 </td>
        <td> $z_{p}$                  </td>
    </tr>
    <tr>
        <td> $\chi^2(n)$               </td>
        <td> $\chi^2_{p}(n)$           </td>
    </tr>
    <tr>
        <td> $t(n)$                    </td>
        <td> $t_{p}(n)$                </td>
    </tr>
     <tr>
        <td> $F(m,n)$               </td>
        <td> $F_{p}(m,n)$           </td>
    </tr>
</table>

<h4 id="多元正态随机向量"><a href="#多元正态随机向量" class="headerlink" title="多元正态随机向量"></a>多元正态随机向量</h4><ul>
<li>$\mathbf{X} \sim N_{p}(\mathbf{\mu},\Sigma)$；</li>
<li>均值向量$\mathbf{\mu} &#x3D; (\mu_1,\mu_2,\cdots,\mu_p)’$，其中$\mu_{i} &#x3D; E(X_i)$；</li>
<li>方差-协方差矩阵为<br>$$<br>Cov &#x3D; \left(<br>\begin{matrix}<br>Var(X_1) &amp; Cov(X_1,X_2) &amp; \cdots &amp; Cov(X_1,X_p)\<br>Cov(X_2,X_1) &amp; Var(X_2) &amp; \cdots &amp; Cov(X_2,X_p)\<br>\vdots &amp; \vdots &amp; &amp; \vdots \<br>Cov(X_p,X_1) &amp; Cov(X_p,X_2) &amp; \cdots &amp; Var(X_p)\<br>\end{matrix}<br>\right)<br>$$</li>
<li>密度函数为<br>$$<br>p(\mathbf{x}) &#x3D; (2\pi)^{-p&#x2F;2} \det(\Sigma)^{-1&#x2F;2} \exp{ -(\mathbf{x} - \mathbf{\mu})’ \Sigma^{-1} (\mathbf{x} - \mathbf{\mu})&#x2F;2 }.<br>$$</li>
</ul>
<h4 id="重要定理"><a href="#重要定理" class="headerlink" title="重要定理"></a>重要定理</h4><p>若$x_1,x_2,\cdots,x_n$是来自于正态分布$N(\mu,\sigma^2)$的样本。我们可以证明</p>
<ol>
<li>样本均值$\bar{x} &#x3D; \frac{1}{n}\sum_{i&#x3D;1}^n x_i \sim N(\mu,\sigma^2&#x2F;n)$.</li>
<li>样本方差$s^2 &#x3D; \frac{1}{n-1}\sum_{i&#x3D;1}^n (x_i-\bar{x})^2$ 满足$(n-1)s^2&#x2F;\sigma^2 \sim \chi^2(n-1)$.</li>
<li>$\bar{x}$与$s^2$独立。</li>
</ol>
<h2 id="Part-Two：Estimation"><a href="#Part-Two：Estimation" class="headerlink" title="Part Two：Estimation"></a>Part Two：Estimation</h2><h3 id="点估计-（Point-Estimation）"><a href="#点估计-（Point-Estimation）" class="headerlink" title="点估计 （Point Estimation）"></a>点估计 （Point Estimation）</h3><ul>
<li>估计的三种思想：</li>
</ul>
<ol>
<li>替换</li>
<li>似然</li>
<li>拟合</li>
</ol>
<h4 id="最大似然估计"><a href="#最大似然估计" class="headerlink" title="最大似然估计"></a>最大似然估计</h4><ul>
<li>似然函数&lt;&#x3D;&gt;联合密度函数<br>例：总体分布$X\sim N(\mu,\sigma^2)$。令参数$\theta &#x3D; (\mu,\sigma^2)’$。现有$x_1,x_2,\cdots,x_n$是样本。欲估计$\theta$。<br>我们可以定义似然函数为<br>$$<br>L(\theta) &#x3D; \prod_{i&#x3D;1}^n p(x_i) &#x3D; (2\pi\sigma^2)^{-n&#x2F;2} \exp{- \frac{1}{2\sigma^2} \sum_{i&#x3D;1}^n(x_i - \mu)^2 } .<br>$$<br>其对数似然函数为<br>$$<br>l(\theta) &#x3D; \ln L(\theta) &#x3D; -\frac{n}{2}\ln(2\pi) -\frac{n}{2} \ln (\sigma^2) - \frac{1}{2\sigma^2} \sum_{i&#x3D;1}^n(x_i - \mu)^2.<br>$$<br>关于$\mu$和$\sigma^2$分别求偏导，即<br>$$<br>\frac{\partial l}{\partial \mu} &#x3D; \frac{1}{\sigma^2} \sum_{i&#x3D;1}^n(x_i - \mu) &#x3D; 0,<br>$$</li>
</ul>
<p>$$<br>\frac{\partial l}{\partial \sigma^2} &#x3D; - \frac{n&#x2F;2}{\sigma^2} + \frac{1}{2\sigma^4} \sum_{i&#x3D;1}^n(x_i - \mu)^2&#x3D; 0.<br>$$</p>
<p>于是，我们可以得到最大似然估计为<br>$$<br>\hat{\mu} &#x3D; \bar{x}, \hat{\sigma}^2 &#x3D; s_n^2 &#x3D; \frac{1}{n}\sum_{i&#x3D;1}^n (x_i-\bar{x})^2.<br>$$</p>
<h3 id="区间估计（Interval-Estimation）"><a href="#区间估计（Interval-Estimation）" class="headerlink" title="区间估计（Interval Estimation）"></a>区间估计（Interval Estimation）</h3><h4 id="枢轴量法"><a href="#枢轴量法" class="headerlink" title="枢轴量法"></a>枢轴量法</h4><p>例：现有$x_1,x_2,\cdots,x_n\sim N(\mu,\sigma^2)$。欲给出$\mu$置信水平为$1-\alpha$的置信区间。</p>
<ol>
<li>如果$\sigma^2$已知，我们记$\sigma^2 &#x3D;\sigma^2_0 $。</li>
</ol>
<ul>
<li>点估计：$\hat{\mu} &#x3D; \bar{x}$；</li>
<li>分布：$\bar{x} \sim N(\mu,\sigma_0^2&#x2F;n)$；</li>
<li>标准化：$\frac{\hat{\mu}-\mu}{\sqrt{\sigma_0^2&#x2F;n}} \sim N(0,1)$；这里$\frac{\hat{\mu}-\mu}{\sqrt{\sigma_0^2&#x2F;n}}$就是所定义的枢轴量；</li>
<li>可以确定c_1,c_2分别为$\pm z_{1-\alpha&#x2F;2}$使得<br>$$<br>P(c_1\leq \frac{\hat{\mu}-\mu}{\sqrt{\sigma_0^2&#x2F;n}}\leq c_2) &#x3D; 1-\alpha<br>$$</li>
<li>关注这个区间${-z_{1-\alpha&#x2F;2} \leq \frac{\bar{x}-\mu}{\sqrt{\sigma_0^2&#x2F;n}}\leq z_{1-\alpha&#x2F;2}}$可以转化为<br>$$<br>\bar{x} - z_{1-\alpha&#x2F;2} \sqrt{\sigma_0^2&#x2F;n}\leq \mu \leq \bar{x} +z_{1-\alpha&#x2F;2} \sqrt{\sigma_0^2&#x2F;n}.<br>$$</li>
</ul>
<ol start="2">
<li><ol>
<li>如果$\sigma^2$未知，我们如何得到区间估计？</li>
</ol>
</li>
</ol>
<ul>
<li>点估计：$\hat{\mu} &#x3D; \bar{x}$；</li>
<li>分布：$\bar{x} \sim N(\mu,\sigma_0^2&#x2F;n)$；</li>
<li>标准化：$\frac{\hat{\mu}-\mu}{\sqrt{\sigma_0^2&#x2F;n}} \sim N(0,1)$；</li>
<li>因为$\sigma^2$未知，我们用$\hat{\sigma}^2$代替$\sigma^2$，即枢轴量为<br>$$<br>G &#x3D; $\frac{\hat{\mu}-\mu}{\sqrt{\hat{\sigma}^2&#x2F;n}} \sim t(n-1)$<br>$$</li>
<li>可以确定c_1,c_2分别为$\pm t_{1-\alpha&#x2F;2}(n-1)$使得<br>$$<br>P(c_1\leq \frac{\hat{\mu}-\mu}{\sqrt{\sigma_0^2&#x2F;n}}\leq c_2) &#x3D; 1-\alpha<br>$$</li>
<li>关注这个区间${-t_{1-\alpha&#x2F;2}(n-1)\leq \frac{\bar{x}-\mu}{\sqrt{\sigma_0^2&#x2F;n}}\leq t_{1-\alpha&#x2F;2}(n-1)}$可以转化为<br>$$<br>\bar{x} - t_{1-\alpha&#x2F;2}(n-1) \sqrt{\sigma_0^2&#x2F;n}\leq \mu \leq \bar{x} +t_{1-\alpha&#x2F;2}(n-1) \sqrt{\sigma_0^2&#x2F;n}.<br>$$</li>
</ul>
<h2 id="Part-Three：Hypothesis-Testing"><a href="#Part-Three：Hypothesis-Testing" class="headerlink" title="Part Three：Hypothesis Testing"></a>Part Three：Hypothesis Testing</h2><p>这里我们考虑正态总体分布的参数假设检验。</p>
<h3 id="单个正态分布"><a href="#单个正态分布" class="headerlink" title="单个正态分布"></a>单个正态分布</h3><p>背景问题：研究大厂的程序员的平均年龄是否不大于35岁？</p>
<p>例：$x_1,x_2,\cdots,x_n \sim N(\mu,\sigma^2)$。</p>
<ol>
<li>如果$\sigma^2$已知。欲检验<br>$$<br>H_0: \mu &#x3D; \mu_0 \quad \text{vs} \quad H_1: \mu&gt; \mu_0.<br>$$<br>我们希望构造的拒绝域为$W &#x3D; {\bar{x} &gt; c}$。接下来，我们的核心问题是$c$是多少？考虑在原假设成立时，$P(\bar{x}&gt;c|H_0) \leq \alpha$。当原假设成立时，<br>$$<br>\bar{x} \sim N(0,\sigma^2).<br>$$<br>那么这个概率<br>$$<br>\alpha\geq P(\bar{x}&gt;c|H_0) &#x3D; P(\bar{x}&#x2F;\sqrt{\sigma^2&#x2F;n}&gt;c&#x2F;\sqrt{\sigma^2&#x2F;n}) &#x3D; 1- \Phi(c&#x2F;\sqrt{\sigma^2&#x2F;n})<br>$$<br>于是，$c &#x3D; z_{1-\alpha} \sqrt{\sigma^2&#x2F;n}$。所以，拒绝域为$W &#x3D; {\bar{x} &gt;   z_{1-\alpha} \sqrt{\sigma^2&#x2F;n}} &#x3D; {\bar{x}&#x2F;\sqrt{\sigma^2&#x2F;n} &gt;z_{1-\alpha}  }$。这里$\bar{x}&#x2F;\sqrt{\sigma^2&#x2F;n}$是检验统计量。</li>
<li>如果$\sigma^2$未知。欲检验<br>$$<br>H_0: \mu \leq \mu_0 \quad \text{vs} \quad H_1: \mu&gt; \mu_0.<br>$$<br>检验统计量为$\bar{x}&#x2F;\sqrt{\hat{\sigma}^2&#x2F;n}$，其拒绝域为${\bar{x}&#x2F;\sqrt{\hat{\sigma}^2&#x2F;n} &gt;t_{1-\alpha}(n-1)  }$</li>
<li>如果$\sigma^2$未知。欲检验<br>$$<br>H_0: \mu &#x3D; \mu_0 \quad \text{vs} \quad H_1: \mu \neq \mu_0.<br>$$<br>检验统计量为$\bar{x}&#x2F;\sqrt{\hat{\sigma}^2&#x2F;n}$，其拒绝域为${\left|\bar{x}&#x2F;\sqrt{\hat{\sigma}^2&#x2F;n}\right| &gt;t_{1-\alpha&#x2F;2}(n-1) }$</li>
</ol>
<ul>
<li>$p$值是当前样本及其更极端情况发生的概率。当$p&lt;\alpha$，则拒绝原假设。</li>
</ul>
<h3 id="两个正态分布"><a href="#两个正态分布" class="headerlink" title="两个正态分布"></a>两个正态分布</h3><p>例：有两个独立样本$x_1,x_2,\cdots,x_m \sim N(\mu_1,\sigma^2)$和$y_1,y_2,\cdots,y_n \sim N(\mu_2,\sigma^2)$。这里$\sigma^2$未知。<br>令$\theta &#x3D; \mu_1- \mu2$。欲检验<br>$$<br>H_0: \theta &#x3D; 0 \quad \text{vs} \quad H_1: \theta \neq 0.<br>$$<br>检验统计量为<br>$$<br>t &#x3D; \frac{\bar{x} - \bar{y}}{\sqrt{s_w^2 (1&#x2F;m+1&#x2F;n)}} .<br>$$<br>其拒绝域为 ${|t| &gt; t_{1-\alpha&#x2F;2}(m+n-2)}$.</p>
<ul>
<li>假设检验与区间估计是相对应的。</li>
</ul>
]]></content>
      <categories>
        <category>ECNU</category>
      </categories>
  </entry>
  <entry>
    <title>OTA差分升级技术</title>
    <url>/blog/ota-diffpatch-algorithm/</url>
    <content><![CDATA[<div class="note info">

<ul>
<li>OTA差分升级，主要是解决整车OTA升级中升级包更新推送不必全量推送的问题。</li>
<li>差分算法用于减小升级包体积，从而缩短下载时间、节省网络带宽、减少用户流量使用。</li>
<li>本文主要介绍几种差分算法，并实践应用一种常见的差分算法。</li>
</ul>
</div>

<span id="more"></span>

<h2 id="差分介绍"><a href="#差分介绍" class="headerlink" title="差分介绍"></a>差分介绍</h2><p>例如，一个新版本的升级包1G，通过云端差分服务，可以把两个新旧版本的升级包之间有差异的地方抽离出来新生成一个比较小的差分包，这个差分包的体积仅为整包大小的5%-20%，云端只要向车端推送这个比较小的差分包，车端拿到差分包之后，再通过对应的差分还原算法，利用旧包和拿到的差分包还原成新的升级包实现升级包的替换安装。</p>
<h3 id="常见差分算法"><a href="#常见差分算法" class="headerlink" title="常见差分算法"></a>常见差分算法</h3><p>OTA差分算法，常见的开源方案有bsdiff、hdiffpatch、xdelta3等：</p>
<ul>
<li><p>bsdiff：这是一种高效的文件差分算法，常用于生成二进制文件的差异。它在 OTA 更新中被广泛使用。</p>
<blockquote>
<p>项目链接：<a href="http://www.daemonology.net/bsdiff/">http://www.daemonology.net/bsdiff/</a></p>
</blockquote>
</li>
<li><p>hdiffpatch：这是一个开源的差分和补丁库，可以在二进制文件或目录之间进行差分和补丁。它运行速度快，生成的差分小，支持大文件，且在差分和补丁时内存需求较小。</p>
<blockquote>
<p>项目链接：<a href="https://github.com/sisong/HDiffPatch">https://github.com/sisong/HDiffPatch</a></p>
</blockquote>
</li>
<li><p>xdelta3：这是一个开源的二进制文件差分算法，它可以生成和应用 VCDIFF 格式的差分和补丁。</p>
<blockquote>
<p>项目链接：<a href="https://github.com/jmacd/xdelta">https://github.com/jmacd/xdelta</a></p>
</blockquote>
</li>
<li><p>courgette：这是 Google Chrome 使用的差分算法，它特别适合于生成二进制可执行文件的差分。</p>
<blockquote>
<p>项目链接：<a href="https://chromium.googlesource.com/chromium/src/courgette/">https://chromium.googlesource.com/chromium/src/courgette/</a></p>
</blockquote>
</li>
</ul>
<h3 id="商业解决方案"><a href="#商业解决方案" class="headerlink" title="商业解决方案"></a>商业解决方案</h3><ul>
<li><a href="https://www.abupdate.com/index.php?catid=78">艾拉比汽车OTA升级解决方案</a></li>
</ul>
<h2 id="算法实践"><a href="#算法实践" class="headerlink" title="算法实践"></a>算法实践</h2><p>上述几种差分算法都可以完成对升级软件包生成差分包，其中hdiffpatch是开源且性能比较好、占用内存比较少的方案，下面针对该算法做一个详细介绍，并最终利用该算法实现一个REST API供业务调用。</p>
<p>hidffpath的源代码托管在Github上，可以在<a href="https://github.com/sisong/HDiffPatch">这里</a>查看和下载。</p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>hdiffpatch 包含两个主要的工具：hdiff 和 hpatch：</p>
<ul>
<li><p>hdiff：这个工具用于生成两个文件之间的差分。它会比较两个文件的内容，找出它们的差异，然后生成一个差分文件。这个差分文件可以用来将旧版本的文件更新到新版本。</p>
</li>
<li><p>hpatch：这个工具用于将差分应用到旧版本的文件上，生成新版本的文件。它会读取旧版本的文件和差分文件，然后根据差分文件的指示修改旧版本的文件，生成新版本的文件。</p>
</li>
</ul>
<p>其接口实现在<code>hdiffz.cpp</code>和<code>hpatch.c</code>文件中，包含了 hdiffpatch 的主要接口:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">hdiff_cmd_line</span><span class="params">(<span class="type">int</span> argc,<span class="type">const</span> <span class="type">char</span> * argv[])</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">hdiff</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* oldFileName,<span class="type">const</span> <span class="type">char</span>* newFileName,<span class="type">const</span> <span class="type">char</span>* outDiffFileName,</span></span></span><br><span class="line"><span class="params"><span class="function">          <span class="type">const</span> hdiff_TCompress* compressPlugin,<span class="type">const</span> TDiffSets&amp; diffSets)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">hpatch</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* oldFileName,<span class="type">const</span> <span class="type">char</span>* diffFileName,<span class="type">const</span> <span class="type">char</span>* outNewFileName,</span></span></span><br><span class="line"><span class="params"><span class="function">           hpatch_BOOL isLoadOldAll,<span class="type">size_t</span> patchCacheSize,hpatch_StreamPos_t diffDataOffert,</span></span></span><br><span class="line"><span class="params"><span class="function">           hpatch_StreamPos_t diffDataSize,hpatch_BOOL vcpatch_isChecksum,hpatch_BOOL vcpatch_isInMem)</span></span>;</span><br></pre></td></tr></table></figure>

<p>基于源码自行封装接口参数后得到以下接口：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ota_diff</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *old_path, <span class="type">const</span> <span class="type">char</span> *new_path, <span class="type">const</span> <span class="type">char</span> *diff_path)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ota_patch</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *diff_path, <span class="type">const</span> <span class="type">char</span> *old_path, <span class="type">const</span> <span class="type">char</span> *new_path)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><ul>
<li><p>Linux</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> https://github.com/sisong/HDiffPatch</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> HDiffPatch</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> https://github.com/sisong/bzip2.git ../bzip2</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> https://github.com/sisong/libmd5.git ../libmd5</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> https://github.com/sisong/lzma.git ../lzma</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> https://github.com/sisong/zstd.git ../zstd</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make LZMA=1 ZSTD=1 MD5=1 BZIP2=1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Android </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1.下载安装 Android NDK</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">wget https://dl.google.com/android/repository/android-ndk-r21d-linux-x86_64.zip</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">unzip android-ndk-r21d-linux-x86_64.zip</span></span><br><span class="line"></span><br><span class="line">2.执行build_libs.sh</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> HDiffPatch/builds/android_ndk_jni_mk</span></span><br><span class="line"></span><br><span class="line">3.在安卓项目中添加 HPatch.java 和 libhpatchz.so 文件，java 代码就可以调用 patch 函数了</span><br><span class="line">  所在路径 HDiffPatch/builds/android_ndk_jni_mk/java/</span><br></pre></td></tr></table></figure>
</li>
<li><p>Cross Compile</p>
<ul>
<li>针对不同平台ECU，利用不同交叉编译工具编译相应平台的还原库。</li>
</ul>
</li>
</ul>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ul>
<li><p>把hdiffpatch源文件编译成Linux下的动态库，Java侧调用动态库libhdiffpatch.so</p>
</li>
<li><p>把libhdiffpatch.so文件放在src&#x2F;main&#x2F;resource&#x2F;linux-x86-64&#x2F;文件夹下</p>
</li>
<li><p>Maven引入JNA</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;net.java.dev.jna&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jna&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.10.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

  <details>
      <summary>
          PS.
      </summary>
      <ol>
          要用Java调用C的接口需要用到JNI，过程较为晦涩繁琐，此处采用JNA调用C代码。
          <li>JNA provides Java programs easy access to native shared libraries without writing anything but Java code - no JNI or native code is required.</li>
          <li>Doc：https://java-native-access.github.io/jna/5.10.0/javadoc/index.html</li>
      </ol>
  </details></li>
<li><p>创建HDiff类</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hh.ota.diff;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.jna.Library;</span><br><span class="line"><span class="keyword">import</span> com.sun.jna.Native;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HDiff</span> <span class="keyword">extends</span> <span class="title class_">Library</span>&#123;</span><br><span class="line">    <span class="type">HDiff</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> (HDiff) Native.load(<span class="string">&quot;hdiffpatch&quot;</span>, HDiff.class);</span><br><span class="line">    <span class="comment">//diff usage: ota_hdiff [options] oldPath newPath outDiffFile</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">ota_hdiff</span><span class="params">(String oldData, String newData, String outPatchFile, <span class="type">long</span> size)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>创建HPatch类</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hh.ota.patch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.jna.Library;</span><br><span class="line"><span class="keyword">import</span> com.sun.jna.Native;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HPatch</span> <span class="keyword">extends</span> <span class="title class_">Library</span> &#123;</span><br><span class="line">    <span class="type">HPatch</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> (HPatch) Native.load(<span class="string">&quot;hdiffpatch&quot;</span>, HPatch.class);</span><br><span class="line">    <span class="comment">//patch usage: ota_hpatch [options] oldPath diffFile outNewPath</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">ota_hpatch</span><span class="params">(String oldPath, String diffFile, String outNewPath)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>创建FileUtils类</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hh.ota.cache;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileUtils</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Verify if the file exists, if not, throw an exception</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filePath：local file path</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> FileNotFoundException if filePath not exist</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">requireFileExist</span><span class="params">(String filePath)</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(filePath);</span><br><span class="line">        <span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FileNotFoundException</span>(filePath);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>JNA实例化</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> oldFile：old version file path</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> newFile：new version file path</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> diffFile：diff package file path</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> FileNotFoundException if oldFile or newFile not exist</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">diff</span><span class="params">(String oldFile, String newFile, String diffFile)</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">    FileUtils.requireFileExist(oldFile);</span><br><span class="line">    FileUtils.requireFileExist(newFile);</span><br><span class="line">    HDiff.INSTANCE.hdiffz(oldFile,newFile, diffFile, <span class="number">1024</span>*<span class="number">1024</span>*<span class="number">128</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> oldPath：old version file path</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> diffPath：diff package file path</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> outNewPath：patch out file path</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> FileNotFoundException if oldFile or patchFile not exist</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">patch</span><span class="params">(String oldPath, String diffPath, String outNewPath)</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">    FileUtils.requireFileExist(oldPath);</span><br><span class="line">    FileUtils.requireFileExist(diffPath);</span><br><span class="line">    HPatch.INSTANCE.hpatchz(oldPath, diffPath, outNewPath);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>创建调用主类</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">oldFile</span> <span class="operator">=</span> <span class="string">&quot;/home/jack_xie/cloud_api_java/bigFile/soc_old.zip&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">newFile</span> <span class="operator">=</span> <span class="string">&quot;/home/jack_xie/cloud_api_java/bigFile/soc_new.zip&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">diffFile</span> <span class="operator">=</span> <span class="string">&quot;/home/jack_xie/cloud_api_java/bigFile/soc_diff.zip&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">outNewPath</span> <span class="operator">=</span> <span class="string">&quot;/home/jack_xie/cloud_api_java/bigFile/soc_patch.zip&quot;</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        diff(oldFile, newFile, diffFile);</span><br><span class="line">        patch(oldFile, diffFile, outNewPath);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Java层调用接口结果<br><img src="https://s2.loli.net/2022/08/24/63WebGDpNZHvYTy.png" alt="image.png"></p>
</li>
<li><p>Java层封装REST接口<br>将上述 Java 方法封装成 REST API供外部调用，使用 Spring Boot 框架实现。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Works</category>
      </categories>
  </entry>
  <entry>
    <title>Python String Processing Tips &amp; Tricks</title>
    <url>/blog/python-string-tips/</url>
    <content><![CDATA[<div class="note info">

<p>  <a href="https://zh.wikipedia.org/wiki/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86">自然语言处理</a>和文本分析是研究和应用的热点领域，在深入实践之前需要掌握一些基本的字符串操作和处理技巧，本文来梳理总结一下一些基本的<code>Python处理字符串</code>的操作。</p>
</div>

<span id="more"></span>

<p>必须掌握两种字符串处理技巧：首先是正则表达式，<strong>一种基于模式的文本匹配方法</strong>。关于正则表达式有许多精彩的介绍，但是喜欢通过视频学习的朋友仍然可以从这个视频中受益良多：<a href="https://youtu.be/Q1zLqfnEXdw?list=PLtmWHNX-gukKocXQOkQjuVxglSDYWsSh9&t=630">fast.ai代码 -初涉自然语言处理</a></p>
<p>另一个必备的字符串处理技能是：<strong>能够利用给定编程语言的标准库进行基本的字符串操作</strong>。为此，本文便是一个简短的Python字符串处理入门教程，旨在为那些以文本分析作为职业的人士寻求更为深入的研究，抛砖引玉。</p>
<p>注意，有实际意义的文本分析远远超出字符串处理的范畴，那些更先进的核心技术可能不需要你频繁的亲自对文本进行操作。然而，对于一个成功的文本分析项目来说，文本数据预处理是非常重要而耗时的环节，所以，本文涵盖的字符串处理技能将很有价值。在基础层面上理解文本的计算处理对于理解更为先进的文本分析技术同样重要。</p>
<p>文中的一些示例使用Python标准库：string module字符串模块，为此，最好准备好string module以备参考。</p>
<p>string module字符串模块链接：<a href="https://docs.python.org/2/library/string.html">https://docs.Python.org/2/library/string.html</a></p>
<h4 id="空格剥离"><a href="#空格剥离" class="headerlink" title="空格剥离"></a>空格剥离</h4><p>lstrip() 剥离前导空格<br>rstrip() 剥离尾随空格<br>strip()  剥离前导和尾随空格</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&#x27;     This is a sentence with whitespace.     \n&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(s.lstrip()))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(s.rstrip()))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(s.strip()))</span><br></pre></td></tr></table></figure>
<p>剥离除空格以外的字符只需传递要剥离的字符即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&#x27;This is a sentence with unwanted characters.AAA&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(s.rstrip(<span class="string">&#x27;A)))</span></span><br></pre></td></tr></table></figure>
<p><a href="https://docs.python.org/3/library/stdtypes.html#str.format">format()文档</a></p>
<h4 id="字符串拆分"><a href="#字符串拆分" class="headerlink" title="字符串拆分"></a>字符串拆分</h4><p>split()将字符串拆分成较小的子字符串列表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&#x27;This is a sentence&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(s.split())</span><br></pre></td></tr></table></figure>
<p><a href="https://docs.python.org/3/library/stdtypes.html#str.split">split()文档</a></p>
<h4 id="列表元素合并成字符串"><a href="#列表元素合并成字符串" class="headerlink" title="列表元素合并成字符串"></a>列表元素合并成字符串</h4><p>join()与split()互为逆方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = [<span class="string">&#x27;This&#x27;</span>, <span class="string">&#x27;is&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;sentence&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27; &#x27;</span>.join(s))</span><br></pre></td></tr></table></figure>
<p><a href="https://docs.python.org/3/library/stdtypes.html#str.join">join()文档</a></p>
<h4 id="字符串反转"><a href="#字符串反转" class="headerlink" title="字符串反转"></a>字符串反转</h4><p>Python无内置字符串反转方法,可以先将字符串看做是字符的列表,再利用反转列表元素的方式进行反转。</p>
<h4 id="大小写转换"><a href="#大小写转换" class="headerlink" title="大小写转换"></a>大小写转换</h4><p>用upper(), lower(), 和swapcase()方法可以进行大小写之间的转换。<br><a href="https://docs.python.org/3/library/stdtypes.html#str.upper">upper()文档</a><br><a href="https://docs.python.org/3/library/stdtypes.html#str.lower">lower()文档</a><br><a href="https://docs.python.org/3/library/stdtypes.html#str.swapcase">swapcase()文档</a></p>
<h4 id="检查是否有字符串成员"><a href="#检查是否有字符串成员" class="headerlink" title="检查是否有字符串成员"></a>检查是否有字符串成员</h4><p>在Python中检查字符串成员的最简单方法是使用in运算符，语法与自然语言非常类似。<br>如果对找到字符串中子字符串的位置更感兴趣（而不是简单地检查是否包含子字符串），则利用find()方法更为有效。</p>
<h4 id="字符串替换"><a href="#字符串替换" class="headerlink" title="字符串替换"></a>字符串替换</h4><p>找到子字符串之后，如果想替换这一子字符串，该怎么办？Python 中的replace()字符串方法将解决这一问题。<br><a href="https://docs.python.org/3/library/stdtypes.html#str.replace">replace()文档</a></p>
<h4 id="组合多个列表的输出"><a href="#组合多个列表的输出" class="headerlink" title="组合多个列表的输出"></a>组合多个列表的输出</h4><p>zip()将多个字符串列表组合在一起</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">countries = [<span class="string">&#x27;China&#x27;</span>, <span class="string">&#x27;USA&#x27;</span>]</span><br><span class="line">cities = [<span class="string">&#x27;Shanghai&#x27;</span>, <span class="string">&#x27;NewYork&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> x, y <span class="keyword">in</span> <span class="built_in">zip</span>(countries,cities):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;The biggest cit of &#123;&#125; is &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(x, y))</span><br></pre></td></tr></table></figure>
<p><a href="https://docs.python.org/3/library/functions.html#zip">zip文档</a></p>
<h4 id="同字母异序词检查"><a href="#同字母异序词检查" class="headerlink" title="同字母异序词检查"></a>同字母异序词检查</h4><p>想检查一对字符串中，其中一个字符串是否是另一个字符串的同字母异序词？从算法上来讲，需要做的是对每个字符串中每个字母的出现次数进行计数，再检查二者计数值是否相等，直接使用collections模块的Counter类便可实现。<br><a href="https://docs.python.org/3/library/collections.html#collections.Counter">collections模块的Counter类</a></p>
<h4 id="回文检查"><a href="#回文检查" class="headerlink" title="回文检查"></a>回文检查</h4><p>如果想检查给定的单词是否是回文，怎么办？从算法上看，需要创建一个单词的反转，然后利用 &#x3D;&#x3D; 运算符来检查这2个字符串（原始字符串和反向字符串）是否相等。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">is_palindrome</span>(<span class="params">s</span>):</span><br><span class="line">    reverse = s[::-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span>(s == reverse)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>虽然掌握这些字符串处理“技巧”之后，并不意味着你已经成为了文本分析或自然语言处理专家，但这些技巧可能会激发出深入探究自然语言处理领域的兴趣，并掌握最终成为专家所必备的技能。</p>
<p><a href="https://www.kdnuggets.com/2018/03/text-data-preprocessing-walkthrough-Python.html">文本数据预处理：Python演练</a><br><a href="https://www.kdnuggets.com/2018/11/text-preprocessing-Python.html">Python中的·文本预处理：步骤、工具和示例</a><br><a href="https://www.kdnuggets.com/2019/05/complete-exploratory-data-analysis-visualization-text-data.html">文本数据分析完整探索与可视化：可视化与NLP相结合</a></p>
<p>原文链接：<a href="https://www.kdnuggets.com/2020/01/Python-string-processing-primer.html">10 Python String Processing Tips &amp; Tricks</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>字节跳动2022春招研发笔试第六场4.10-算法方向</title>
    <url>/blog/recruitment-bytedance-2022-04-10/</url>
    <content><![CDATA[<div class="note info">

<ul>
<li>涨潮淹没岛屿考察深度优先搜索（DFS）在二维网格上的应用，主要目标是找到二维网格中的岛屿（由1组成的连通区域），并将与边界相连的岛屿“淹没”（将1变为0）</li>
<li>网球装箱、网球装箱主要考察排序（Sorting）和线性扫描（Linear Scan）相关知识点以及对一维、二维数组的基本读取和操作。</li>
<li>集齐卡牌用了贪心算法（Greedy Algorithm）和哈希表（Hash Table）的数据结构知识点来解决问题，每次都选择覆盖剩余最多元素的商品，直到所有元素都被覆盖。</li>
</ul>
</div>

<span id="more"></span>

<h2 id="涨潮淹没岛屿"><a href="#涨潮淹没岛屿" class="headerlink" title="涨潮淹没岛屿"></a>涨潮淹没岛屿</h2><p>有一个矩阵，矩阵中每个数字代表一块海洋&#x2F;土地块（数字1代表土地，数字0代表海洋），每块土地仅与上下左右四块其他的土地块&#x2F;海洋接壤。矩阵边缘以外视为土地。</p>
<p>涨潮时，与海洋接壤两个或者两格以上的土地块将被淹没为海洋。请返回涨潮后的矩阵。</p>
<p>输入描述：</p>
<blockquote>
<p>1.第一行包含一个数字T，代表总共有T个案例。<br>2.以下重复T次：<br>a. 第一行包含空格分隔的两个数字M和N，代表矩阵高M、宽N。<br>b. 后续M行，每一行都包含一个长度为N的，由0&#x2F;1组成的数组。</p>
</blockquote>
<p>输出描述：</p>
<blockquote>
<p>返回涨潮后的矩阵。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Input:</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">3 4</span></span><br><span class="line"><span class="comment">1011</span></span><br><span class="line"><span class="comment">0000</span></span><br><span class="line"><span class="comment">0010</span></span><br><span class="line"><span class="comment">1 2</span></span><br><span class="line"><span class="comment">01</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Output:</span></span><br><span class="line"><span class="comment">0001</span></span><br><span class="line"><span class="comment">0000</span></span><br><span class="line"><span class="comment">0000</span></span><br><span class="line"><span class="comment">01</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid, <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= grid.<span class="built_in">size</span>() || j &gt;= grid[<span class="number">0</span>].<span class="built_in">size</span>() || grid[i][j] != <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        grid[i][j] = <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(grid, i - <span class="number">1</span>, j);</span><br><span class="line">        <span class="built_in">dfs</span>(grid, i + <span class="number">1</span>, j);</span><br><span class="line">        <span class="built_in">dfs</span>(grid, i, j - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">dfs</span>(grid, i, j + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">floodIslands</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid) &#123;</span><br><span class="line">        <span class="type">int</span> m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i * j == <span class="number">0</span> || i == m - <span class="number">1</span> || j == n - <span class="number">1</span> || grid[i][j] == <span class="number">0</span>)</span><br><span class="line">                    <span class="built_in">dfs</span>(grid, i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                grid[i][j] = grid[i][j] == <span class="number">2</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> grid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="type">int</span> M, N;</span><br><span class="line">        cin &gt;&gt; M &gt;&gt; N;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">grid</span>(M, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(N));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; M; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">                cin &gt;&gt; grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Solution solution;</span><br><span class="line">        grid = solution.<span class="built_in">floodIslands</span>(grid);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; row : grid) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> val : row) &#123;</span><br><span class="line">                cout &lt;&lt; val;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="机器人能否走到最后"><a href="#机器人能否走到最后" class="headerlink" title="机器人能否走到最后"></a>机器人能否走到最后</h2><p>小明设计了一个简单的机器人，它每移动一步至少需要消耗一个能量值。例如当小明给它输入5个能量值的时候，它可能会走0步（也就是不动），也可能走1步，但是不会走超过5步。<br>小明希望机器人往前走N步，每个位置有不同的能量值，每次消耗了能量值之后可以往前走几步，到达新的位置之后，可以继续消耗当前位置的能量值，继续往前。如果当前位置的能量值为0，那么机器人就无法行动了。<br>小明现在的疑惑是，机器人是否有机会移动到最后一个指令，你可以帮他计算一下吗？</p>
<p>输入描述：</p>
<blockquote>
<p>第一行N代表总共有多少个位置，第二行是空格分割的每个位置能量值，总共有N个。</p>
</blockquote>
<p>输出描述：</p>
<blockquote>
<p>判断机器人是否能够到达最后一个位置，如果可以到达的话，输出TRUE否则输出FALSE。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Input: </span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">2 3 1 1 4</span></span><br><span class="line"><span class="comment">Output:</span></span><br><span class="line"><span class="comment">TRUE</span></span><br><span class="line"><span class="comment">Explain:</span></span><br><span class="line"><span class="comment">2→3→4 √</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Input:</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">3 2 1 0 4</span></span><br><span class="line"><span class="comment">Output:</span></span><br><span class="line"><span class="comment">FALSE</span></span><br><span class="line"><span class="comment">Explain:</span></span><br><span class="line"><span class="comment">3→0 ×</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canJump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> rightmost = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt;= rightmost) &#123;</span><br><span class="line">                rightmost = <span class="built_in">max</span>(rightmost, i + nums[i]);</span><br><span class="line">                <span class="keyword">if</span> (rightmost &gt;= n - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nums</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    Solution solution;</span><br><span class="line">    cout &lt;&lt; (solution.<span class="built_in">canJump</span>(nums) ? <span class="string">&quot;TRUE&quot;</span> : <span class="string">&quot;FALSE&quot;</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="网球装箱"><a href="#网球装箱" class="headerlink" title="网球装箱"></a>网球装箱</h2><p>字节网球部门有一套特殊的装箱姿势：首先取出N个网球桶和K个网球，给每个网球依次印上编号（1,2,3,…,k）。接着按照编号从小到大的顺序依次取出每个网球，对于每个网球，随机找一个网球桶，从任意一个开口塞进去。<br>波波现在要对一批产品进行质量检测，请帮他判断这箱网球是否严格遵循了上述装箱流程。</p>
<p>输入描述：</p>
<blockquote>
<p>第一行为一个整数T表示test case数量<br>对于每组输入数据，第一行为一个整数N，表示网球桶数<br>接下来N行，每行第一个数字为K1，表示第1个桶包含多少网球；后面跟K1个数字，表示该桶中每个网球的编号（按顺序）。<br>输入保证每组test case中不会有两个网球编号相同，且网球编号一定会覆盖1-k<br>1≤T≤10<br>1≤N&lt;10<br>0≤Ki≤1e5<br>1≤∑Ki≤1e7</p>
</blockquote>
<p>输出描述:</p>
<blockquote>
<p>对于每组测试数据，输出一行。如果判断装箱方式符合规定，输出数字1，否则输出数字0。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Input:</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">1 1</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">5 5 4 3 2 1</span></span><br><span class="line"><span class="comment">4 9 6 7 8</span></span><br><span class="line"><span class="comment">Output:</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Input:</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">0</span></span><br><span class="line"><span class="comment">5 1 2 5 4 3</span></span><br><span class="line"><span class="comment">4 6 9 8 7</span></span><br><span class="line"><span class="comment">Output:</span></span><br><span class="line"><span class="comment">0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; balls)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; balls.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (balls[i] &lt; balls[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minBalls</span><span class="params">(<span class="type">int</span> T, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; balls;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; data.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; data[i].<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                    balls.<span class="built_in">push_back</span>(data[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">sort</span>(balls.<span class="built_in">begin</span>(), balls.<span class="built_in">end</span>());</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">check</span>(balls) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; data;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="type">int</span> N;</span><br><span class="line">        cin &gt;&gt; N;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; balls;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> K;</span><br><span class="line">            cin &gt;&gt; K;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; K; ++j) &#123;</span><br><span class="line">                <span class="type">int</span> ball;</span><br><span class="line">                cin &gt;&gt; ball;</span><br><span class="line">                balls.<span class="built_in">push_back</span>(ball);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        data.<span class="built_in">push_back</span>(balls);</span><br><span class="line">    &#125;</span><br><span class="line">    Solution solution;</span><br><span class="line">    cout &lt;&lt; solution.<span class="built_in">minBalls</span>(T, data) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="集齐卡牌"><a href="#集齐卡牌" class="headerlink" title="集齐卡牌"></a>集齐卡牌</h2><p>某商品在促销时推出了集换活动，集齐全套卡片即可获得神秘大奖，集换活动的规侧如下：<br>1.每次购买都可以获得三张集换卡<br>2.一套集换卡中包含10种不同的卡片（用0-9标识）假设你知道每件商品中包含的集换卡，请判断输出集齐整套卡片最少需要购买几件商品</p>
<p>输入描述：</p>
<blockquote>
<p>输入分为一行，每行包含M个字符串，每个字符串代表一件商品，每个字符串由3个数字组成，不同的数字代表不同的集换卡。</p>
</blockquote>
<p>输出描述：</p>
<blockquote>
<p>如果不能集齐，输出-1，否则输出集齐一套集换卡所需购买商品数量的最小值.</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Input:</span></span><br><span class="line"><span class="comment">000 111 222 345 678 891</span></span><br><span class="line"><span class="comment">Output:</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minGoods</span><span class="params">(string s, vector&lt;string&gt;&amp; goods)</span> </span>&#123;</span><br><span class="line">        <span class="type">size_t</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((pos = s.<span class="built_in">find</span>(<span class="string">&#x27; &#x27;</span>)) != string::npos) &#123;</span><br><span class="line">            goods.<span class="built_in">push_back</span>(s.<span class="built_in">substr</span>(<span class="number">0</span>, pos));</span><br><span class="line">            s.<span class="built_in">erase</span>(<span class="number">0</span>, pos + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        goods.<span class="built_in">push_back</span>(s);</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">counts</span>(goods.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; goods.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> c : goods[i]) &#123;</span><br><span class="line">                counts[i][c - <span class="string">&#x27;0&#x27;</span>] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">total</span><span class="params">(<span class="number">10</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; count : counts) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">                total[i] += count[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (*<span class="built_in">min_element</span>(total.<span class="built_in">begin</span>(), total.<span class="built_in">end</span>()) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="function">unordered_set&lt;<span class="type">int</span>&gt; <span class="title">remaining</span><span class="params">(&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;)</span></span>;</span><br><span class="line">        <span class="keyword">while</span> (!remaining.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> max_count = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> max_index = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; counts.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j : remaining) &#123;</span><br><span class="line">                    count += counts[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (count &gt; max_count) &#123;</span><br><span class="line">                    max_count = count;</span><br><span class="line">                    max_index = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (counts[max_index][i] == <span class="number">1</span>) &#123;</span><br><span class="line">                    remaining.<span class="built_in">erase</span>(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ++res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="built_in">getline</span>(cin, s);</span><br><span class="line">    vector&lt;string&gt; goods;</span><br><span class="line">    Solution solution;</span><br><span class="line">    cout &lt;&lt; solution.<span class="built_in">minGoods</span>(s, goods) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Offer</category>
      </categories>
  </entry>
  <entry>
    <title>华为2022校园招聘软件专业类4.08-机试题三道</title>
    <url>/blog/recruitment-huawei-2022-04-08/</url>
    <content><![CDATA[<div class="note info">

<ul>
<li>第一题考察模拟：涉及到对实际问题或过程的计算机算法模拟。</li>
<li>第二题是DFS在二维网格上的应用：<a href="https://leetcode.cn/problems/max-area-of-island">岛屿的最大面积</a>、连通区域的最大面积等经典题目的变体，主要考察对DFS算法和二维网格操作的理解。</li>
<li>第三题是一维动态规划：DP中经典问题<a href="https://leetcode.cn/problems/jump-game-ii">跳跃游戏</a>的一个变种，考察DP的基本知识点。</li>
</ul>
</div>

<span id="more"></span>

<h4 id="第一题（100）"><a href="#第一题（100）" class="headerlink" title="第一题（100）"></a>第一题（100）</h4><p>给出多个房间编号，两个房间之间存在单向门，根据单向门输出只能进不能出的房间编号，有且仅有一个只能进不能出的房间。</p>
<p>输入描述：</p>
<blockquote>
<p>1.第一行是单向门的数量N。<br>2.第二行开始的N行，是使用空格分隔的两个房间号，代表一个单向门。</p>
<p>说明：<br>1 &lt;&#x3D; 单向门数量 &lt;&#x3D; 100<br>房间号为int类型数字</p>
</blockquote>
<p>输出描述：</p>
<blockquote>
<p>房间的编号</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#输出只进不出的唯一的一个门🚪</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Input:</span></span><br><span class="line"><span class="string">5</span></span><br><span class="line"><span class="string">1 2</span></span><br><span class="line"><span class="string">2 3</span></span><br><span class="line"><span class="string">3 4</span></span><br><span class="line"><span class="string">2 5</span></span><br><span class="line"><span class="string">5 4</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Output:</span></span><br><span class="line"><span class="string">4</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">from_list = []</span><br><span class="line">to_list = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    a, b = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    from_list.append(a)</span><br><span class="line">    to_list.append(b)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> to_list:</span><br><span class="line">    <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> from_list:</span><br><span class="line">        <span class="built_in">print</span>(i)</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<h4 id="第二题（200）"><a href="#第二题（200）" class="headerlink" title="第二题（200）"></a>第二题（200）</h4><p>给定一个二维数组，每个元素代表地形的高度。山体是由连续的、高度大于0的格子组成的，每个山体的体积是其包含的所有格子的高度之和。请找出体积最大的山体。</p>
<p>输入描述：</p>
<blockquote>
<p>第一行包含两个整数n和m，表示二维数组的行数和列数（1 &lt;&#x3D; n, m &lt;&#x3D; 1000）。 接下来的n行，每行包含m个整数，表示地形的高度（0 &lt;&#x3D; 高度 &lt;&#x3D; 1000）。</p>
</blockquote>
<p>输出描述：</p>
<blockquote>
<p>输出一个整数，表示体积最大的山体的体积。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 岛屿的最大山体体积 dfs</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Input:</span></span><br><span class="line"><span class="comment">5 5</span></span><br><span class="line"><span class="comment">0 1 1 0 0</span></span><br><span class="line"><span class="comment">0 1 1 0 0</span></span><br><span class="line"><span class="comment">0 0 0 0 0</span></span><br><span class="line"><span class="comment">0 0 1 2 3</span></span><br><span class="line"><span class="comment">0 0 1 3 9</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Output:</span></span><br><span class="line"><span class="comment">19</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> grid[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line"><span class="type">bool</span> visited[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    visited[x][y] = <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> volume = grid[x][y];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> nx = x + dx[i], ny = y + dy[i];</span><br><span class="line">        <span class="keyword">if</span>(nx &gt;= <span class="number">0</span> &amp;&amp; nx &lt; n &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; ny &lt; m &amp;&amp; grid[nx][ny] &gt; <span class="number">0</span> &amp;&amp; !visited[nx][ny]) &#123;</span><br><span class="line">            volume += <span class="built_in">dfs</span>(nx, ny);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> volume;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            cin &gt;&gt; grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> maxVolume = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j] &gt; <span class="number">0</span> &amp;&amp; !visited[i][j]) &#123;</span><br><span class="line">                maxVolume = <span class="built_in">max</span>(maxVolume, <span class="built_in">dfs</span>(i, j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; maxVolume &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第三道（300）"><a href="#第三道（300）" class="headerlink" title="第三道（300）"></a>第三道（300）</h4><p>原题：大致是在讲给出一些网络传输设备，每台设备都有其能传输数据的最大传输距离，问从第一台设备传输数据到最后一台数据所用到的最少中转次数为多少。</p>
<p>翻译：给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p>
<p>输入描述：</p>
<blockquote>
<p>第入参通过多行字符串方式表示，例如：<br>4<br>2 3 1 1<br>字符串含义：<br>1.第一行表示总共中转设备台数：总计4台<br>2.第二行表述中转设备的最大传输能力：第一台设备最大传输距离为2km，第二胎设备最大传输距离为3km，第三台设备最大传输距离为1km，第四台设备最大传输距离为1km。</p>
</blockquote>
<p>输出描述：</p>
<blockquote>
<p>2<br>解释：<br>数据从第一台设备中转到第三台设备，再从第三台设备中转到第四台设备，传输结束，中共需中转2次。</p>
</blockquote>
<p>解题思路：</p>
<blockquote>
<p>这个题目主要考察的是动态规划的知识点。<br>在这个问题中，我们使用一个动态规划数组dp，其中dp[i]表示从位置i跳跃到数组的最后一个位置的最少跳跃次数。<br>我们从数组的倒数第二个位置开始，向前遍历，对于每个位置，如果它可以一步跳到最后一个位置，那么dp[i]就是1，否则，dp[i]就是它可以跳到的所有位置的dp值加1的最小值。<br>最后，dp[0]就是我们要求的答案。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// LeetCode 45.跳跃游戏（Jump Game Ⅱ）的一个变种题目</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Input:</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">2 3 1 1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Output:</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1000</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[MAXN];</span><br><span class="line"><span class="type">int</span> dp[MAXN];   <span class="comment">//dp[i]表示以i为开始到达最后一个节点的最小步数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    dp[n<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//遍历顺序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="comment">//递推公式</span></span><br><span class="line">        <span class="keyword">if</span>(n<span class="number">-1</span>-i &lt;= a[i])&#123;  <span class="comment">//当前位置一步就可以到达最后一个节点</span></span><br><span class="line">            dp[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;   <span class="comment">//当前位置无法一步到达最后一个节点 此时需要遍历求得最小的步数</span></span><br><span class="line">            <span class="type">int</span> min_temp = <span class="number">10000</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= a[i]; j++)&#123;</span><br><span class="line">                <span class="type">int</span> temp = dp[i + j] + <span class="number">1</span>;</span><br><span class="line">                min_temp = <span class="built_in">min</span>(min_temp, temp);</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i] = min_temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//打印输出目标dp</span></span><br><span class="line">    cout &lt;&lt; dp[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Offer</category>
      </categories>
  </entry>
  <entry>
    <title>近期技术面试问题回顾与总结</title>
    <url>/blog/recruitment-technology-review-2024/</url>
    <content><![CDATA[<div class="note info">

<ul>
<li>掌握计科五大件：<code>编译原理</code>、<code>计网</code>、<code>计组</code>、<code>操作系统</code>、<code>数据结构和算法</code>，<a href="https://imageslr.com/2020/07/08/tech-interview">常见面试题</a>.</li>
<li>具有一定的代码框架设计能力，熟悉常用<code>设计模式</code>, 有面向对象开发经验。</li>
<li>熟练掌握<code>网络编程</code>、熟悉<code>TCP/UDP</code>、<code>HTTP</code>协议及<code>Socket</code>，以及其他以太网通信协议。</li>
<li>熟练掌握<code>C++11</code>之后的语言特性，保证代码的可维护性和可扩展性。</li>
<li>掌握<code>系统构建</code>、<code>调试</code>、<code>异常分析</code>和<code>性能优化</code>的基本方法。</li>
<li>掌握<code>多线程</code>、<code>异步编程</code>等<code>并发编程</code>开发必要方法、框架和组件，掌握性能优化方法。</li>
<li>理解并能够应用各种数据<code>序列化和反序列化</code>技术，如JSON, XML, Protocol Buffers等。</li>
<li>具备较强的逻辑思维和代码阅读能力；能持续学习，钻研问题，不断提升质量和效率。</li>
</ul>
</div>

<span id="more"></span>

<h2 id="C-语言特性"><a href="#C-语言特性" class="headerlink" title="C++语言特性"></a><center>C++语言特性</center></h2><h3 id="编译链接"><a href="#编译链接" class="headerlink" title="编译链接"></a>编译链接</h3><details>
    <summary>
        点击展开
    </summary>

<p>C++的编译链接过程主要包括四个步骤：预处理、编译、汇编和链接。</p>
<ol>
<li><p><strong>预处理（Preprocessing）</strong>：这是编译过程的第一步，主要处理源代码中的预处理指令，如<code>#include</code>、<code>#define</code>等。预处理器会将所有的<code>#include</code>指令替换为对应文件的内容，处理所有的宏定义，处理条件编译指令等。预处理后的文件通常以<code>.i</code>或<code>.ii</code>为扩展名。</p>
</li>
<li><p><strong>编译（Compilation）</strong>：编译器将预处理后的代码（也就是C++源代码）转换为汇编语言。在这个过程中，编译器会检查语法错误，进行词法分析、语法分析、语义分析和优化等操作。编译后的文件通常以<code>.s</code>为扩展名。</p>
</li>
<li><p><strong>汇编（Assembly）</strong>：汇编器将编译器生成的汇编代码转换为机器语言代码，也就是目标代码。这个过程主要是将汇编指令转换为机器指令。汇编后的文件通常以<code>.o</code>或<code>.obj</code>为扩展名，这些文件被称为目标文件。</p>
</li>
<li><p><strong>链接（Linking）</strong>：链接器将一个或多个目标文件以及所需的库文件链接为一个可执行文件。在这个过程中，链接器会解析所有的符号引用，确保每个符号都有一个定义，然后将所有的目标文件和库文件合并为一个文件。链接后的文件就是我们可以执行的程序。</p>
</li>
</ol>
<p>使用GCC编译器，可以通过以下命令执行C++编译过程的每一步：</p>
<ol>
<li>预处理：使用<code>-E</code>选项进行预处理。这将只执行预处理并将结果输出到标准输出。如果你想将结果保存到文件，可以重定向输出到一个文件。例如：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">g++ -E myfile.cpp &gt; myfile.i</span><br></pre></td></tr></table></figure></li>
<li>编译：使用<code>-S</code>选项进行编译。这将执行预处理和编译，但不进行汇编，生成的汇编代码将保存到一个.s文件。例如：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">g++ -S myfile.i</span><br></pre></td></tr></table></figure></li>
<li>汇编：使用<code>-c</code>选项进行汇编。这将执行预处理、编译和汇编，但不进行链接，生成的目标代码将保存到一个.o文件。例如：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">g++ -c myfile.s</span><br></pre></td></tr></table></figure></li>
<li>链接：如果没有指定任何选项，GCC将执行所有步骤，包括链接，生成的可执行文件默认名为a.out。如果你想指定输出文件的名字，可以使用<code>-o</code>选项。例如:<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">g++ myfile.o -o myfile</span><br></pre></td></tr></table></figure></li>
</ol>
<p>拓展阅读：</p>
<ul>
<li><a href="https://taifua.com/psst-compile-link.html">《程序员的自我修养》阅读笔记 - 编译和链接</a></li>
<li><a href="https://chyyuu.gitee.io/compiler-toolbox/">《清华大学编译原理在线实验》</a></li>
</ul>
</details>



<h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><details>
    <summary>
        点击展开
    </summary>

<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>Lambda表达式是C++11引入的一个新特性，它允许定义一个匿名函数并立即使用。以下是一些常见的应用场景：</p>
<ol>
<li><strong>排序</strong>：可以使用lambda表达式定义自定义的排序规则。例如，可以使用lambda表达式对一个vector的元素进行降序排序：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">std::<span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), [](<span class="type">int</span> a, <span class="type">int</span> b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li><strong>算法</strong>：许多C++的STL算法，如std::for_each，std::transform等，都可以接受lambda表达式作为参数。例如，可以使用lambda表达式将一个vector的所有元素都增加1：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">std::for_each(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), [](<span class="type">int</span>&amp; n) &#123;</span><br><span class="line">    n++;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li><strong>线程</strong>：可以使用lambda表达式创建新的线程。例如，使用lambda表达式在一个新的线程中打印一条消息：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">([]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    std::cout &lt;&lt; <span class="string">&quot;Hello from a new thread!&quot;</span> &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;</span><br><span class="line">t.<span class="built_in">join</span>();</span><br></pre></td></tr></table></figure></li>
<li><strong>函数对象</strong>：可以使用lambda表达式创建函数对象，这对于需要回调函数的场景非常有用。例如，可以使用lambda表达式定义一个函数，该函数接受一个函数对象作为参数，并在函数内部调用这个函数对象：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> print = [](<span class="type">const</span> std::string&amp; message) &#123;</span><br><span class="line">    std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>由于匿名函数没有名字，可以直接在代码中定义和使用，因此可以更加<code>灵活地组织代码结构</code>、<code>使代码更加简洁清晰</code>、<code>实现更加精细的控制流程</code>。具体来说使用 lambda 表达式有几个主要的优点：</p>
<ol>
<li><p><strong>简洁性</strong>：lambda 表达式通常比完整的函数定义更简洁，尤其是在函数体很小的情况下。这可以使代码更易于阅读和理解。</p>
</li>
<li><p><strong>局部性</strong>：lambda 表达式定义在使用它的地方，这可以增强代码的局部性，使得读者不需要在文件中跳来跳去来查找函数的定义。</p>
</li>
<li><p><strong>闭包</strong>：lambda 表达式可以捕获其外部作用域中的变量，这使得它们可以访问和操作这些变量，即使在 lambda 表达式的定义之外。这是普通函数无法做到的。</p>
</li>
<li><p><strong>匿名性</strong>：lambda 表达式是匿名的，这意味着你不需要为它们想一个名字。这在你只需要在一个地方使用函数的情况下非常有用。</p>
</li>
<li><p><strong>兼容STL</strong>：许多标准模板库（STL）的算法，如 std::sort，std::for_each 等，都接受函数对象作为参数。使用 lambda 表达式可以方便地创建这样的函数对象。</p>
</li>
</ol>
<p>这并不意味着在工作中总是使用 lambda 表达式。在某些情况下，使用普通的函数可能更合适，例如<em>当函数体很大，或者需要在多个地方重用同一个函数时</em>。</p>
<p>拓展阅读：</p>
<ul>
<li><a href="https://learn.microsoft.com/zh-cn/cpp/cpp/lambda-expressions-in-cpp">C++ 中的 Lambda 表达式 - Microsoft Learn</a></li>
<li><a href="https://en.cppreference.com/w/cpp/language/lambda">Lambda expressions (since C++11) - cppreference</a></li>
</ul>
</details>




<h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><details>
    <summary>
        点击展开
    </summary>

<ol>
<li><p><strong>基本概念</strong>：</p>
<p> 智能指针是C++中的一种对象，它像原始指针一样可以指向动态分配的内存，但当它们离开作用域或被显式删除时，它们会自动删除所指向的内存，从而防止内存泄漏。</p>
</li>
<li><p><strong>分类特点</strong>：</p>
<p> C++中有三种类型的智能指针：</p>
<p> <code>std::unique_ptr</code>：这是一种独占所有权的智能指针，同一时间只能有一个std::unique_ptr指向给定的对象。当std::unique_ptr被销毁时，它所指向的对象也会被自动销毁。</p>
<p> <code>std::shared_ptr</code>：这是一种共享所有权的智能指针。多个std::shared_ptr可以指向同一个对象，该对象只有在最后一个指向它的std::shared_ptr被销毁时才会被自动销毁。</p>
<p> <code>std::weak_ptr</code>：这是一种不拥有所有权的智能指针。它是为了解决std::shared_ptr可能会引起的循环引用问题而设计的。std::weak_ptr可以从一个std::shared_ptr或者另一个std::weak_ptr中构造，但是它不会增加引用计数。</p>
</li>
<li><p><strong>使用场景</strong>：</p>
<p> <code>std::unique_ptr</code>：当你需要确保一个对象在任何时候都只有一个所有者时，或者需要在堆上分配一个对象并确保它在不再需要时被删除时，可以使用std::unique_ptr。</p>
<p> <code>std::shared_ptr</code>：当你需要在多个所有者之间共享一个对象时，可以使用std::shared_ptr。</p>
<p> <code>std::weak_ptr</code>：当你需要一个指向对象的指针，但不需要拥有该对象时，可以使用std::weak_ptr。这通常用于解决std::shared_ptr的循环引用问题。</p>
</li>
<li><p><strong>内存管理</strong>：</p>
<p> 智能指针在C++中是一种对象，它们可以像原始指针一样指向动态分配的内存，但是它们有一个额外的特性：当智能指针离开作用域或被显式删除时，它们会自动删除所指向的内存。这就是智能指针如何帮助管理内存的方式。例如，考虑以下代码：</p>
<p> 例如，考虑以下代码：</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>* raw_ptr = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">42</span>); <span class="comment">// Allocate memory with new.</span></span><br><span class="line">    <span class="comment">// ... use raw_ptr ...</span></span><br><span class="line">&#125; <span class="comment">// Memory leak! We didn&#x27;t delete raw_ptr.</span></span><br></pre></td></tr></table></figure>
<p> 在这上面个例子中，我们在foo函数中使用new分配了一块内存，但是我们忘记了在函数结束时使用delete释放这块内存，所以发生了内存泄漏。如果如下使用智能指针，这个问题将得到结局。</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">smart_ptr</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">42</span>))</span></span>; <span class="comment">// Allocate memory with new.</span></span><br><span class="line">    <span class="comment">// ... use smart_ptr ...</span></span><br><span class="line">&#125; <span class="comment">// No memory leak! smart_ptr automatically deletes the memory.</span></span><br></pre></td></tr></table></figure>
<p> 当smart_ptr在foo函数结束时离开作用域，它会自动删除所指向的内存，从而防止内存泄漏。</p>
</li>
<li><p><strong>循环引用</strong>：</p>
<p> 循环引用是指两个或更多的对象互相引用，形成一个闭环。在这种情况下，即使没有外部引用，这些对象也无法被垃圾收集器回收，因为它们互相引用，看起来都是“活跃”的。</p>
<p> 在C++中，<code>std::shared_ptr</code>可能会导致循环引用。例如，如果你有两个类A和B，它们互相包含对方的std::shared_ptr，那么就会形成一个循环引用。即使没有任何其他对象引用这两个对象，它们也不会被销毁，因为它们互相引用。</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::shared_ptr&lt;B&gt; b_ptr;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;A deleted\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::shared_ptr&lt;A&gt; a_ptr;</span><br><span class="line">    ~<span class="built_in">B</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;B deleted\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;A&gt; a = std::<span class="built_in">make_shared</span>&lt;A&gt;();</span><br><span class="line">    std::shared_ptr&lt;B&gt; b = std::<span class="built_in">make_shared</span>&lt;B&gt;();</span><br><span class="line">    a-&gt;b_ptr = b;</span><br><span class="line">    b-&gt;a_ptr = a;</span><br><span class="line">&#125; <span class="comment">// a and b are not deleted here due to circular reference</span></span><br></pre></td></tr></table></figure>

<p> <code>std::weak_ptr</code>可以帮助解决这个问题。std::weak_ptr是一种不控制所指向对象生存期的智能指针，它指向一个由std::shared_ptr管理的对象。将上述代码中的std::shared_ptr替换为std::weak_ptr，就可以解决循环引用的问题。</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::weak_ptr&lt;B&gt; b_ptr; <span class="comment">// change shared_ptr to weak_ptr</span></span><br><span class="line">    ~<span class="built_in">A</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;A deleted\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::weak_ptr&lt;A&gt; a_ptr; <span class="comment">// change shared_ptr to weak_ptr</span></span><br><span class="line">    ~<span class="built_in">B</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;B deleted\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;A&gt; a = std::<span class="built_in">make_shared</span>&lt;A&gt;();</span><br><span class="line">    std::shared_ptr&lt;B&gt; b = std::<span class="built_in">make_shared</span>&lt;B&gt;();</span><br><span class="line">    a-&gt;b_ptr = b;</span><br><span class="line">    b-&gt;a_ptr = a;</span><br><span class="line">&#125; <span class="comment">// a and b are deleted here as expected</span></span><br></pre></td></tr></table></figure>
<p> 在上面这个例子中，当a和b离开作用域时，它们会被正确地销毁，因为没有std::shared_ptr指向它们。</p>
</li>
<li><p><strong>实际代码</strong>：</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Test created\n&quot;</span>; &#125;</span><br><span class="line">    ~<span class="built_in">Test</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Test deleted\n&quot;</span>; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">testFunc</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Test function\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Using unique_ptr</span></span><br><span class="line">    std::unique_ptr&lt;Test&gt; uPtr = std::<span class="built_in">make_unique</span>&lt;Test&gt;();</span><br><span class="line">    uPtr-&gt;<span class="built_in">testFunc</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Using shared_ptr</span></span><br><span class="line">    std::shared_ptr&lt;Test&gt; sPtr = std::<span class="built_in">make_shared</span>&lt;Test&gt;();</span><br><span class="line">    &#123;</span><br><span class="line">        std::shared_ptr&lt;Test&gt; sPtr1 = sPtr;</span><br><span class="line">        sPtr1-&gt;<span class="built_in">testFunc</span>();</span><br><span class="line">        std::cout &lt;&lt; sPtr.<span class="built_in">use_count</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// prints: 2</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; sPtr.<span class="built_in">use_count</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// prints: 1</span></span><br><span class="line">    sPtr-&gt;<span class="built_in">testFunc</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Using weak_ptr</span></span><br><span class="line">    std::weak_ptr&lt;Test&gt; wPtr = sPtr;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> sPtr2 = wPtr.<span class="built_in">lock</span>(); <span class="comment">// lock() returns a shared_ptr</span></span><br><span class="line">        <span class="keyword">if</span> (sPtr2) &#123;</span><br><span class="line">            sPtr2-&gt;<span class="built_in">testFunc</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(wPtr.<span class="built_in">expired</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Object has been deleted\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Object still exists\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>底层实现</strong>：</p>
<p>C++智能指针的底层实现通常依赖于原始指针和RAII（Resource Acquisition Is Initialization）机制。</p>
<p><code>std::unique_ptr</code>的底层实现通常是一个包装了原始指针的类，通过重载析构函数来释放资源。</p>
<p><code>std::shared_ptr</code>的底层实现通常包含一个引用计数器，记录资源被共享的次数，以及一个原始指针指向资源。</p>
<p><code>std::weak_ptr</code>的底层实现通常包含一个指向资源的原始指针和一个指向引用计数器的弱引用计数器。</p>
</li>
</ol>
<p>拓展阅读：</p>
<ul>
<li><a href="https://en.cppreference.com/book/intro/smart_pointers">Smart Pointers - cppreference</a></li>
<li><a href="https://en.cppreference.com/w/cpp/memory">Dynamic memory management - cppreference</a></li>
</ul>
</details>



<h3 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h3><details>
    <summary>
        点击展开
    </summary>

<h4 id="C-11-STL"><a href="#C-11-STL" class="headerlink" title="C++11 STL"></a>C++11 STL</h4><table>
<thead>
<tr>
<th align="center">特性</th>
<th align="center">API</th>
</tr>
</thead>
<tbody><tr>
<td align="center">thread</td>
<td align="center"><a href="https://en.cppreference.com/w/cpp/thread/thread">std::thread</a></td>
</tr>
<tr>
<td align="center">mutex</td>
<td align="center"><a href="https://en.cppreference.com/w/cpp/thread/mutex">std::mutex</a>、<a href="https://en.cppreference.com/w/cpp/thread/lock_guard">std::lock_guard</a>、<a href="https://en.cppreference.com/w/cpp/thread/unique_lock">std::unique_lock</a></td>
</tr>
<tr>
<td align="center">condition variable</td>
<td align="center"><a href="https://en.cppreference.com/w/cpp/thread/condition_variable">std::condition_variable</a>、<a href="https://en.cppreference.com/w/cpp/thread/condition_variable_any">std::condition_variable_any</a></td>
</tr>
<tr>
<td align="center">atomic</td>
<td align="center"><a href="https://en.cppreference.com/w/cpp/atomic/atomic">std::atomic</a>、<a href="https://en.cppreference.com/w/cpp/atomic/atomic_thread_fence">std::atomic_thread_fence</a></td>
</tr>
<tr>
<td align="center">future</td>
<td align="center"><a href="https://en.cppreference.com/w/cpp/thread/future">std::future</a>、<a href="https://en.cppreference.com/w/cpp/thread/shared_future">std::shared_future</a></td>
</tr>
<tr>
<td align="center">interruption</td>
<td align="center">无</td>
</tr>
</tbody></table>
<hr>
<h4 id="Concurrency"><a href="#Concurrency" class="headerlink" title="Concurrency"></a>Concurrency</h4><p><strong>并发编程</strong>是指在程序中同时执行多个任务的编程方式。这些任务可以是同时执行的、交替执行的，或者同时进行的。并发编程的目标是有效地利用计算资源，提高程序的性能、响应速度以及资源利用率。</p>
<p>在并发编程中，可以采用多种方式实现任务的并发执行，包括<code>多线程</code>、<code>异步编程</code>、<code>并行计算</code>等。这些方式可以根据任务的性质、程序的需求以及硬件平台的特性来选择。并发编程通常涉及到<code>线程间的同步与通信</code>、<code>资源共享</code>与<code>竞态条件</code>等问题，需要合理地设计和管理，以确保程序的正确性和性能。</p>
<p>并发编程在现代计算机系统中广泛应用，比如<strong>网络服务器、多线程GUI应用程序、并行计算、分布式系统</strong>等领域。通过并发编程，可以充分利用多核处理器、提高程序的并发性能，同时也可以满足用户对于快速响应和高吞吐量的需求。</p>
<hr>
<h4 id="Asynchronous"><a href="#Asynchronous" class="headerlink" title="Asynchronous"></a>Asynchronous</h4><p><strong>异步编程</strong>是一种编程模式，允许程序在<strong>执行某些耗时操作时不会被阻塞，而是可以继续执行其他任务</strong>。在C++中，异步编程通常通过<code>多线程</code>或<code>异步IO</code>来实现。</p>
<p>一种常见的实现异步编程的方式是使用C++11引入的<code>std::async</code>和<code>std::future</code>。<code>std::async函数</code>允许我们在一个新的线程或者线程池中执行一个函数，并返回一个<code>std::future对象</code>，用于获取函数的执行结果。通过std::future对象，我们可以等待异步操作的完成，也可以获取异步操作的结果。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 耗时操作函数，模拟一个耗时操作，比如网络请求或者文件IO</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">performTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">3</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span>; <span class="comment">// 返回一个结果</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 启动一个异步任务，并获取 future 对象</span></span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; futureResult = std::<span class="built_in">async</span>(std::launch::async, performTask);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行一些其他任务</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;正在执行其他任务...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待异步任务完成并获取结果</span></span><br><span class="line">    <span class="type">int</span> result = futureResult.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出异步任务的结果</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;异步任务的结果是: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一种实现异步编程的方式是使用C++标准库中的<code>std::thread</code>和<code>std::condition_variable</code>等<strong>多线程工具</strong>，或者使用一些第三方库，比如Boost.Asio等，来处理异步IO操作。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量，用于存储异步任务的结果</span></span><br><span class="line"><span class="type">int</span> asyncResult;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 耗时操作函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">performTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 模拟一个耗时操作，比如网络请求或者文件IO</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将结果存储在全局变量中</span></span><br><span class="line">    asyncResult = <span class="number">42</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个互斥量和条件变量</span></span><br><span class="line">    std::mutex mtx;</span><br><span class="line">    std::condition_variable cv;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动一个新线程执行异步任务</span></span><br><span class="line">    <span class="function">std::thread <span class="title">asyncThread</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        performTask();</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="comment">// 异步任务完成后，通知主线程</span></span></span></span><br><span class="line"><span class="params"><span class="function">        cv.notify_one();</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行一些其他任务</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;正在执行其他任务...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待异步任务完成</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    cv.<span class="built_in">wait</span>(lock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出异步任务的结果</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;异步任务的结果是: &quot;</span> &lt;&lt; asyncResult &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待异步线程结束并释放资源</span></span><br><span class="line">    asyncThread.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总的来说，异步编程可以提高程序的性能和响应速度，特别是在需要处理大量IO操作或者并发任务的情况下。</p>
<hr>
<h4 id="Multithreading"><a href="#Multithreading" class="headerlink" title="Multithreading"></a>Multithreading</h4><p><strong>多线程编程</strong>是一种并发编程的方式，通过创建多个线程来同时执行多个任务。在多线程编程中，每个线程都可以独立执行任务，同时共享程序的内存空间。<br>多线程够何理利用C多核处理器资源，提高程序的性能和响应速度，避免阻塞，降低每个线程的工作量 ，提高程序的并发性能和执行效率。<br>多线程编程通常涉及到线程的创建、同步、通信和管理等方面的操作，需要注意线程安全性、同步机制等方面的问题，以确保多个线程能够正确地协调工作，避免竞态条件和数据不一致等问题。</p>
<h5 id="ThreadManagement"><a href="#ThreadManagement" class="headerlink" title="ThreadManagement"></a><a href="https://github.com/downdemo/Cpp-Concurrency-in-Action-2ed/blob/master/docs/01_managing_thread.md">ThreadManagement</a></h5><p>下面的demo演示了如何用<code>std::thread</code>创建四个线程，分别演示了四种不同的创建方式和参数传递方式。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span> <span class="comment">// 引入 std::ref</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程函数，无参数版本</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunctionNoParam</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread with no parameter.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程函数，有参数版本</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunctionWithParam</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread with parameter: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程函数，使用引用类型参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunctionWithRef</span><span class="params">(<span class="type">int</span>&amp; value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在线程中修改引用参数</span></span><br><span class="line">    value += <span class="number">50</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread with reference parameter: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建线程1：无参数版本</span></span><br><span class="line">    <span class="function">std::thread <span class="title">thread1</span><span class="params">(threadFunctionNoParam)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程2：有参数版本，传递整数参数</span></span><br><span class="line">    <span class="type">int</span> param = <span class="number">42</span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">thread2</span><span class="params">(threadFunctionWithParam, param)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程3：匿名函数版本</span></span><br><span class="line">    <span class="function">std::thread <span class="title">thread3</span><span class="params">([] &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        std::cout &lt;&lt; <span class="string">&quot;Thread with anonymous function.&quot;</span> &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程4：传递引用类型的参数</span></span><br><span class="line">    <span class="type">int</span> data = <span class="number">100</span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">thread4</span><span class="params">([&amp;data] &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="comment">// 在线程中修改引用参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">        data += <span class="number">50</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">        std::cout &lt;&lt; <span class="string">&quot;Thread with reference parameter: &quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line">    <span class="comment">// std::thread thread4(threadFunctionWithRef, std::ref(data)); // 使用 std::ref 来传递引用类型参数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程等待线程1执行完成</span></span><br><span class="line">    thread1.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分离线程2，主线程不再等待其执行完成</span></span><br><span class="line">    thread2.<span class="built_in">detach</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程等待线程3执行完成</span></span><br><span class="line">    thread3.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分离线程4，主线程不再等待其执行完成</span></span><br><span class="line">    thread4.<span class="built_in">detach</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出引用参数被修改后的值</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Modified data in main thread: &quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="ThreadPool"><a href="#ThreadPool" class="headerlink" title="ThreadPool"></a>ThreadPool</h5><p><strong>线程池</strong>是一种有效管理和复用线程的机制，能够减少线程创建和销毁的开销、控制并发线程数量、提高响应速度、平衡系统负载、同时简化线程的管理和调度。</p>
<p>下面的demo演示了如何使用C++的标准库<code>std::thread</code>创建多线程，并利用线程池的概念管理多个线程执行任务的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ThreadPool</span>(<span class="type">size_t</span> numThreads) : <span class="built_in">stop</span>(<span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; numThreads; ++i) &#123;</span><br><span class="line">            threads.<span class="built_in">emplace_back</span>([<span class="keyword">this</span>] &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    std::function&lt;<span class="built_in">void</span>()&gt; task;</span><br><span class="line">                    &#123;</span><br><span class="line">                        std::unique_lock&lt;std::mutex&gt; <span class="built_in">lock</span>(queueMutex);</span><br><span class="line">                        condition.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>] &#123; <span class="keyword">return</span> stop || !tasks.<span class="built_in">empty</span>(); &#125;);</span><br><span class="line">                        <span class="keyword">if</span> (stop &amp;&amp; tasks.<span class="built_in">empty</span>()) <span class="keyword">return</span>;</span><br><span class="line">                        task = std::<span class="built_in">move</span>(tasks.<span class="built_in">front</span>());</span><br><span class="line">                        tasks.<span class="built_in">pop</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">task</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">ThreadPool</span>() &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(queueMutex)</span></span>;</span><br><span class="line">            stop = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        condition.<span class="built_in">notify_all</span>();</span><br><span class="line">        <span class="keyword">for</span> (std::thread &amp;thread : threads) &#123;</span><br><span class="line">            thread.<span class="built_in">join</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> F, <span class="keyword">class</span>... Args&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">enqueue</span><span class="params">(F&amp;&amp; f, Args&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(queueMutex)</span></span>;</span><br><span class="line">            tasks.<span class="built_in">emplace</span>(std::<span class="built_in">bind</span>(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...));</span><br><span class="line">        &#125;</span><br><span class="line">        condition.<span class="built_in">notify_one</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;std::thread&gt; threads;</span><br><span class="line">    std::queue&lt;std::function&lt;<span class="type">void</span>()&gt;&gt; tasks;</span><br><span class="line"></span><br><span class="line">    std::mutex queueMutex;</span><br><span class="line">    std::condition_variable condition;</span><br><span class="line">    <span class="type">bool</span> stop;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 演示任务函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">taskFunction</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Task &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; is being executed.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 模拟任务执行时间</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Task &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; execution completed.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建线程池，包含3个线程</span></span><br><span class="line">    <span class="function">ThreadPool <span class="title">pool</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向线程池添加任务</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        pool.<span class="built_in">enqueue</span>(taskFunction, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程等待任务完成</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Thread-Synchronization"><a href="#Thread-Synchronization" class="headerlink" title="Thread Synchronization"></a>Thread Synchronization</h5><p><strong>线程同步</strong>是一种控制多个线程在共享资源上的访问顺序和时机的机制。在多线程环境中，当多个线程同时访问共享资源时，可能会出现竞态条件（Race Condition）和数据不一致等问题，线程同步就是为了解决这些问题而引入的一种手段。</p>
<p>保证线程同步的方法有多种，其中一些常见的方法包括：</p>
<h6 id="Mutex"><a href="#Mutex" class="headerlink" title="Mutex"></a><strong>Mutex</strong></h6><p><strong>互斥锁（Mutex）</strong>是一种最常见的线程同步机制，它可以确保在任意时刻只有一个线程能够访问共享资源。线程在访问共享资源之前会先获取互斥锁，访问完成后再释放互斥锁，从而确保了线程的互斥访问。</p>
<p>互斥量的概念可以用一个比喻来理解：假设有一个房间（共享资源），只有拿到房间的钥匙（互斥量的锁）的人才能进入房间（访问共享资源），其他人需要等待拿到钥匙后才能进入。当一个线程拿到了互斥量的锁时，其他线程就无法再拿到该锁，只能等待锁的释放。</p>
<p>用法示例如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 共享资源</span></span><br><span class="line"><span class="type">int</span> sharedData = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 互斥量</span></span><br><span class="line">std::mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程函数，向共享资源添加值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addValue</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 加锁，保护共享资源</span></span><br><span class="line">    mtx.<span class="built_in">lock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问共享资源</span></span><br><span class="line">    sharedData += value;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; adds value &quot;</span> &lt;&lt; value &lt;&lt; <span class="string">&quot;, sharedData is now &quot;</span> &lt;&lt; sharedData &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解锁，释放互斥量</span></span><br><span class="line">    mtx.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建两个线程</span></span><br><span class="line">    <span class="function">std::thread <span class="title">thread1</span><span class="params">(addValue, <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">thread2</span><span class="params">(addValue, <span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程执行完成</span></span><br><span class="line">    thread1.<span class="built_in">join</span>();</span><br><span class="line">    thread2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出最终共享资源的值</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Final sharedData value: &quot;</span> &lt;&lt; sharedData &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按照锁的具体类型来分类：</p>
<ul>
<li><p><code>互斥锁（Mutex)</code>：互斥锁是最基本的锁类型，用于保护共享资源的互斥访问。互斥锁适用于对共享资源的长时间操作，因为它会阻塞其他试图获取锁的线程，直到拥有锁的线程释放锁。<code>std::mutex</code>是C++标准库中提供的递归锁类。</p>
</li>
<li><p><code>递归锁（Recursive Mutex）</code>：递归锁是一种特殊的互斥锁，允许同一个线程多次获得锁。递归锁可以在同一线程内对共享资源进行递归调用，避免死锁的问题。<code>std::recursive_mutex</code>是C++标准库提供的递归锁类。</p>
</li>
<li><p><code>自旋锁（Spinlock）</code>：自旋锁是一种特殊类型的互斥锁，当一个线程试图获取一个已经被其他线程持有的自旋锁时，它会在一个循环中不断地尝试获取锁，而不是被阻塞。自旋锁适用于对共享资源的短时间操作，因为它可以避免线程切换的开销。C++标准库中没有提供原生的自旋锁，但可以通过原子操作等机制实现自旋锁的功能。</p>
</li>
<li><p><code>读写锁（Read-Write Lock）</code>：读写锁允许多个线程同时读取共享资源，但在任何时候只允许一个线程写入。读写锁可以提高读取操作的并发性能，适用于读取操作频繁、写入操作较少的场景。C++标准库中没有提供原生的读写锁，但可以通过互斥锁和条件变量等组合实现读写锁的功能。</p>
</li>
</ul>
<p>按照对并发控制的思想进行划分：</p>
<ul>
<li><p><code>乐观锁（Optimistic Locking）</code>：乐观锁是一种并发控制的策略，它假设多个线程在访问共享资源时不会发生冲突，因此在访问资源时不会立即加锁，而是在更新资源时才检查是否有冲突。如果发现冲突，就放弃更新，通常配合重试机制使用。乐观锁适用于冲突少的情况。</p>
</li>
<li><p><code>悲观锁（Pessimistic Locking）</code>：悲观锁是一种并发控制的策略，它假设多个线程在访问共享资源时会发生冲突，因此在访问资源时就立即加锁。悲观锁适用于冲突多的情况。</p>
</li>
</ul>
<h6 id="Condition-Variable"><a href="#Condition-Variable" class="headerlink" title="Condition Variable"></a><strong>Condition Variable</strong></h6><p><strong>条件变量（Condition Variable）</strong>是一种用于线程间通信和同步的机制，它允许线程在等待某个条件满足时进入阻塞状态，直到其他线程通知条件变量并唤醒它们。条件变量通常与互斥锁一起使用，<code>std::condition_variable</code>用于等待某个条件的发生，而<code>std::mutex</code>用于保护共享资源，确保在访问共享资源时的线程安全性。</p>
<p>最典型的使用场景是生产者和消费者问题：</p>
<ul>
<li>生产者线程负责生成产品，并将产品放入共享队列中。</li>
<li>消费者线程负责从共享队列中取出产品，并进行消费。</li>
<li>当共享队列为空时，消费者线程需要等待，直到有新的产品放入队列中。</li>
<li>当共享队列已满时，生产者线程需要等待，直到有消费者取出产品。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::queue&lt;<span class="type">int</span>&gt; sharedQueue; <span class="comment">// 共享队列</span></span><br><span class="line">std::mutex mtx; <span class="comment">// 互斥量</span></span><br><span class="line">std::condition_variable cv; <span class="comment">// 条件变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">500</span>)); <span class="comment">// 模拟生产过程</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">            sharedQueue.<span class="built_in">push</span>(i); <span class="comment">// 将产品放入队列中</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Produced: &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        cv.<span class="built_in">notify_one</span>(); <span class="comment">// 通知消费者线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        cv.<span class="built_in">wait</span>(lock, []&#123; <span class="keyword">return</span> !sharedQueue.<span class="built_in">empty</span>(); &#125;); <span class="comment">// 等待直到队列不为空</span></span><br><span class="line">        <span class="type">int</span> value = sharedQueue.<span class="built_in">front</span>(); <span class="comment">// 取出产品</span></span><br><span class="line">        sharedQueue.<span class="built_in">pop</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Consumed: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建生产者和消费者线程</span></span><br><span class="line">    <span class="function">std::thread <span class="title">producerThread</span><span class="params">(producer)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">consumerThread</span><span class="params">(consumer)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程执行完成</span></span><br><span class="line">    producerThread.<span class="built_in">join</span>();</span><br><span class="line">    consumerThread.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h6 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a><strong>Semaphore</strong></h6><p><strong>信号量（Semaphore）</strong>是一种计数器，用于控制对共享资源的访问权限。它允许多个线程同时访问共享资源，但可以限制同时访问的线程数量。通过对信号量的增加和减少操作，可以实现对共享资源的访问控制和线程同步。</p>
<p>C++标准库（C++11及更新版本）本身并没有提供信号量的实现，但是在POSIX系统中，可以使用<code>semaphore.h</code>头文件提供的函数来操作信号量。这些函数包括：</p>
<ul>
<li><p><strong>sem_init()：</strong> 初始化信号量。</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_init</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> pshared, <span class="type">unsigned</span> <span class="type">int</span> value)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>sem_destroy()：</strong> 销毁信号量。</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_destroy</span><span class="params">(<span class="type">sem_t</span> *sem)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>sem_wait()：</strong> 等待信号量。</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_wait</span><span class="params">(<span class="type">sem_t</span> *sem)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>sem_trywait()：</strong> 尝试等待信号量，如果无法立即获取则立即返回。</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_trywait</span><span class="params">(<span class="type">sem_t</span> *sem)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>sem_post()：</strong> 发送信号量。</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_post</span><span class="params">(<span class="type">sem_t</span> *sem)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>sem_getvalue()：</strong> 获取信号量的当前值。</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_getvalue</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> *sval)</span></span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>以上函数用于创建、销毁、等待和发送信号量，并可以获取当前信号量的值。需要注意的是，这些函数是在POSIX标准中定义的，因此在非POSIX系统上可能不适用，或者需要额外的库支持。</p>
<p>下面是使用信号量解决生产者-消费者问题的例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::queue&lt;<span class="type">int</span>&gt; sharedQueue; <span class="comment">// 共享队列</span></span><br><span class="line">std::mutex mtx; <span class="comment">// 互斥量</span></span><br><span class="line"><span class="type">sem_t</span> empty; <span class="comment">// 空闲信号量，表示空闲的缓冲区数量</span></span><br><span class="line"><span class="type">sem_t</span> full; <span class="comment">// 满信号量，表示已填充的缓冲区数量</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> BUFFER_SIZE = <span class="number">5</span>; <span class="comment">// 缓冲区大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">500</span>)); <span class="comment">// 模拟生产过程</span></span><br><span class="line">        <span class="built_in">sem_wait</span>(&amp;empty); <span class="comment">// 等待空闲信号量</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">            sharedQueue.<span class="built_in">push</span>(i); <span class="comment">// 将产品放入队列中</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Produced: &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sem_post</span>(&amp;full); <span class="comment">// 发送满信号量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">sem_wait</span>(&amp;full); <span class="comment">// 等待满信号量</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">            <span class="type">int</span> value = sharedQueue.<span class="built_in">front</span>(); <span class="comment">// 取出产品</span></span><br><span class="line">            sharedQueue.<span class="built_in">pop</span>();</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Consumed: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sem_post</span>(&amp;empty); <span class="comment">// 发送空闲信号量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化信号量</span></span><br><span class="line">    <span class="built_in">sem_init</span>(&amp;empty, <span class="number">0</span>, BUFFER_SIZE);</span><br><span class="line">    <span class="built_in">sem_init</span>(&amp;full, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建生产者和消费者线程</span></span><br><span class="line">    <span class="function">std::thread <span class="title">producerThread</span><span class="params">(producer)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">consumerThread</span><span class="params">(consumer)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程执行完成</span></span><br><span class="line">    producerThread.<span class="built_in">join</span>();</span><br><span class="line">    consumerThread.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁信号量</span></span><br><span class="line">    <span class="built_in">sem_destroy</span>(&amp;empty);</span><br><span class="line">    <span class="built_in">sem_destroy</span>(&amp;full);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h6 id="Atomic-Operation"><a href="#Atomic-Operation" class="headerlink" title="Atomic Operation"></a><strong>Atomic Operation</strong></h6><p><strong>原子操作（Atomic Operation）</strong>是一种不可分割的操作，它要么完全执行，要么完全不执行，不存在中间状态，可以确保在多线程环境中对共享变量的操作是原子性的，不会被其他线程中断。原子操作通常用于实现对共享变量的安全访问和更新，避免了竞态条件和数据不一致等问题。</p>
<p><code>std::atomic</code>是C++标准库提供的模板类，用于执行原子操作，支持各种数据类型的原子操作，包括整数、指针、布尔值等，同时支持包括增加、读取、设置、交换等原子操作。</p>
<p>以下是<code>std::atomic</code>模板类的一些常见成员函数：</p>
<ul>
<li><code>load()</code>：以原子方式读取<code>std::atomic</code>对象的值。</li>
<li><code>store()</code>：以原子方式设置<code>std::atomic</code>对象的值。</li>
<li><code>exchange()</code>：以原子方式交换<code>std::atomic</code>对象的值，并返回之前的值。</li>
<li><code>compare_exchange_strong()</code>和<code>compare_exchange_weak()</code>：以原子方式比较并交换<code>std::atomic</code>对象的值，可以选择强一致性或者弱一致性。</li>
</ul>
<p>用法示例如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">counter</span><span class="params">(<span class="number">0</span>)</span></span>; <span class="comment">// 创建一个原子类型的整数对象，初始值为0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原子操作：增加计数器的值</span></span><br><span class="line">    counter++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原子操作：读取计数器的值</span></span><br><span class="line">    <span class="type">int</span> value = counter.<span class="built_in">load</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原子操作：设置计数器的值</span></span><br><span class="line">    counter.<span class="built_in">store</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原子操作：交换计数器的值，并返回之前的值</span></span><br><span class="line">    <span class="type">int</span> oldValue = counter.<span class="built_in">exchange</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Old Value: &quot;</span> &lt;&lt; oldValue &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们创建了一个<code>std::atomic</code>对象<code>counter</code>，并进行了一系列原子操作，这些操作都是原子性的，不会被其他线程中断，从而确保了对共享资源的操作是安全的。</p>
<h6 id="Barrier"><a href="#Barrier" class="headerlink" title="Barrier"></a><strong>Barrier</strong></h6><p><strong>屏障（Barrier）</strong>是一种同步机制，它可以确保所有线程在达到某个指定点之前都必须等待，然后一起继续执行。屏障通常用于多个线程在某个阶段需要等待其他线程都完成某个操作后再继续执行的场景。</p>
<p>C++标准库并没有提供原生的屏障（Barrier）实现。但是可以使用第三方库（如Boost库）提供的屏障来实现线程同步。以下是一个使用Boost库中的屏障的示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/thread.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/thread/barrier.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> NUM_THREADS = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">boost::barrier <span class="title">bar</span><span class="params">(NUM_THREADS)</span></span>; <span class="comment">// 创建一个屏障，指定线程数量为3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; boost::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; started.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 等待所有线程到达屏障</span></span><br><span class="line">    bar.<span class="built_in">wait</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; boost::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; finished.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建线程</span></span><br><span class="line">    boost::thread_group threads;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_THREADS; ++i) &#123;</span><br><span class="line">        threads.<span class="built_in">create_thread</span>(threadFunction);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待所有线程完成</span></span><br><span class="line">    threads.<span class="built_in">join_all</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，首先创建了一个屏障bar，指定了线程数量为3。然后创建了3个线程，并在每个线程中调用bar.wait()等待所有线程到达屏障。当所有线程都到达屏障后，它们才会继续执行后续的操作。</p>
<p>需要注意的是，上述代码使用了Boost库，需要在编译和链接时指定对应的库文件，并且需要安装Boost库。</p>
<hr>
<h5 id="Optimization"><a href="#Optimization" class="headerlink" title="Optimization"></a>Optimization</h5><p>在并发编程中，如何确保性能？请介绍一下并发编程中的常见性能优化技巧。</p>
<p>并发编程中确保性能的关键在于合理的设计和优化，并发算法和数据结构，以及有效地利用计算资源和系统资源。以下是一些确保性能的常见方法：</p>
<ol>
<li><p><strong>减少锁的使用：</strong> 锁是保护共享资源的关键机制，但过多地使用锁会导致线程之间频繁地竞争锁资源，降低程序的并发性能。因此，可以尽量减少锁的使用，尽量使用细粒度的锁或无锁数据结构来减少锁的竞争。</p>
</li>
<li><p><strong>使用非阻塞算法：</strong> 非阻塞算法可以避免线程之间的锁竞争，提高并发性能。常见的非阻塞算法包括无锁数据结构（如无锁队列、无锁链表等）和无锁算法（如CAS、原子操作等）。</p>
</li>
<li><p><strong>减少线程间的通信：</strong> 线程间的通信会引入额外的开销和延迟，降低程序的性能。因此，可以尽量减少线程间的通信，避免不必要的数据共享和同步操作。</p>
</li>
<li><p><strong>使用线程池：</strong> 使用线程池可以减少线程的创建和销毁开销，提高线程的复用性和效率，从而提高程序的并发性能。</p>
</li>
<li><p><strong>并行化任务：</strong> 将大型任务分解成多个小任务，并行执行可以充分利用多核处理器的计算能力，提高程序的执行效率和性能。</p>
</li>
<li><p><strong>优化数据访问模式：</strong> 合理设计数据结构和访问模式，减少内存访问和数据依赖，优化数据访问性能。</p>
</li>
<li><p><strong>使用高性能并发库：</strong> 使用高性能的并发库可以提供优化过的并发算法和数据结构，提高程序的并发性能。</p>
</li>
<li><p><strong>避免资源争用：</strong> 避免多个线程之间的资源争用，尽量减少共享资源的访问，优化资源的分配和利用，提高程序的并发性能。</p>
</li>
</ol>
<p>综上所述，确保性能的关键在于合理设计并发算法和数据结构，有效地利用计算资源和系统资源，并尽量减少线程间的通信和资源竞争，从而提高程序的并发性能。</p>
<p>拓展阅读：</p>
<ul>
<li><a href="https://github.com/goodbigzzz/Cpp_Concurrency_In_Action_2nd-/tree/main">C++并发编程实战</a></li>
<li><a href="https://www.limerence2017.com/2023/07/31/concpp/">C++并发</a></li>
<li><a href="https://juejin.cn/post/7292243642000392192">C++性能优化</a></li>
</ul>
</details>



<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><details>
    <summary>
        点击展开
    </summary>

<ol>
<li><p>简述多态实现的原理</p>
<p>多态可以分为<strong>静态多态（编译时多态）</strong>和<strong>动态多态（运行时多态）</strong>，可以理解为<code>函数重载 &amp; 模板</code>和<code>函数重写</code>。</p>
<ul>
<li><code>静态多态</code><ul>
<li>实现方式：<code>函数重载</code>，由编译器确定的</li>
<li>具体实现：<ul>
<li>允许在同一个作用域中声明多个功能类似的同名函数</li>
<li>这些函数的参数列表、参数个数、参数类型、参数顺序不一样</li>
<li>注意不能通过返回值来区别重载</li>
</ul>
</li>
<li>实现原理：<ul>
<li>函数名修饰</li>
<li>编译过程<ul>
<li>预编译：把头文件中的函数声明拷贝到源文件，避免编译过程中语法分析找不到函数定义</li>
<li>编译：语法分析，同时进行符号汇总（函数名）</li>
<li>汇编：生成函数名和函数地址的映射，方便之后通过函数名找到函数定义的位置，从而执行函数</li>
<li>链接：将多个文件中的符号表汇总合并</li>
</ul>
</li>
<li>通过objdump -t *.o : _ZN+类长度+类名+函数名长度+函数名+E+类型首字母</li>
</ul>
</li>
</ul>
</li>
<li><code>动态多态</code><ul>
<li>实现方式：<code>虚函数重写</code>，由运行时确定的</li>
<li>具体实现：<ul>
<li>在基类的函数名前加上virtual关键字，在派生类中重写该函数</li>
<li>运行时将会根据对象的类型来调用相应的函数</li>
<li>如果对象的类型是基类，则调用基类的函数</li>
<li>如果对象的类型是派生类，这调用派生类的函数</li>
</ul>
</li>
<li>实现原理：<ul>
<li>早绑定：编译器编译时已经确定对象调用的函数的地址</li>
<li>晚绑定：若类使用了virtual函数，则编译器会为类生成虚函数表，他是一个一维数组，存放虚函数的地址。</li>
</ul>
</li>
<li>virtual关键字用于声明一个函数为虚函数。<strong>虚函数主要用于实现多态</strong>，即允许在派生类中重写(override)基类中的函数。虚函数表指针在构造函数中初始化。</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<ol start="2">
<li><p>虚函数表和虚函数表指针</p>
<ul>
<li>虚函数表<ul>
<li>what：<code>虚函数表</code>是一个存储类的<strong>虚函数地址</strong>的数组，每个包含虚函数的类或者从这样的类派生的类都有一个虚函数表。</li>
<li>how：虚函数表的内容在编译器编译的时候已经生成，当一个类的对象被创建时一个虚函数表也会被创建并与该对象关联。</li>
<li>why：虚函数表用于实现动态多态性。动态多态性允许我们通过基类指针调用派生类的函数。</li>
<li>where：虚函数表存放在全局数据区中的只读数据段中，每个对象的内存布局中都有一个指向虚函数表的指针。</li>
<li>when：有一个基类指针，并且想调用派生类的函数时，需要使用虚函数表。</li>
</ul>
</li>
<li>虚函数表指针：<ul>
<li>what：<code>虚函数表指针</code>是一个指向虚函数表（vtable）的指针，每个包含虚函数的类或者从这样的类派生的类的对象都有一个虚函数表指针。</li>
<li>when：对象构造的时候，在构造函数，将虚函数表的地址赋值给对象vptr。</li>
<li>how：继承下虚函数表指针赋值过程：<ul>
<li>如果类没有构造函数，则编译器为类生成默认构造函数，从而为类对象初始化vptr。</li>
<li>接着调用子类构造函数的时候，又将子类的虚函数表地址赋值给vptr。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<ol start="3">
<li><p>构造函数能否声明为虚函数？</p>
<p> 在C++中，构造函数不能声明为虚函数。这是因为虚函数的调用需要通过对象的虚函数表（vtable）来实现，而在对象构造期间，虚函数表尚未建立，因此无法通过虚函数表来调用构造函数。</p>
</li>
</ol>
<hr>
</details>



<h3 id="仿函数"><a href="#仿函数" class="headerlink" title="仿函数"></a>仿函数</h3><details>
    <summary>
        点击展开
    </summary>

<p>在C++中，仿函数（Functor）是一个行为类似函数的对象。它是一个类，该类重载了operator()运算符。因此，我们可以像调用函数一样调用这个类的对象。这就是为什么它被称为仿函数。仿函数可以扩展函数的功能，并且可以保存状态信息，具有很高的灵活性和可复用性。</p>
<p>仿函数在C++中有许多应用场景，以下是一些常见的应用场景：</p>
<ol>
<li><p>作为STL算法的参数：STL算法，如sort，transform等，通常接受一个函数或者仿函数作为参数。使用仿函数可以使得代码更加灵活和可重用。</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyComparator</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &gt; b; <span class="comment">// 降序排序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Add</span> &#123;</span><br><span class="line">    <span class="type">int</span> value; <span class="comment">// 保存要加的值</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Add</span>(<span class="type">int</span> val) : <span class="built_in">value</span>(val) &#123;&#125; <span class="comment">// 构造函数，初始化要加的值</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> x)</span> <span class="type">const</span> </span>&#123; <span class="comment">// 重载函数调用运算符</span></span><br><span class="line">        <span class="keyword">return</span> x + value; <span class="comment">// 返回加法操作的结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    std::<span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="built_in">MyComparator</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl; <span class="comment">// 输出：9 6 5 4 3 2 1 1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    std::<span class="built_in">transform</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), vec.<span class="built_in">begin</span>(), <span class="built_in">Add</span>(<span class="number">5</span>));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;vec: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : vec) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl; <span class="comment">// 输出：vec: 6 7 8 9 10</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>作为比较函数：在STL的数据结构，如set，map，priority_queue等，可以接受一个比较函数或者仿函数来自定义元素的排序方式。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Compare</span> : <span class="keyword">public</span> std::binary_function&lt;<span class="type">int</span>, <span class="type">int</span>, <span class="type">bool</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; a, <span class="type">const</span> <span class="type">int</span>&amp; b)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &gt; b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::priority_queue&lt;<span class="type">int</span>, std::vector&lt;<span class="type">int</span>&gt;, Compare&gt; pq;</span><br><span class="line"></span><br><span class="line">    pq.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">    pq.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    pq.<span class="built_in">push</span>(<span class="number">4</span>);</span><br><span class="line">    pq.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    pq.<span class="built_in">push</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Priority Queue: &quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; pq.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl; <span class="comment">// 输出：Priority Queue: 5 4 3 1 1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>在回调函数中：仿函数是类对象，可以包含成员变量，因此可以保存状态信息。这使得仿函数在执行函数调用时可以考虑到之前的状态，实现更复杂的功能。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个仿函数 AddWithState</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddWithState</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> state; <span class="comment">// 保存状态信息</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数，初始化状态信息</span></span><br><span class="line">    <span class="built_in">AddWithState</span>(<span class="type">int</span> initialState) : <span class="built_in">state</span>(initialState) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载函数调用运算符，将输入值与状态信息相加并返回</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> result = x + state;</span><br><span class="line">        state = result; <span class="comment">// 更新状态信息</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> initialState = <span class="number">0</span>; <span class="comment">// 初始状态信息为 0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 AddWithState 对象，将初始状态信息传入构造函数</span></span><br><span class="line">    <span class="function">AddWithState <span class="title">adder</span><span class="params">(initialState)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用仿函数进行加法操作，并将结果保存到 vec 中</span></span><br><span class="line">    std::<span class="built_in">transform</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), vec.<span class="built_in">begin</span>(), adder);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出每次加法操作的结果</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Resulting vector: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : vec) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>作为函数对象适配器的参数： 仿函数可以与函数对象适配器一起使用，实现更复杂的功能。例如，std::bind、std::function等可以与仿函数一起使用，实现函数的组合、筛选等操作。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPredicate</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x % <span class="number">2</span> == <span class="number">0</span>; <span class="comment">// 判断是否为偶数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyPredicate predicate;</span><br><span class="line">    std::function&lt;<span class="type">bool</span>(<span class="type">int</span>)&gt; isEven = std::<span class="built_in">bind</span>(predicate, std::placeholders::_1);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">isEven</span>(<span class="number">3</span>) &lt;&lt; std::endl; <span class="comment">// 输出 0</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">isEven</span>(<span class="number">4</span>) &lt;&lt; std::endl; <span class="comment">// 输出 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details></li>
</ol>
<h3 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h3><details>
    <summary>
        点击展开
    </summary>

<p><code>static</code> 关键字在C++中具有多种用途，用于定义静态变量、静态函数和静态常量，实现了在程序运行期间共享状态信息、提高函数的调用效率等功能。</p>
<ol>
<li><strong>静态变量（Static Variables）：</strong> 在函数内部或类内部声明的变量可以使用 <code>static</code> 关键字修饰，表示静态变量。静态变量在程序的整个生命周期内存在，不会因为程序的多次调用而被重复创建和销毁。函数内部的静态变量在函数执行时被初始化，但只会初始化一次，其值在函数调用之间保持不变。类内部的静态成员变量在类的所有对象中共享，也被称为类的静态成员。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// 静态局部变量</span></span><br><span class="line">    count++;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Function called &quot;</span> &lt;&lt; count &lt;&lt; <span class="string">&quot; times.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> instanceCount; <span class="comment">// 类的静态成员变量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> MyClass::instanceCount = <span class="number">0</span>; <span class="comment">// 静态成员变量的初始化</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(); <span class="comment">// 输出：Function called 1 times.</span></span><br><span class="line">    <span class="built_in">func</span>(); <span class="comment">// 输出：Function called 2 times.</span></span><br><span class="line"></span><br><span class="line">    MyClass obj1;</span><br><span class="line">    MyClass obj2;</span><br><span class="line">    MyClass::instanceCount++;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Number of instances: &quot;</span> &lt;&lt; MyClass::instanceCount &lt;&lt; std::endl; <span class="comment">// 输出：Number of instances: 1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>静态函数（Static Functions）：</strong> 在类内部声明的函数可以使用 <code>static</code> 关键字修饰，表示静态函数。静态函数不依赖于任何特定的对象实例，可以直接通过类名来调用。静态函数不能访问类的非静态成员，因为它们不依赖于对象的状态。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">staticFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Static function called.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass::<span class="built_in">staticFunction</span>(); <span class="comment">// 输出：Static function called.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>静态常量（Static Constants）：</strong> 在类内部声明的常量可以使用 <code>static</code> 和 <code>const</code> 关键字修饰，表示静态常量。静态常量在类的所有对象中共享，且不可修改。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> MAX_VALUE = <span class="number">100</span>; <span class="comment">// 静态常量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Max value: &quot;</span> &lt;&lt; MyClass::MAX_VALUE &lt;&lt; std::endl; <span class="comment">// 输出：Max value: 100</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>



<h3 id="左值引用-amp-右值引用"><a href="#左值引用-amp-右值引用" class="headerlink" title="左值引用 &amp; 右值引用"></a>左值引用 &amp; 右值引用</h3><details>
    <summary>
        点击展开
    </summary>

<p>在C++中，左值引用（lvalue reference）和右值引用（rvalue reference）是与变量或表达式的生命周期和使用方式相关联的两种引用类型。</p>
<ol>
<li><strong>左值引用（lvalue reference）：</strong> 左值引用绑定到具有名称的对象（即左值），并且可以延长其生命周期。左值引用通常用于传递可修改的对象，也可以用于函数重载和模板推断等场景。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">5</span>; <span class="comment">// x 是左值</span></span><br><span class="line">    <span class="type">int</span>&amp; lref = x; <span class="comment">// lref 是左值引用，绑定到 x</span></span><br><span class="line">    lref = <span class="number">10</span>; <span class="comment">// 修改 x 的值</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x = &quot;</span> &lt;&lt; x &lt;&lt; std::endl; <span class="comment">// 输出：x = 10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>右值引用（rvalue reference）：</strong> 右值引用绑定到临时对象或表达式（即右值），并且可以延长其生命周期。右值引用通常用于移动语义、完美转发和实现移动构造函数和移动赋值运算符等场景。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Constructor&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Destructor&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">const</span> MyClass&amp;) &#123; std::cout &lt;&lt; <span class="string">&quot;Copy constructor&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="built_in">MyClass</span>(MyClass&amp;&amp;) &#123; std::cout &lt;&lt; <span class="string">&quot;Move constructor&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">MyClass <span class="title">createObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">MyClass</span>(); <span class="comment">// 返回临时对象，是右值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass&amp;&amp; rref = <span class="built_in">createObject</span>(); <span class="comment">// rref 是右值引用，绑定到临时对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>createObject()</code> 函数返回一个临时对象，因此返回值是一个右值。在 <code>main()</code> 函数中，我们使用右值引用 <code>MyClass&amp;&amp; rref</code> 来绑定这个临时对象，延长了它的生命周期，从而使得对象在 <code>main()</code> 函数作用域内仍然有效。右值引用的绑定延长了对象的生命周期，可以用于实现移动语义，避免了临时对象的不必要拷贝。</p>
<ol start="3">
<li><strong>区分左值引用和右值引用：</strong></li>
</ol>
<p>左值引用和右值引用在语义上有很大的差异，左值引用通常用于可修改的对象，右值引用则通常用于临时对象或表达式，并且可以延长其生命周期以实现移动语义。区分左值引用和右值引用的关键在于理解它们绑定到的对象的生命周期和可修改性。</p>
<ul>
<li>左值引用（lvalue reference）绑定到具有名称的对象（即左值），例如变量或对象的名称。</li>
<li>右值引用（rvalue reference）绑定到临时对象或表达式（即右值），例如临时对象、函数返回值、字面量等。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">5</span>; <span class="comment">// x 是左值</span></span><br><span class="line"><span class="type">int</span>&amp; lref = x; <span class="comment">// lref 是左值引用，绑定到 x</span></span><br><span class="line"><span class="type">int</span>&amp;&amp; rref = <span class="number">10</span>; <span class="comment">// rref 是右值引用，绑定到临时对象</span></span><br></pre></td></tr></table></figure>


<ol start="4">
<li><strong>右值引用的使用场景：</strong></li>
</ol>
<ul>
<li><code>移动语义</code>：右值引用常用于实现移动构造函数和移动赋值运算符，从而避免了不必要的深拷贝，提高了效率。</li>
<li><code>完美转发</code>：右值引用还可用于实现完美转发，将参数以原样传递给其他函数，无需进行多余的拷贝或移动操作。</li>
<li><code>临时对象的延长生命周期</code>：通过右值引用，可以延长临时对象的生命周期，使其在函数调用结束后仍然有效。</li>
</ul>
<p>下面是一些右值引用的更多使用场景和示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 移动语义示例：移动构造函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyVector</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; data;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyVector</span>(std::vector&lt;<span class="type">int</span>&gt;&amp;&amp; other) : <span class="built_in">data</span>(std::<span class="built_in">move</span>(other)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Move constructor called.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 完美转发示例：使用右值引用进行完美转发</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">forward</span><span class="params">(T&amp;&amp; t, U&amp;&amp; u)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">process</span>(std::forward&lt;T&gt;(t), std::forward&lt;U&gt;(u));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span>&amp;&amp; x, <span class="type">int</span>&amp;&amp; y)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Processing: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 移动语义示例：移动构造函数</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; temp = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="function">MyVector <span class="title">mv</span><span class="params">(std::move(temp))</span></span>; <span class="comment">// 调用移动构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 完美转发示例：使用右值引用进行完美转发</span></span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line">    forward(std::<span class="built_in">move</span>(a), std::<span class="built_in">move</span>(b)); <span class="comment">// 调用 process 函数并进行完美转发</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拓展阅读：</p>
<ul>
<li><a href="https://modern-cpp.readthedocs.io/zh-cn/latest/rvalue-ref.html">Understanding Modern C++：rvalue reference</a></li>
<li><a href="https://cntransgroup.github.io/EffectiveModernCppChinese/5.RRefMovSemPerfForw/item24.html">Effective Modern C++ Item 24: Distinguish universal references from rvalue references</a></li>
</ul>
</details>







<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a><center>设计模式</center></h2><h3 id="日常工作中用到了那些设计模式？"><a href="#日常工作中用到了那些设计模式？" class="headerlink" title="日常工作中用到了那些设计模式？"></a>日常工作中用到了那些设计模式？</h3><details>
    <summary>
        点击展开
    </summary>

<ol>
<li><code>单例模式</code>是一种<code>创建型设计模式</code>，它保证一个类只有一个实例，并提供一个全局访问点。单例模式的优点包括：</li>
</ol>
<ul>
<li><p>控制实例数目：单例模式可以确保一个类只有一个实例，避免了因为多次创建实例而导致的资源浪费。</p>
</li>
<li><p>全局访问点：单例模式提供了一个全局访问点，这使得我们可以在任何地方都能访问到这个实例。</p>
</li>
<li><p>共享资源：由于单例模式只有一个实例，所以可以方便地用于共享资源，例如配置信息，缓存等。</p>
</li>
</ul>
<p>注意，虽然单例模式有这些优点，但也有一些缺点，例如它可能导致代码的耦合度增加，且在多线程环境下需要特别注意线程安全问题。因此，在使用单例模式时需要根据具体的需求和场景进行权衡。</p>
<ol start="2">
<li><code>代理模式</code>是一种<code>结构型设计模式</code>，它提供了一个对象来代替另一个对象控制对原对象的访问。代理对象可以在客户端和目标对象之间起到中介的作用，并添加额外的功能。</li>
</ol>
<p>代理模式主要包含以下三种类型：</p>
<ul>
<li><p>虚拟代理：在需要时创建开销很大的对象。通过它来存储实例化需要很长时间的真实对象的一些信息。</p>
</li>
<li><p>保护代理：控制真实对象访问的权限。</p>
</li>
<li><p>远程代理：为一个对象在不同的地址空间提供局部代表。</p>
</li>
</ul>
<p>代理模式通常包含以下几个角色：</p>
<ul>
<li><p>抽象主题（Subject）：定义了 RealSubject 和 Proxy 共用接口，这样在任何使用 RealSubject 的地方都可以使用 Proxy。</p>
</li>
<li><p>真实主题（RealSubject）：定义了 Proxy 所代表的真实实体。</p>
</li>
<li><p>代理（Proxy）：保存一个引用使得代理可以访问实体，并提供一个与 Subject 的接口相同的接口。</p>
</li>
</ul>
<p>以下是一个简单的 C++ 代理模式的例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">request</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RealSubject</span> : <span class="keyword">public</span> Subject &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">request</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;RealSubject: Handling request.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Proxy</span> : <span class="keyword">public</span> Subject &#123;</span><br><span class="line">    RealSubject* real_subject_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Proxy</span>(RealSubject* real_subject) : <span class="built_in">real_subject_</span>(<span class="keyword">new</span> <span class="built_in">RealSubject</span>(*real_subject)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">request</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;<span class="built_in">checkAccess</span>()) &#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;real_subject_-&gt;<span class="built_in">request</span>();</span><br><span class="line">            <span class="keyword">this</span>-&gt;<span class="built_in">logAccess</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkAccess</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Some real checks should go here.</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Proxy: Checking access prior to firing a real request.\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">logAccess</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Proxy: Logging the time of request.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<ol start="3">
<li>观察者模式是一种<code>行为型设计模式</code>，定义了对象之间的一对多依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知并自动更新。</li>
</ol>
<p>这种设计模式通常用于需要实现复杂的事件处理或消息传递系统时。例如，GUI库、游戏、实时系统、分布式系统等都可能使用观察者模式。</p>
<p>观察者模式有以下优点：</p>
<ul>
<li><p>解耦：观察者模式可以解耦观察者和被观察者之间的关系，使得它们可以独立变化和复用。</p>
</li>
<li><p>广播通信：被观察者会向所有的观察者广播通知，这是一种一对多的关系。</p>
</li>
<li><p>动态关系：可以在运行时动态地添加和删除观察者，改变观察者与被观察者之间的关系。</p>
</li>
</ul>
<p>然而，观察者模式也有一些缺点：</p>
<ul>
<li><p>过度使用或误用：如果过度使用或误用观察者模式，可能会导致程序难以理解和维护。例如，如果一个观察者的更新操作引发了另一个更新操作，可能会导致复杂的链式更新。</p>
</li>
<li><p>假设同步通知：观察者模式通常假设观察者在接收到通知后能立即进行更新，但在某些情况下，这可能不是可行的。例如，如果观察者的更新操作需要很长时间，或者需要从网络获取数据，那么这种同步通知的方式可能会导致程序阻塞。</p>
</li>
<li><p>可能引发的性能问题：如果有大量的观察者，或者观察者的处理逻辑很复杂，那么通知所有观察者可能会花费很长时间。</p>
</li>
</ul>
<p>拓展阅读：<a href="https://subingwen.cn/design-patterns/index.html">C++设计模式</a></p>
</details>



<h3 id="如何实现一个线程安全的单例模式？"><a href="#如何实现一个线程安全的单例模式？" class="headerlink" title="如何实现一个线程安全的单例模式？"></a>如何实现一个线程安全的单例模式？</h3><details>
    <summary>
        点击展开
    </summary>

<p><code>线程安全</code>：在拥有共享数据的多条线程并行执行的程序中，线程安全的代码会通过同步机制保证各个线程都可以正常且正确的执行，不会出现数据污染等意外情况。</p>
<p>单例模式指在整个系统生命周期里，保证一个类只能产生一个实例，确保该类的唯一性。</p>
<p>单例模式可以分为<code>懒汉式</code>和<code>饿汉式</code>，两者之间的区别在于创建实例的时间不同：</p>
<p><code>懒汉式</code>：指系统运行中，实例并不存在，只有当需要使用该实例时，才会去创建并使用实例。（这种方式要考虑线程安全）<br><code>饿汉式</code>：指系统一运行，就初始化创建实例，当需要时，直接调用即可。（本身就线程安全，没有多线程的问题）</p>
<p>如何实现线程安全：</p>
<ol>
<li><p><code>普通的懒汉式单例</code>没有加锁，是线程不安全的，当线程并发时会创建多个实例。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> Singleton* instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造函数，防止外部创建实例</span></span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 获取单例对象实例的静态方法</span></span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton* Singleton::instance = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在多线程环境下可能会创建多个实例</span></span><br><span class="line">    Singleton* singleton1 = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line">    Singleton* singleton2 = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Singleton 1 address: &quot;</span> &lt;&lt; singleton1 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Singleton 2 address: &quot;</span> &lt;&lt; singleton2 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p><code>加锁的懒汉式单例</code>，<code>std::unique_lock&lt;std::mutex&gt; lock(m_Mutex);</code> 加了互斥锁的普通懒汉式是线程安全的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> Singleton* instance;</span><br><span class="line">    <span class="type">static</span> std::mutex mutex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造函数，防止外部创建实例</span></span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 获取单例对象实例的静态方法</span></span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton* Singleton::instance = <span class="literal">nullptr</span>;</span><br><span class="line">std::mutex Singleton::mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Singleton* singleton1 = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line">    Singleton* singleton2 = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Singleton 1 address: &quot;</span> &lt;&lt; singleton1 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Singleton 2 address: &quot;</span> &lt;&lt; singleton2 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>双重检查锁定的懒汉单例</code>，通过在实例化单例对象时进行双重检查来避免了不必要的加锁，从而提高了一定的性能。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> Singleton* instance;</span><br><span class="line">    <span class="type">static</span> std::mutex mutex;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 私有构造函数，防止外部创建实例</span></span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 获取单例对象实例的静态方法</span></span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 第一次检查：判断实例是否已经存在，避免不必要的加锁</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="comment">// 加锁，确保只有一个线程可以创建实例</span></span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第二次检查：在获取锁后再次判断实例是否已经存在</span></span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁止拷贝构造函数和赋值运算符，防止通过拷贝创建新实例</span></span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化静态成员变量</span></span><br><span class="line">Singleton* Singleton::instance = <span class="literal">nullptr</span>;</span><br><span class="line">std::mutex Singleton::mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取单例对象实例</span></span><br><span class="line">    Singleton* singleton = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Singleton address: &quot;</span> &lt;&lt; singleton &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>内部静态变量的懒汉单例</code>，利用了局部静态变量的初始化是线程安全的这一特性，因为C++11保证了局部静态变量的初始化在并发情况下只会被执行一次，线程安全，且不需要使用锁，因此性能最好。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 私有构造函数，防止外部创建实例</span></span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 获取单例对象实例的静态方法</span></span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">static</span> Singleton instance;</span><br><span class="line">        <span class="keyword">return</span> &amp;instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Singleton* singleton1 = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line">    Singleton* singleton2 = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Singleton 1 address: &quot;</span> &lt;&lt; singleton1 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Singleton 2 address: &quot;</span> &lt;&lt; singleton2 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>参考链接：</p>
<ul>
<li><a href="https://www.cnblogs.com/xiaolincoding/p/11437231.html">C++ 线程安全的单例模式总结 - 小林coding - 博客园</a></li>
</ul>
</details>



<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a><center>操作系统</center></h2><h3 id="死锁的「产生」「预防」「避免」「检测」「解除」"><a href="#死锁的「产生」「预防」「避免」「检测」「解除」" class="headerlink" title="死锁的「产生」「预防」「避免」「检测」「解除」"></a>死锁的「产生」「预防」「避免」「检测」「解除」</h3><details>
    <summary>
        点击展开
    </summary>

<ol>
<li>产生</li>
</ol>
<p>死锁是在多任务环境中，两个或更多的进程无限期地等待资源，而这些资源又被等待的进程所占有。死锁通常是由于多个进程之间的资源竞争和进程间的不恰当同步造成的。</p>
<p>死锁的产生需要满足四个条件，也被称为死锁的四个必要条件：</p>
<ul>
<li><p>互斥条件：一个资源每次只能被一个进程使用。</p>
</li>
<li><p>占有与等待条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</p>
</li>
<li><p>不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺。</p>
</li>
<li><p>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。</p>
</li>
</ul>
<ol start="2">
<li>预防</li>
</ol>
<p>预防死锁就是破坏上面四个条件任意一个，但是实现很难：</p>
<ul>
<li><p>破坏互斥条件：允许某些资源同时被多个进程访问。但是有些资源本身并不具有这种属性，因此这种方案实用性有限。</p>
</li>
<li><p>破坏占有并等待条件：实行资源预先分配策略，当一个进程开始运行之前，必须一次性向系统申请它所需要的全部资源，否则不运行；或者只允许进程在没有占用资源的时候才能申请资源（申请资源前先释放占有的资源）</p>
<p>缺点：很多时候无法预知一个进程所需的全部资源；同时，会降低资源利用率，降低系统的并发性。</p>
</li>
<li><p>破坏非抢占条件：允许进程强行抢占被其它进程占有的资源。会降低系统性能。</p>
</li>
<li><p>破坏循环等待条件：对所有资源统一编号，所有进程对资源的请求必须按照序号递增的顺序提出，即只有占有了编号较小的资源才能申请编号较大的资源。这样避免了占有大号资源的进程去申请小号资源，各个进程申请资源的顺序都是从小到大，就不会有环了</p>
</li>
</ul>
<ol start="3">
<li>避免</li>
</ol>
<p>允许系统中同时存在四个必要条件，但是每当进程提出资源申请时，系统要分析满足该资源请求后，系统是否会发生死锁，若不会发生则实施分配，否则拒绝分配。银行家算法实现了这个过程。</p>
<ol start="4">
<li>检测</li>
</ol>
<p>画出资源分配图，检测是否存在环路。检测环路前要将资源分配图化简，化简的原理是“一个目前占有运行所需的资源的进程，迟早能够执行完成释放资源”。因此，可以从“进程—资源分配图”中找到一个既不阻塞又非孤立的进程，删除所有与该进程相连的有向边，回收资源，使之成为孤立结点，然后将所回收的资源分配给其它进程。循环此过程，直到无法化简。若仍存在环路，则该系统目前处于死锁状态。</p>
<p>检测到死锁后，需要解除死锁。</p>
<ol start="5">
<li>解除</li>
</ol>
<p>破坏除了“互斥条件”之外的其他三个条件：</p>
<ul>
<li><p>回退执行：系统定期对各个进程进行检查，将检查点的有关信息写入文件。死锁时，让某占有必要资源的进程回退到取得资源之前的一个检查点，释放的资源分配给一个死锁进程（破坏“占有且等待”）</p>
</li>
<li><p>抢占资源：剥夺占有进程的资源，分配给另外某些进程，直至死锁环路被打破（破坏“不可抢占”）</p>
</li>
<li><p>杀掉进程：一次终止一个进程，直至消除死锁环路（破坏“循环等待”）</p>
</li>
</ul>
<p>拓展阅读：</p>
<ul>
<li><a href="https://imageslr.com/2020/07/08/tech-interview#%E6%AD%BB%E9%94%81%E7%9A%84%E9%A2%84%E9%98%B2%E6%A3%80%E6%B5%8B%E9%81%BF%E5%85%8D%E8%A7%A3%E9%99%A4">面试题】技术面试题汇总 🔥 死锁的预防检测避免解除</a></li>
</ul>
</details>



<h3 id="如何由虚拟地址映射到物理地址"><a href="#如何由虚拟地址映射到物理地址" class="headerlink" title="如何由虚拟地址映射到物理地址"></a>如何由虚拟地址映射到物理地址</h3><details>
    <summary>
        点击展开
    </summary>

<p>物理地址和虚拟地址是操作系统<code>内存管理</code>中的两个重要概念。</p>
<ol>
<li><p><strong>物理地址：</strong> 物理地址是实际存储在计算机内存芯片上的地址，也称为实际地址或真实地址。它是硬件所理解和处理的地址，用于直接访问计算机的内存单元。</p>
</li>
<li><p><strong>虚拟地址：</strong> 虚拟地址是由处理器（CPU）生成的地址，用于访问计算机内存中的数据。它是相对于程序而言的一种抽象地址，程序只能看到和使用虚拟地址，而不知道实际的物理内存地址。虚拟地址空间通常比物理内存空间大得多，因为它可以包含操作系统和其他应用程序的地址空间。</p>
</li>
</ol>
<hr>
<p>为什么要将虚拟地址映射到物理地址？</p>
<ul>
<li><strong>Why？</strong>：将虚拟地址映射到物理地址的主要目的是实现内存管理和地址空间隔离。通过虚拟地址，操作系统可以为每个程序提供独立的地址空间，使得每个程序都认为自己拥有整个内存空间，从而实现了地址空间的隔离和保护。</li>
</ul>
<hr>
<p>什么时候会发生虚拟地址到物理地址之间的映射？</p>
<ul>
<li><strong>When？</strong>：虚拟地址到物理地址的映射通常发生在计算机执行程序时进行内存访问时。具体来说，当程序访问内存中的数据时，处理器会生成虚拟地址，并通过硬件中的地址转换单元（MMU）将虚拟地址映射到物理地址。</li>
</ul>
<hr>
<p>谁来处理虚拟地址到物理地址的映射？</p>
<ul>
<li><strong>Who？</strong>：虚拟地址到物理地址的映射是由硬件中的地址转换单元（MMU）来处理的。MMU是计算机体系结构中的一个重要组成部分，负责处理内存访问请求，并将虚拟地址映射到物理地址。</li>
</ul>
<hr>
<p>如何处理虚拟地址到物理地址的映射？</p>
<ul>
<li><strong>How？</strong>：虚拟地址到物理地址的映射过程通常包括以下几个步骤：<ol>
<li><strong>页表查找：</strong> MMU根据虚拟地址的高位页号来查找页表。</li>
<li><strong>页表项解析：</strong> 一旦找到了页表中对应的页表项，MMU会解析该项以获取物理地址页面帧号。</li>
<li><strong>偏移量添加：</strong> MMU将虚拟地址中的偏移量与物理地址页面帧号相结合，得到最终的物理地址。</li>
<li><strong>TLB缓存（可选）：</strong> 为了加速地址转换过程，MMU可能会使用一个高速缓存，称为翻译后备缓冲器（TLB）。TLB中存储了最近的一些虚拟地址到物理地址的映射关系，如果TLB中找到了对应的映射，MMU会直接使用它而不必查询页表。</li>
<li><strong>缺页处理（可选）：</strong> 如果在查询页表或TLB时发现对应的页面不在内存中（即缺页），则会触发一个缺页中断。在这种情况下，操作系统会将缺失的页面从磁盘加载到内存中，并更新页表或TLB以反映这个变化。</li>
</ol>
</li>
</ul>
<hr>
<p>总的来说，虚拟地址到物理地址的映射是由硬件中的MMU处理的，它通过页表查找、解析页表项、偏移量添加等步骤完成映射过程。TLB缓存和缺页处理是在这个过程中的一些优化和异常处理机制。</p>
<p>参考文档：</p>
<ul>
<li><a href="https://rcore-os.cn/rCore-Tutorial-deploy/docs/lab-3/guide/part-1.html">从虚拟内存到物理内存</a></li>
</ul>
</details>




<h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a><center>计算机网络</center></h2><h3 id="三次握手和四次挥手的过程"><a href="#三次握手和四次挥手的过程" class="headerlink" title="三次握手和四次挥手的过程"></a>三次握手和四次挥手的过程</h3><details>
    <summary>
        点击展开
    </summary>

<p>TCP&#x2F;IP协议中的三次握手和四次挥手是建立和关闭TCP连接时的重要过程。</p>
<h4 id="三次握手（Three-Way-Handshake）："><a href="#三次握手（Three-Way-Handshake）：" class="headerlink" title="三次握手（Three-Way Handshake）："></a>三次握手（Three-Way Handshake）：</h4><ol>
<li><p><strong>客户端向服务器发送连接请求（SYN）：</strong> 客户端发送一个带有SYN（同步序列编号）标志的TCP数据包给服务器，说明客户端要建立连接，并选择一个初始序列号。</p>
</li>
<li><p><strong>服务器响应连接请求（SYN + ACK）：</strong> 如果服务器同意连接，会发送一个带有SYN和ACK（确认）标志的TCP数据包给客户端，以确认客户端的连接请求，并选择一个初始序列号作为回应。</p>
</li>
<li><p><strong>客户端确认连接（ACK）：</strong> 最后，客户端再发送一个带有ACK标志的数据包给服务器，表示连接请求已收到确认。此时，TCP连接已经建立，双方可以开始进行数据传输。</p>
</li>
</ol>
<h4 id="四次挥手（Four-Way-Handshake）："><a href="#四次挥手（Four-Way-Handshake）：" class="headerlink" title="四次挥手（Four-Way Handshake）："></a>四次挥手（Four-Way Handshake）：</h4><ol>
<li><p><strong>发起关闭连接请求（FIN）：</strong> 当客户端或服务器决定关闭连接时，会发送一个带有FIN（结束）标志的TCP数据包给对方，表示不再向对方发送数据。</p>
</li>
<li><p><strong>对关闭请求进行确认（ACK）：</strong> 收到关闭请求的一方会发送一个带有ACK标志的TCP数据包作为确认，表示收到了关闭请求。</p>
</li>
<li><p><strong>关闭连接（FIN）：</strong> 接收到关闭请求并确认后，对方也会发送一个带有FIN标志的TCP数据包给发起关闭的一方，表示同意关闭连接。</p>
</li>
<li><p><strong>确认关闭（ACK）：</strong> 最后，发起关闭的一方收到对方的确认后，也会发送一个带有ACK标志的TCP数据包给对方，表示确认收到关闭请求。此时，TCP连接彻底关闭，双方不再传输数据。</p>
</li>
</ol>
<p>这些过程确保了在TCP连接的建立和关闭过程中，双方都能够正确地进行通信并进行必要的确认和处理，以保证数据的可靠传输。</p>
<p>参考链接：</p>
<ul>
<li><a href="https://juejin.cn/post/6844904005315854343">https://juejin.cn/post/6844904005315854343</a></li>
<li><a href="https://imageslr.com/2020/07/07/tcp-shake-wave">https://imageslr.com/2020/07/07/tcp-shake-wave</a></li>
</ul>
</details>


<h3 id="TCP-与-UDP-的对比"><a href="#TCP-与-UDP-的对比" class="headerlink" title="TCP 与 UDP 的对比"></a>TCP 与 UDP 的对比</h3><details>
    <summary>
        点击展开
    </summary>

<table>
<thead>
<tr>
<th>方面</th>
<th>TCP</th>
<th>UDP</th>
</tr>
</thead>
<tbody><tr>
<td>连接性</td>
<td>面向连接</td>
<td>无连接</td>
</tr>
<tr>
<td>可靠性</td>
<td>提供可靠的数据传输</td>
<td>不提供可靠性保证</td>
</tr>
<tr>
<td>传输方式</td>
<td>面向字节流</td>
<td>面向数据报</td>
</tr>
<tr>
<td>传输距离</td>
<td>适用于局域网和广域网</td>
<td>适用于局域网</td>
</tr>
<tr>
<td>双工性</td>
<td>全双工</td>
<td>可以是全双工、半双工或单工</td>
</tr>
<tr>
<td>流量控制&#x2F;拥塞控制</td>
<td>提供流量控制和拥塞控制</td>
<td>不提供流量控制和拥塞控制</td>
</tr>
<tr>
<td>应用场景</td>
<td>网页浏览、文件传输、电子邮件等</td>
<td>音频、视频流媒体、在线游戏等</td>
</tr>
<tr>
<td>应用层协议</td>
<td>HTTP、HTTPS、FTP、SMTP等</td>
<td>DNS、DHCP、TFTP、SNMP等</td>
</tr>
</tbody></table>
</details>




<h3 id="POST和GET的区别"><a href="#POST和GET的区别" class="headerlink" title="POST和GET的区别"></a>POST和GET的区别</h3><details>
    <summary>
        点击展开
    </summary>

<table>
<thead>
<tr>
<th>方面</th>
<th>POST</th>
<th>GET</th>
</tr>
</thead>
<tbody><tr>
<td>数据位置</td>
<td>请求体中发送数据</td>
<td>URL中发送数据</td>
</tr>
<tr>
<td>数据长度限制</td>
<td>无限制</td>
<td>有限制（通常受浏览器或服务器限制 2KB）</td>
</tr>
<tr>
<td>安全性</td>
<td>更安全，数据不会暴露在URL中</td>
<td>较不安全，数据会暴露在URL中</td>
</tr>
<tr>
<td>应用</td>
<td>添加 &#x2F; 修改服务器的数据</td>
<td>获取服务器的指定数据</td>
</tr>
<tr>
<td>历史记录</td>
<td>不可以</td>
<td>可以保存在历史记录中或者收藏为书签</td>
</tr>
<tr>
<td>缓存</td>
<td>不可被缓存</td>
<td>可以被缓存</td>
</tr>
<tr>
<td>数据类型</td>
<td>可以发送多种类型的数据（二进制、文本等）</td>
<td>仅能发送ASCII字符</td>
</tr>
<tr>
<td>请求类型</td>
<td>用于向服务器提交数据，用于创建资源</td>
<td>用于从服务器获取数据，用于读取资源</td>
</tr>
<tr>
<td>幂等性</td>
<td>非幂等，会对服务器资源进行改变</td>
<td>幂等（同样的请求发送多次会产生相同的结果）</td>
</tr>
<tr>
<td>安全性</td>
<td>需要一定的安全性措施</td>
<td>相对较不需要安全性措施</td>
</tr>
<tr>
<td>可见性</td>
<td>数据不会暴露在URL中</td>
<td>数据会暴露在URL中</td>
</tr>
<tr>
<td>后退 &#x2F; 刷新</td>
<td>后退或者刷新的时候，GET是无害的</td>
<td>后退或者刷新的时候，POST会重新提交表单</td>
</tr>
</tbody></table>
</details>




<h2 id="数据结构和算法"><a href="#数据结构和算法" class="headerlink" title="数据结构和算法"></a><center>数据结构和算法</center></h2><h3 id="阐述堆排序中「建堆」「调整」和「删除」的过程。"><a href="#阐述堆排序中「建堆」「调整」和「删除」的过程。" class="headerlink" title="阐述堆排序中「建堆」「调整」和「删除」的过程。"></a>阐述堆排序中「建堆」「调整」和「删除」的过程。</h3><details>
    <summary>
        点击展开
    </summary>

<p>建堆、调整和删除是堆操作的三个主要步骤。以下是这三个步骤的简要描述：</p>
<ul>
<li><p><strong>建堆</strong>：建堆是将一个无序的数组构建成一个堆的过程。对于一个完全二叉树（堆就是一个完全二叉树），从最后一个非叶子节点开始，对每一个非叶子节点进行下沉操作（即调整操作），直到根节点。这个过程是O(n)的复杂度。</p>
</li>
<li><p><strong>调整</strong>：调整是保持堆属性的过程。对于大顶堆，如果某个节点的值小于其子节点，那么就需要将这个节点和它的最大的子节点进行交换，然后继续对交换后的子节点进行调整，直到这个节点的值大于其所有子节点的值。对于小顶堆，调整的过程类似，只是比较和交换的条件相反。</p>
</li>
<li><p><strong>删除</strong>：删除通常是删除堆顶元素。删除堆顶元素后，为了保持堆的属性，通常的做法是将最后一个元素移动到堆顶，然后进行调整。这个过程是O(log n)的复杂度，因为可能需要调整的层数等于堆的高度。</p>
</li>
</ul>
<p>详见<a href="https://leetcode.cn/problems/kth-largest-element-in-an-array">LeetCode 215.</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinHeap</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; data;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">siftUp</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(i &gt; <span class="number">0</span> &amp;&amp; data[(i - <span class="number">1</span>) / <span class="number">2</span>] &gt; data[i]) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(data[(i - <span class="number">1</span>) / <span class="number">2</span>], data[i]);</span><br><span class="line">            i = (i - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">siftDown</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">2</span> * i + <span class="number">1</span> &lt; data.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> left = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> right = <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> j = left;</span><br><span class="line">            <span class="keyword">if</span>(right &lt; data.<span class="built_in">size</span>() &amp;&amp; data[right] &lt; data[left]) &#123;</span><br><span class="line">                j = right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(data[i] &lt;= data[j]) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">swap</span>(data[i], data[j]);</span><br><span class="line">            i = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        data.<span class="built_in">push_back</span>(val);</span><br><span class="line">        <span class="built_in">siftUp</span>(data.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        data[<span class="number">0</span>] = data.<span class="built_in">back</span>();</span><br><span class="line">        data.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="built_in">siftDown</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findKthLargest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        MinHeap q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num: nums) &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(num);</span><br><span class="line">            <span class="keyword">if</span>(q.<span class="built_in">size</span>() &gt; k) &#123;</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</details>



<h3 id="阐述字典序Trie这种数据类型。"><a href="#阐述字典序Trie这种数据类型。" class="headerlink" title="阐述字典序Trie这种数据类型。"></a>阐述字典序Trie这种数据类型。</h3><details>
    <summary>
        点击展开
    </summary>

<p>What（什么）：字典序，也称为词典序或者字母序，是一种排序方法，它按照字母或者数字的顺序进行排序，就像在字典中查找单词一样。</p>
<p>Who（谁）：程序员和数据科学家经常需要使用字典序，例如在处理字符串或者文本数据时，可能会用到字典序。在数据库查询中，也常常需要按照字典序进行排序。</p>
<p>When（何时）：当需要对字符串或者文本数据进行排序，或者需要在数据库中进行查询时，可能会用到字典序。</p>
<p>Where（何地）：字典序可以在任何需要排序或者查询的地方使用，例如在编程语言中处理字符串，或者在数据库中进行查询。</p>
<p>Why（为什么）：字典序可以帮助我们按照一定的顺序组织和查找数据，使得数据更容易被理解和处理。</p>
<p>How（如何）：在大多数编程语言中，都有内置的字符串比较函数，可以直接用来实现字典序。如果需要自定义字典序，可以使用数据结构（例如Trie）或者算法（例如字典序的下一个排列算法）来实现。</p>
<p>实现方式：用前缀树实现字典序</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TrieNode</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TrieNode* children[<span class="number">26</span>];</span><br><span class="line">    <span class="type">bool</span> isEndOfWord;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">TrieNode</span>() &#123;</span><br><span class="line">        isEndOfWord = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">            children[i] = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TrieNode* root;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Trie</span>() &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        TrieNode* node = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : word) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;children[c - <span class="string">&#x27;a&#x27;</span>] == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                node-&gt;children[c - <span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;children[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;isEndOfWord = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        TrieNode* node = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : word) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;children[c - <span class="string">&#x27;a&#x27;</span>] == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;children[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node != <span class="literal">nullptr</span> &amp;&amp; node-&gt;isEndOfWord;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">startsWith</span><span class="params">(string prefix)</span> </span>&#123;</span><br><span class="line">        TrieNode* node = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : prefix) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;children[c - <span class="string">&#x27;a&#x27;</span>] == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;children[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node != <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面这个Trie实现支持插入、查找和前缀查找操作。每个TrieNode包含一个指向26个子节点的指针数组（对应26个英文字母）和一个标记该节点是否为一个单词的结束的布尔值。插入操作是将一个单词的每个字符按顺序插入到Trie中，查找操作是检查一个单词是否存在于Trie中，前缀查找操作是检查一个前缀是否存在于Trie中。</p>
</details>


<h3 id="位运算拾疑"><a href="#位运算拾疑" class="headerlink" title="位运算拾疑"></a>位运算拾疑</h3><details>
    <summary>
        点击展开
    </summary>

<p>程序中的所有数在计算机内存中都是以二进制的形式储存的。位运算说到底，就是直接对整数在内存中的二进制位进行操作。使用位运算，主要目的是节约内存，使你的程序速度更快，还有就是对内存要求苛刻的地方使用。</p>
<p>位运算在面试中的“初衷”是考察面试者的基本功，但不幸的是，位运算所考察的知识点，大部分属于知道就知道, 不知道不知道的类型。所以有必要先知道一下。</p>
<ol>
<li><p><code>按位与（&amp;）</code>：将两个数的对应位进行与操作，如果两个数的对应位都为1，则结果为1，否则为0。常用于清零特定位、判断某个位是否为1等操作。</p>
</li>
<li><p><code>按位或（|）</code>：将两个数的对应位进行或操作，如果两个数的对应位中有一个为1，则结果为1，否则为0。常用于将特定位设置为1。</p>
</li>
<li><p><code>按位异或（^）</code>：将两个数的对应位进行异或操作，如果两个数的对应位不同，则结果为1，否则为0。常用于交换两个数的值、清除特定位等操作。</p>
</li>
<li><p><code>按位取反（~）</code>：将一个数的所有位取反，即将0变为1，将1变为0。常用于对数的位进行取反操作。</p>
</li>
<li><p><code>左移（&lt;&lt;）</code>：将一个数的所有位向左移动指定的位数，高位丢弃，低位补0。常用于实现乘以2的n次方。</p>
</li>
<li><p><code>右移（&gt;&gt;）</code>：将一个数的所有位向右移动指定的位数，低位丢弃，高位根据情况补0或者补符号位。常用于实现除以2的n次方。</p>
</li>
</ol>
<p>奇技淫巧和常见用途：</p>
<ul>
<li>交换两个数的值：使用按位异或（^）运算，即a ^&#x3D; b; b ^&#x3D; a; a ^&#x3D; b;。</li>
<li>判断奇偶性：使用按位与（&amp;）运算，奇数的最后一位为1，偶数的最后一位为0。</li>
<li>清零特定位：使用按位与（&amp;）运算，将指定位设置为0。</li>
<li>设置特定位：使用按位或（|）运算，将指定位设置为1。</li>
<li>快速计算2的幂：使用左移（&lt;&lt;）运算，将1左移n位得到2的n次方。</li>
<li>判断一个数是否是2的幂：使用按位与（&amp;）运算，2的幂的二进制表示中只有一位为1，其余为0，所以 n &amp; (n - 1) &#x3D;&#x3D; 0 表示 n 是2的幂。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换两个数的值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">    a ^= b;</span><br><span class="line">    b ^= a;</span><br><span class="line">    a ^= b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断奇偶性</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isEven</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (n &amp; <span class="number">1</span>) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清零特定位</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">clearBit</span><span class="params">(<span class="type">int</span> num, <span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num &amp; ~(<span class="number">1</span> &lt;&lt; pos);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置特定位</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setBit</span><span class="params">(<span class="type">int</span> num, <span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num | (<span class="number">1</span> &lt;&lt; pos);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快速计算2的幂</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">powOf2</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断一个数是否是2的幂</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPowerOf2</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (n &amp; (n - <span class="number">1</span>)) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 交换两个数的值</span></span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">swap</span>(a, b);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Swap: a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;, b = &quot;</span> &lt;&lt; b &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断奇偶性</span></span><br><span class="line">    <span class="type">int</span> num = <span class="number">7</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Is &quot;</span> &lt;&lt; num &lt;&lt; <span class="string">&quot; even? &quot;</span> &lt;&lt; <span class="built_in">isEven</span>(num) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清零特定位</span></span><br><span class="line">    <span class="type">int</span> num1 = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> pos1 = <span class="number">2</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Clear bit at position &quot;</span> &lt;&lt; pos1 &lt;&lt; <span class="string">&quot; in &quot;</span> &lt;&lt; num1 &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; <span class="built_in">clearBit</span>(num1, pos1) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置特定位</span></span><br><span class="line">    <span class="type">int</span> num2 = <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> pos2 = <span class="number">1</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Set bit at position &quot;</span> &lt;&lt; pos2 &lt;&lt; <span class="string">&quot; in &quot;</span> &lt;&lt; num2 &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; <span class="built_in">setBit</span>(num2, pos2) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 快速计算2的幂</span></span><br><span class="line">    <span class="type">int</span> n = <span class="number">3</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;2^&quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; <span class="built_in">powOf2</span>(n) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断一个数是否是2的幂</span></span><br><span class="line">    <span class="type">int</span> num3 = <span class="number">16</span>;</span><br><span class="line">    std::cout &lt;&lt; num3 &lt;&lt; <span class="string">&quot; is power of 2? &quot;</span> &lt;&lt; <span class="built_in">isPowerOf2</span>(num3) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拓展阅读：</p>
<ul>
<li><a href="https://www.bilibili.com/video/BV1YT4y117AH/">https://www.bilibili.com/video/BV1YT4y117AH/</a></li>
</ul>
</details>


<h2 id="业务技能"><a href="#业务技能" class="headerlink" title="业务技能"></a><center>业务技能</center></h2><h3 id="Protobuf和Json有什么区别，车内通信应用领域有何不同？"><a href="#Protobuf和Json有什么区别，车内通信应用领域有何不同？" class="headerlink" title="Protobuf和Json有什么区别，车内通信应用领域有何不同？"></a>Protobuf和Json有什么区别，车内通信应用领域有何不同？</h3><details>
    <summary>
        点击展开
    </summary>

<p>Protocol Buffers (protobuf) 和 JSON 是两种常用的<code>数据序列化格式</code>，它们都可以用于<code>数据存储和通信</code>。然而，它们在设计理念、性能和使用场景上有一些重要的区别：</p>
<ul>
<li><p>数据大小和速度：Protobuf 通常比 JSON 更小，更快。Protobuf 是二进制格式，比 JSON 的文本格式更紧凑，因此在网络传输和数据存储上更有效率。同时，Protobuf 的解析和序列化速度也通常比 JSON 更快。</p>
</li>
<li><p>类型安全：Protobuf 是静态类型的，需要预先定义数据结构（在 .proto 文件中）。这意味着你可以在编译时获取类型安全性，并且可以利用 Protobuf 编译器生成的代码来读写数据。而 JSON 是动态类型的，数据结构可以在运行时改变，这在某些情况下可能更灵活，但也可能导致更多的运行时错误。</p>
</li>
<li><p>可读性和互操作性：JSON 是人类可读的，可以直接在文本编辑器中查看和编辑，而且被广泛支持在几乎所有的编程语言中。而 Protobuf 是二进制格式，不易于直接阅读和编辑，但它提供了工具可以将数据转换为可读的文本格式。Protobuf 的支持也比较广泛，但可能不如 JSON 那么普遍。</p>
</li>
<li><p>版本兼容性：Protobuf 设计了一套规则来处理数据结构的变化，使得新旧版本的数据结构可以相互兼容。而在 JSON 中，如果数据结构发生变化，可能需要更多的手动处理来保证兼容性。</p>
</li>
</ul>
<p>总的来说，Protobuf 和 JSON 各有优势，适用于不同的场景。在需要<code>可读性和广泛的语言互操作性</code>的 Web 开发中，JSON 是一个很好的选择，因为 <code>HTTP 请求和响应通常需要在多种不同的平台和语言之间进行交互</code>。</p>
<p>在需要高效性能和强类型的车载网络通信中，Protobuf 是更好的选择，因为因为车载系统通常有严格的性能和资源限制，在车载网络中，带宽和资源通常是有限的，因此需要使用更高效的数据格式。<code>Protobuf 的二进制格式比 JSON 的文本格式更紧凑</code>，因此可以更有效地<code>利用网络带宽</code>。</p>
<p>拓展阅读：</p>
<ol>
<li><a href="https://sunyunqiang.com/blog/protobuf_encode/">Protobuf编码原理</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/633656133">序列化协议Protobuf入门</a></li>
</ol>
</details>



<h3 id="介绍下DoIP报文的格式。"><a href="#介绍下DoIP报文的格式。" class="headerlink" title="介绍下DoIP报文的格式。"></a>介绍下DoIP报文的格式。</h3><details>
    <summary>
        点击展开
    </summary>

<p>DoIP（Diagnostic over Internet Protocol）是一种在以太网上进行车辆诊断的协议。它是基于TCP&#x2F;IP和UDP&#x2F;IP的，允许在车辆网络中进行高速、高效的数据传输。</p>
<p>DoIP报文的基本格式如下：</p>
<p>协议版本：这是一个8位的字段，表示DoIP协议的版本。当前的版本是0x02。</p>
<p>载荷类型：这是一个16位的字段，表示载荷的类型。例如，诊断消息、车辆识别请求等。</p>
<p>载荷长度：这是一个32位的字段，表示载荷的长度（以字节为单位）。</p>
<p>载荷：这是一个可变长度的字段，包含载荷的实际数据。其内容和长度取决于载荷类型。</p>
<p>源地址：这是一个16位的字段，表示发送节点的地址。</p>
<p>目标地址：这是一个16位的字段，表示接收节点的地址。</p>
<p>在实际使用中，DoIP报文通常会被封装在TCP或UDP报文中，然后通过以太网进行传输。具体的传输协议（TCP或UDP）取决于载荷类型和特定的应用需求。</p>
<p>拓展阅读：</p>
<ul>
<li><a href="https://www.iso.org/standard/87961.html">https://www.iso.org/standard/87961.html</a></li>
<li><a href="https://github.com/doip/doip">https://github.com/doip/doip</a></li>
<li><a href="http://bbs.eeworld.com.cn/thread-1275968-1-1.html">http://bbs.eeworld.com.cn/thread-1275968-1-1.html</a></li>
</ul>
</details>



<h3 id="介绍下CAN报文的格式以及在工作中是如何分析CAN报文的。"><a href="#介绍下CAN报文的格式以及在工作中是如何分析CAN报文的。" class="headerlink" title="介绍下CAN报文的格式以及在工作中是如何分析CAN报文的。"></a>介绍下CAN报文的格式以及在工作中是如何分析CAN报文的。</h3><details>
    <summary>
        点击展开
    </summary>

<p>CAN（Controller Area Network）报文主要有两种格式：标准格式（CAN 2.0A）和扩展格式（CAN 2.0B）。其基本格式包括：起始位、仲裁域（包括标识符和远程传输请求位）、控制域（包括数据长度代码）、数据域、CRC域、确认域和结束位。上述两种格式的主要区别在于标识符的长度，标准格式的标识符是11位，而扩展格式的标识符是29位。</p>
<p>以下是CAN报文的基本结构：</p>
<ul>
<li><p>起始位（Start of frame）：这是一个固定为0的位，表示报文的开始。</p>
</li>
<li><p>仲裁域（Arbitration field）：这个域包括标识符和远程传输请求位（RTR）。标识符用于标识报文的类型或目的。RTR位用于区分数据帧（RTR&#x3D;0）和远程帧（RTR&#x3D;1）。</p>
</li>
<li><p>控制域（Control field）：这个域包括数据长度代码（DLC），表示数据域中的字节数（0到8字节）。</p>
</li>
<li><p>数据域（Data field）：这个域包含报文的数据，长度由DLC指定。</p>
</li>
<li><p>CRC域（CRC field）：这个域包含一个15位的循环冗余校验序列和一个固定为1的分隔位。</p>
</li>
<li><p>确认域（ACK field）：这个域包括一个确认位和一个固定为1的分隔位。发送节点将确认位设置为0，接收节点在成功接收报文后将其设置为1。</p>
</li>
<li><p>结束位（End of frame）：这是一个固定为1的位，表示报文的结束。</p>
</li>
</ul>
<p>在CAN网络中，所有节点都会监听网络上的所有报文，并根据报文的标识符决定是否处理报文。当多个节点同时发送报文时，标识符较小的报文（即优先级较高的报文）会被优先发送。这是通过CAN协议的仲裁机制实现的。</p>
<p>有一些工具可以帮助在工作中分析CAN报文，例如Wireshark、Vector CANoe等。这些工具可以自动解析CAN报文，并提供一些高级的功能，如报文过滤、触发条件等。</p>
</details>



<h3 id="简单介绍下MQTT的消息格式、消息类型、服务质量和连接保活特征。"><a href="#简单介绍下MQTT的消息格式、消息类型、服务质量和连接保活特征。" class="headerlink" title="简单介绍下MQTT的消息格式、消息类型、服务质量和连接保活特征。"></a>简单介绍下MQTT的消息格式、消息类型、服务质量和连接保活特征。</h3><details>
    <summary>
        点击展开
    </summary>

<p>MQTT（Message Queuing Telemetyr Transport 消息队列遥测传输协议）：基于发布&#x2F;订阅模式的轻量级通讯协议，该协议构建于TCP&#x2F;IP协议之上。MQTT运行于TCP之上，属于应用层协议。</p>
<ul>
<li><p><strong>消息格式</strong>：<br>每条MQTT命令消息的消息头都包含一个固定的报头，有些消息会携带一个可变报文头和一个负荷。消息格式如下：</p>
<p>  <code>固定报文头</code>  |  <code>可变报文头</code>  |  <code>负荷</code></p>
</li>
</ul>
<ol>
<li><p>固定报头：最少有两个字节，第一个字节包含消息的类型（Message Type）和QoS级别等标志位。第二个字节开始是剩余长度字节，该长度是后面的可变报文头加消息负载的总长度，该字段最多允许四个字节。<br>剩余长度字段单个字节的最大值为0x7F. 也就是127个字节。MQTT协议规定，单个字节的最高位如果是1，表示后续还有字节存在，第八位起延续位的作用。<br>由于MQTT协议最多使用四个字节表示剩余长度，并且最后一个字节的最大值只能是0x7F,而不是0xFF。所以能发送的最大消息长度是256MB，而不是512MB。</p>
</li>
<li><p>可变报头：主要包含协议名，协议版本，连接标志，心跳间隔时间，连接返回码，主题名等。</p>
</li>
<li><p>负荷：实际上可以理解为消息的主体。当MQTT发送的消息类型是CONNECT（连接）、PUBLISH（发布）、SUBSCRIBE（订阅）、SUBACK（订阅确认）、UBSUNSCRIBE（取消订阅）时会带有负荷。</p>
</li>
</ol>
<ul>
<li><strong>消息类型</strong>：<br>固定报文头中的第一个字节包含连接标志，连接标志用来区分MQTT的消息类型。MQTT协议拥有14中不同的消息类型。如下表，可简单分为连接及终止、发布和订阅、Qos2消息的机制以及各种确认ACK。</li>
</ul>
<table>
<thead>
<tr>
<th>类型名称</th>
<th>类型值</th>
<th>报文说明</th>
<th>流动方向</th>
</tr>
</thead>
<tbody><tr>
<td>CONNECT</td>
<td>1</td>
<td>客户端请求连接到服务器</td>
<td>客户端到服务器</td>
</tr>
<tr>
<td>CONNACK</td>
<td>2</td>
<td>连接确认</td>
<td>服务器到客户端</td>
</tr>
<tr>
<td>PUBLISH</td>
<td>3</td>
<td>发布消息</td>
<td>客户端到服务器，服务器到客户端</td>
</tr>
<tr>
<td>PUBACK</td>
<td>4</td>
<td>发布确认，针对QoS 1消息</td>
<td>客户端到服务器，服务器到客户端</td>
</tr>
<tr>
<td>PUBREC</td>
<td>5</td>
<td>发布收到（保证交付第一步），针对QoS 2消息</td>
<td>客户端到服务器，服务器到客户端</td>
</tr>
<tr>
<td>PUBREL</td>
<td>6</td>
<td>发布释放（保证交付第二步），针对QoS 2消息</td>
<td>客户端到服务器，服务器到客户端</td>
</tr>
<tr>
<td>PUBCOMP</td>
<td>7</td>
<td>发布完成（保证交付第三步），针对QoS 2消息</td>
<td>客户端到服务器，服务器到客户端</td>
</tr>
<tr>
<td>SUBSCRIBE</td>
<td>8</td>
<td>客户端订阅请求</td>
<td>客户端到服务器</td>
</tr>
<tr>
<td>SUBACK</td>
<td>9</td>
<td>订阅确认</td>
<td>服务器到客户端</td>
</tr>
<tr>
<td>UNSUBSCRIBE</td>
<td>10</td>
<td>取消订阅请求</td>
<td>客户端到服务器</td>
</tr>
<tr>
<td>UNSUBACK</td>
<td>11</td>
<td>取消订阅确认</td>
<td>服务器到客户端</td>
</tr>
<tr>
<td>PINGREQ</td>
<td>12</td>
<td>PING请求</td>
<td>客户端到服务器</td>
</tr>
<tr>
<td>PINGRESP</td>
<td>13</td>
<td>PING响应</td>
<td>服务器到客户端</td>
</tr>
<tr>
<td>DISCONNECT</td>
<td>14</td>
<td>客户端断开连接</td>
<td>客户端到服务器</td>
</tr>
</tbody></table>
<ul>
<li><strong>服务质量</strong>：<br>MQTT消息质量有三个等级，QoS 0、Qos 1、Qos 2。</li>
</ul>
<ol>
<li><p>Qos 0：最多分发一次，消息的传递完全依赖底层的TCP&#x2F;IP网络，协议里没有定义应答和重试。消息只会到达服务端一次，要么就没到达。</p>
</li>
<li><p>Qos 1：至少分发一次、服务器的消息接收由PUBACK消息进行确认，如果通信链路或设备异常，或指定时间内没有收到确认消息，发送端会重发这条在消息头中设置了Dup位的消息。</p>
</li>
<li><p>Qos 2：只分发一次。最高级别的消息传递，消息丢失和重复都是不可接受的，使用这个服务质量等级会有额外的开销。</p>
</li>
</ol>
<ul>
<li><strong>连接保活机制</strong>：<br>MQTT客户端可以设置一个心跳间隔时间（keep Alive Timer），表示在每个心跳检测时间内发送一条消息。如果在这个时间周期内，没有业务数据相关的消息，客户端会发送一个PINGREQ消息，相应的，服务器会返回一个PINGRESP消息进行确认。</li>
</ul>
<p>如果服务器在一个半（1.5）个心跳间隔时间周期内没有收到来自客户端的消息，就会断开与客户端的连接。心跳间隔时间最大值可以设置为18个小时，8表示客户端不会断开。</p>
<p>拓展阅读：<a href="https://cloud.tencent.com/developer/article/1432369">https://cloud.tencent.com/developer/article/1432369</a></p>
</details>



<h3 id="RESTful-的灵魂是什么？"><a href="#RESTful-的灵魂是什么？" class="headerlink" title="RESTful 的灵魂是什么？"></a>RESTful 的灵魂是什么？</h3><details>
    <summary>
        点击展开
    </summary>

<p>RESTful的灵魂是一种设计理念和风格，其核心思想是将Web应用程序建模为资源，并通过统一的接口（HTTP方法）对资源进行操作。RESTful架构风格强调以下几个关键特征：</p>
<ol>
<li><p><strong>资源（Resources）：</strong> 将网络上的信息（如文档、图片、视频等）视为资源，并使用URI（统一资源标识符）来唯一标识每个资源。</p>
</li>
<li><p><strong>表现层状态转换（Representational State Transfer）：</strong> 客户端和服务器之间的交互通过表现层的转换来实现，客户端通过操作资源的表现形式来操作资源。</p>
</li>
<li><p><strong>无状态（Stateless）：</strong> 服务端不保存客户端的状态信息，每个请求都包含足够的信息，使服务器可以理解请求的上下文。</p>
</li>
<li><p><strong>统一接口（Uniform Interface）：</strong> 使用统一的接口对资源进行操作，包括标识资源的URI、使用标准的HTTP方法（GET、POST、PUT、DELETE等）进行操作、使用标准的媒体类型（如JSON、XML）来传输资源的表现形式。</p>
</li>
<li><p><strong>客户端-服务器架构（Client-Server）：</strong> 将系统划分为客户端和服务器，客户端负责用户界面和用户交互，服务器负责存储和管理资源。</p>
</li>
<li><p><strong>可缓存性（Cacheability）：</strong> 服务端必须声明哪些资源是可缓存的，客户端可以使用缓存来提高性能和减少网络延迟。</p>
</li>
<li><p><strong>分层系统（Layered System）：</strong> 允许系统在不影响客户端的情况下增加中间层（如代理服务器、负载均衡器等），以提高系统的可伸缩性和性能。</p>
</li>
</ol>
<p>综上所述，RESTful的灵魂在于将Web应用程序建模为资源，并通过统一的接口和无状态的通信方式来实现客户端和服务器之间的交互，以实现系统的松耦合、可伸缩性和可重用性。</p>
</details>



<h3 id="AUTOSAR-是做AP还是CP，两者有什么区别，简要介绍下？"><a href="#AUTOSAR-是做AP还是CP，两者有什么区别，简要介绍下？" class="headerlink" title="AUTOSAR 是做AP还是CP，两者有什么区别，简要介绍下？"></a>AUTOSAR 是做AP还是CP，两者有什么区别，简要介绍下？</h3><details>
    <summary>
        点击展开
    </summary>

<pre><code>• 汽车领域的一套标准软件架构
• AUTOSAR的主要内容：
    ○ 完整的基础软件架构：框架，系统有哪些模块，模块间的交互
    ○ 汽车应用接口规范
    ○ 验收测试规范
    ○ 方法论
• CP：基于传统ECU的嵌入式软件平台
• AP：基于高性能智能ECU的软件中间件 [C++11、SOA、Security]
• 功能模块介绍—AP：
    ○ 通信模块（ara::com）：模块和外界交互，SOME/IP、DDS、Signal PDU、IPC
    ○ 执行模块（ara::exec）：模块在系统中如何跑起来，由一个可执行程序变成进程，管理其启动时和运行时的一些进程的行为。
    ○ 持久化模块（ara::per）：进程记录一些数据，读写一些信息，和外界配置信息交互
    ○ 时间同步（ara::tsync）：高精度时间保证。
    ○ 日志追踪（ara::log）：模块运行的记录日志。
    ○ 状态管理（ara::sm）：模块的状态转换。
    ○ 升级管理（ara::ucm）：软件升级
    ○ 诊断管理（ara::diag）
</code></pre>
</details>



<h3 id="TC397"><a href="#TC397" class="headerlink" title="TC397"></a>TC397</h3><details>
    <summary>
        点击展开
    </summary>

<p>国内L2+大多数方案 MCU:TC397 SoC:TDA4VM</p>
<p>CP AUTOSAR一般运行在8bit、16bit、32bit的微控制器（MCU）中，如英飞凌的TC3xx，瑞萨的RH850等。<br>AP AUTOSAR可以运行在64bit的高性能处理器（MPU）、CPU等中，如瑞萨的H3，英伟达的Xavier等。除此之外，AP AUTOSAR也可以运行在虚拟硬件上。<br>CP AUTOSAR OS是基于OSEK标准的。 AP AUTOSAR OS是POSIX OS，且至少应包含PSE51子集。</p>
<p>注：<br>OSEK&#x2F;VDX、POSIX和PSE51都是操作系统标准，主要用于嵌入式系统和实时系统。</p>
<p>OSEK&#x2F;VDX：这是一个为汽车电子控制单元（ECU）开发的开放式标准。它定义了一个实时操作系统（RTOS）的接口，以及一些相关的服务，如网络通信和诊断。OSEK&#x2F;VDX标准旨在提供一个跨多个硬件平台的统一的软件架构，以简化汽车电子系统的开发和维护。</p>
<p>POSIX：这是一组由IEEE定义的操作系统接口标准，旨在提高软件的可移植性。POSIX标准定义了一组核心的API和服务，包括文件系统操作、进程管理、线程管理、和信号处理等。许多操作系统，包括大多数Unix和Linux变种，以及一些嵌入式操作系统，都提供了对POSIX标准的支持。</p>
<p>PSE51：这是POSIX标准的一个子集，专门为小型嵌入式实时系统设计。PSE51标准定义了一组最小的、对实时系统有用的API和服务，包括线程管理、时间管理、和信号量等。PSE51标准旨在提供一个适合资源受限环境的、可移植的操作系统接口。</p>
</details>



<h3 id="FOTA和TBOX的通信怎么做"><a href="#FOTA和TBOX的通信怎么做" class="headerlink" title="FOTA和TBOX的通信怎么做"></a>FOTA和TBOX的通信怎么做</h3><details>
    <summary>
        点击展开
    </summary>

<p>云端和TBOX的通信，一边是上行和下行的通信，下行一般采用MQTT协议，将云端的信息通知给TBOX，上行信息一般较多，如版本信息、安装进度、安装状态等，一般采用HTTPS的POST、GET请求和云端交互，设计到指定的一系列车云REST接口。</p>
<p>MQTT：MQTT 是一种基于发布&#x2F;订阅模式的轻量级消息协议，特别适合在网络带宽较小、不稳定或高延迟的环境中使用。在车云通信的下行通信中，云端需要将信息（如 FOTA 更新）推送给 TBOX，这种一对多的通信模式非常适合 MQTT。此外，MQTT 还支持持久会话和消息存储，可以确保重要的信息不会丢失。</p>
<p>HTTPS：HTTPS 是 HTTP 的安全版本，它在 HTTP 上添加了 SSL&#x2F;TLS 协议，可以提供数据的加密传输、身份验证和消息完整性检查。在车云通信的上行通信中，TBOX 需要将信息（如版本信息、安装进度、安装状态等）发送给云端，这种一对一的通信模式非常适合 HTTPS。此外，HTTPS 的 POST 和 GET 请求可以方便地与云端的 REST 接口进行交互。</p>
</details>



<h3 id="诊断仪的代码移植"><a href="#诊断仪的代码移植" class="headerlink" title="诊断仪的代码移植"></a>诊断仪的代码移植</h3><details>
    <summary>
        点击展开
    </summary>

<ol>
<li><p>理解源代码：首先，需要理解源代码的功能和结构，包括各个模块的作用，以及它们之间的交互方式。</p>
</li>
<li><p>选择目标平台：然后，需要选择一个目标平台，这可能是一个不同的操作系统，或者一个不同的硬件架构。</p>
</li>
<li><p>设置开发环境：根据目标平台，设置相应的开发环境，包括编译器、调试器等工具。</p>
</li>
<li><p>修改代码：根据目标平台的特性，修改源代码。这可能包括修改硬件抽象层（HAL），修改操作系统相关的代码，以及修改编译器特定的代码等。</p>
</li>
<li><p>编译和测试：编译修改后的代码，并在目标平台上进行测试。测试应该包括功能测试，性能测试，以及稳定性测试等。</p>
</li>
<li><p>优化和调试：根据测试结果，进行必要的优化和调试。</p>
</li>
</ol>
</details>



<h3 id="代码移植之后怎么做验证"><a href="#代码移植之后怎么做验证" class="headerlink" title="代码移植之后怎么做验证"></a>代码移植之后怎么做验证</h3><details>
    <summary>
        点击展开
    </summary>

<ol>
<li><p>单元测试：对每个函数或模块进行独立的测试，使用 <code>EXPECT_EQ</code> 宏来检查响应是否等于预期的响应，以确保它们在新环境中的功能正确。（1.车云接口 2.整车版本 3.网络丢包）</p>
</li>
<li><p>集成测试：在所有模块组合在一起后进行测试，以确保它们能够正确地协同工作。（编译通过）</p>
</li>
<li><p>系统测试：在整个系统级别进行测试，以确保所有组件和服务在一起工作时的行为符合预期。（放到板子上跑）</p>
</li>
<li><p>性能测试：测试系统在高负载或大数据量下的性能和稳定性。（压测）</p>
</li>
<li><p>回归测试：在每次修改代码后，重新运行所有的测试，以确保修改没有引入新的错误。（查缺补漏）</p>
</li>
<li><p>验收测试：最后，进行验收测试，以确保系统满足所有的业务需求和用户需求。（质量部门）</p>
</li>
</ol>
</details>



<h3 id="CMake的基础用法"><a href="#CMake的基础用法" class="headerlink" title="CMake的基础用法"></a>CMake的基础用法</h3><details>
    <summary>
        点击展开
    </summary>

<p><a href="https://zhuanlan.zhihu.com/p/662623216">https://zhuanlan.zhihu.com/p/662623216</a></p>
<p>CMake是一个跨平台的自动化构建系统，主要用来管理软件构建的过程，它使用一个名为CMakeLists.txt的配置文件来指导编译和链接的过程。</p>
<p><code>make_minimum_required(VERSION x.x)</code>: 指定项目需要的最低CMake版本。</p>
<p><code>project(ProjectName)</code>: 定义项目的名称和使用的语言。</p>
<p><code>add_executable(TargetName source1 source2 ...)</code>: 添加一个可执行目标，并指定其源文件。</p>
<p><code>add_library(TargetName type source1 source2 ...)</code>: 添加一个库目标，并指定其类型（静态或动态）和源文件。</p>
<p><code>find_package(PackageName)</code>: 查找并加载外部依赖包。</p>
<p><code>target_link_libraries(TargetName library1 library2 ...)</code>: 指定目标链接的库。</p>
</details>



<h3 id="诊断刷写的流程"><a href="#诊断刷写的流程" class="headerlink" title="诊断刷写的流程"></a>诊断刷写的流程</h3><details>
    <summary>
        点击展开
    </summary>

<p>诊断刷写通常是指在汽车诊断过程中，通过诊断工具将新的固件刷写到汽车的电子控制单元（ECU）中。以下是一个基本的诊断刷写流程：</p>
<p>软件刷写总体上分为三个步骤：</p>
<ol>
<li>pre-programming</li>
<li>programming</li>
<li>post-programming</li>
</ol>
<p>刷写前：</p>
<p>Step 1：切换到拓展模式<br>（10：会话控制 03：拓展会话）</p>
<p>Step 2：检查刷写前提条件，如条件不满足，则退出刷写。<br>（31：例程控制 01：启动例程 XXX：例程ID，如车速、电源等）</p>
<p>Step 3：停用故障码存储功能，屏蔽故障<br>（85：故障码控制设置 02：停止故障码存储）</p>
<p>Step 4：停止发送一切通讯报文，关闭与诊断无关的报文，将节约出来的通信资源用于刷写软件，提升刷写速度。<br>（28：通信控制 01：停止发送报文和接收报文 01：一般通信报文 XXX结点识别号）</p>
<hr>
<p>Step 1：进入编程模式<br>（10：会话控制 02：编程会话）</p>
<p>Step 2：使用27服务进行安全访问<br>（27：安全访问 01：请求种子 02：发送与验证Key）</p>
<p>Step 3：写入指纹信息，即标记写软件人的身份<br>（2E：DID写入）</p>
<p>Step 4：擦除内存<br>（31：例程控制 01：启动例程 FF 00：例程ID，擦除存储数据）</p>
<p>Step 5：调用34，36，37服务完成数据的写入。<br>（34：请求下载 36：传输数据 37：请求传输退出）</p>
<p>Step 6：执行31服务，检查刚刚写入的数据块是否正确，典型的就是执行checksum验证。如果还有数据块要写，则再跳回Step 5，如果没有，则进入Step 7。<br>（31：例程控制 01：启动例程 02 02：例程ID，检查内存 FF 01： 检查编程依赖）</p>
<p>Step 7：写入所有数据块之后，一个完整的软件也就写好了，此时需要ECU检查一下这个软件是否可用，比如软硬件兼容问题。<br>（11：ECU复位 01：硬件复位）</p>
<hr>
<p>Step 1：切换到拓展模式<br>（10：会话控制 03：拓展会话）</p>
<p>Step 2：启用发送一般性通讯报文<br>（28：通信控制 00：启用发送报文和接收报文 01：一般通信报文 XXX结点识别号）</p>
<p>Step 3：各个ECU回复故障码的检测<br>（85：故障码控制设置 01：启动故障码存储）</p>
<p>Step 4：ECU回到默认模式<br>（10：会话模式 01：默认会话）</p>
</details>



<h3 id="A-x2F-B分区"><a href="#A-x2F-B分区" class="headerlink" title="A&#x2F;B分区"></a>A&#x2F;B分区</h3><details>
    <summary>
        点击展开
    </summary>

<ol>
<li>什么是A&#x2F;B分区系统呢？</li>
</ol>
<p>答：A分区或者B分区系统独立，两者之间可以相互切换的系统。</p>
<ol start="2">
<li>为什么需要这样的系统呢？</li>
</ol>
<p>答：在没有A&#x2F;B功能之前，车辆控制器的刷写需要车辆停车，满足一定的安全刷写条件后，使用诊断仪或者其他上位机刷写。这一系列的操作，费时费力。为了最大程度的节省刷写时间，给用户更好的升级体验，静默刷写来了。而静默刷写建立的基础就是A&#x2F;B功能，即：激活的分区，可以在车辆运行的过程中更新非激活分区。</p>
<ol start="3">
<li>非激活分区完成更新以后，何时切换分区？</li>
</ol>
<p>非激活分区（A分区或者B分区）完成软件更新以后，需要在下次系统启动（一般需要MCU进行系统级复位）时，进行分区切换。</p>
<ol start="4">
<li>A&#x2F;B分区均启动失败以后，应该如何处理？</li>
</ol>
<p>如果A&#x2F;B分区均启动失败，程序应该进入诊断的编程会话（Programming Session），以便于程序可以被更新，避免控制器成为”板砖”。</p>
</details>


<h3 id="为了Aspice做了那些工作"><a href="#为了Aspice做了那些工作" class="headerlink" title="为了Aspice做了那些工作"></a>为了Aspice做了那些工作</h3><details>
    <summary>
        点击展开
    </summary>

<p>ASPICE全称<code>“AutomotiveSoftware ProcessImprovement and CapacityDetermination”</code>，即<code>汽车软件过程改进及能力评定</code>。<br>它是一个过程模型，由<code>过程</code>和<code>能力度</code>两个维度构成，用于评价汽车行业<code>软件设计开发的能力水平</code>。</p>
<p>ASPICE评估对象是项目，而不是产品或公司体系。ASPICE评估只能证明一个公司某个项目在某个时间段的过程能力情况。</p>
<p>1.编写和维护技术文档，包括系统软件技术规范（SSTS）、开发接口文档等，以确保所有的软件开发活动都有明确的指导和记录。</p>
<p>2.为下一个阶段的工作提供输入。例如，系统需求会为软件需求提供输入，这样可以让工作有章法可循。</p>
<p>3.使用Jira等缺陷跟踪管理系统，明确任务和缺陷。一级需求作为epic，二级需求作为story。在这个过程中，我会与产品经理反复沟通，明确我们的目标和预期结果。</p>
<p>4.进行定期的内部审计和评估，以确保我们的软件开发过程符合ASPICE的要求。</p>
<p>5.提供培训和指导，以确保团队成员理解和遵守ASPICE规范。</p>
<p>6.在软件开发过程中，我会确保所有的变更都经过严格的变更控制过程，包括变更请求的提交、评审、批准和实施。</p>
<p>最后，我会进行持续的过程改进，以提高我们的软件开发能力和成熟度。</p>
</details>



<h3 id="进程crash之后的处理"><a href="#进程crash之后的处理" class="headerlink" title="进程crash之后的处理"></a>进程crash之后的处理</h3><details>
    <summary>
        点击展开
    </summary>

<p>Native层Crash处理:</p>
<ul>
<li><p>kernel捕捉到进程的异常信号(SIGABRT,SIGBUS,SIGFPE)时,调用信号处理函数；信号处理函数负责收集Crash进程的错误信息，并将错误信息通过socket发送给debugger守护进程；</p>
</li>
<li><p>debugger守护进程接收到crash信息后，一方面告知AMS有进程发生Crash，一方面通过tomestone保存完整的现场信息；</p>
</li>
<li><p>AMS收到Crash信息后，弹出对话框告知用户Crash信息，同时保存该crash进程的相关LOG；</p>
</li>
<li><p>出现 Crash 或 ANR，可以从以下几个方面处理：</p>
</li>
</ul>
<p>可以先把墓碑文件导出来</p>
<p>然后再搜索其中的关键字，比如：exception、crash，看看是哪些方法或者异常导致了问题；</p>
<p>根据backtrace初步定位问题原因后，查找代码进行分析修复与验证。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">NullPointerException - 空指针引用异常</span><br><span class="line">ClassCastException - 类型强制转换异常</span><br><span class="line">IllegalArgumentException - 传递非法参数异常</span><br><span class="line">ArithmeticException - 算术运算异常</span><br><span class="line">ArrayStoreException - 向数组中存放与声明类型不兼容对象异常</span><br><span class="line">IndexOutOfBoundsException - 下标越界异常</span><br><span class="line">NegativeArraySizeException - 创建一个大小为负数的数组错误异常</span><br><span class="line">NumberFormatException - 数字格式异常</span><br><span class="line">SecurityException - 安全异常</span><br><span class="line">UnsupportedOperationException - 不支持的操作异常</span><br></pre></td></tr></table></figure>

</details>


<h3 id="GCC和GDB"><a href="#GCC和GDB" class="headerlink" title="GCC和GDB"></a>GCC和GDB</h3><details>
    <summary>
        点击展开
    </summary>

<p>了解基础：首先要知道gdb是一个强大的UNIX和Linux下的<code>程序调试工具</code>，它支持多种编程语言，包括C、C++等。<br>基本命令：掌握gdb的启动方式，例如gdb program来直接调试程序。一些基本命令，如run、next、step、continue、break（或b）、print（或p）等，用于启动程序、单步执行、设置断点和查看变量值。<br>使用帮助：知道如何在gdb中使用help命令来获取帮助信息。</p>
<p>断点和监视点：深入了解不同类型的断点（如条件断点）和监视点（watchpoint）的设置和使用。<br>堆栈跟踪：学会使用backtrace（或bt）命令来查看函数调用堆栈。<br>变量查看：掌握如何查看和修改变量的值，包括局部变量和全局变量。<br>源代码导航：学习如何在gdb中导航源代码，包括设置和跳转到不同的源代码行。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">（gdb）help：查看命令帮助，具体命令查询在gdb中输入help + 命令,简写h</span><br><span class="line">（gdb）run：重新开始运行文件（run-text：加载文本文件，run-bin：加载二进制文件）,简写r</span><br><span class="line">（gdb）start：单步执行，运行程序，停在第一执行语句</span><br><span class="line">（gdb）list：查看原代码（list-n,从第n行开始查看代码。list+ 函数名：查看具体函数）,简写l</span><br><span class="line">（gdb）set：设置变量的值</span><br><span class="line">（gdb）next：单步调试（逐过程，函数直接执行）,简写n</span><br><span class="line">（gdb）step：单步调试（逐语句：跳入自定义函数内部执行）,简写s</span><br><span class="line">（gdb）backtrace：查看函数的调用的栈帧和层级关系,简写bt</span><br><span class="line">（gdb）frame：切换函数的栈帧,简写f</span><br><span class="line">（gdb）info：查看函数内部局部变量的数值,简写i</span><br><span class="line">（gdb）finish：结束当前函数，返回到函数调用点</span><br><span class="line">（gdb）continue：继续运行,简写c</span><br><span class="line">（gdb）print：打印值及地址,简写p</span><br><span class="line">（gdb）quit：退出gdb,简写q</span><br><span class="line">（gdb）break+num：在第num行设置断点,简写b</span><br><span class="line">（gdb）info breakpoints：查看当前设置的所有断点</span><br><span class="line">（gdb）delete breakpoints num：删除第num个断点,简写d</span><br><span class="line">（gdb）display：追踪查看具体变量值</span><br><span class="line">（gdb）undisplay：取消追踪观察变量</span><br><span class="line">（gdb）watch：被设置观察点的变量发生修改时，打印显示</span><br><span class="line">（gdb）i watch：显示观察点</span><br><span class="line">（gdb）enable breakpoints：启用断点</span><br><span class="line">（gdb）disable breakpoints：禁用断点</span><br><span class="line">（gdb）x：查看内存x/20xw 显示20个单元，16进制，4字节每单元</span><br><span class="line">（gdb）run argv[1] argv[2]：调试时命令行传参</span><br><span class="line">（gdb）set follow-fork-mode child#Makefile项目管理：选择跟踪父子进程（fork()）</span><br></pre></td></tr></table></figure>

</details>



<h3 id="差分升级"><a href="#差分升级" class="headerlink" title="差分升级"></a>差分升级</h3><details>
    <summary>
        点击展开
    </summary>

<p>差分算法需要解决两个主要的问题：</p>
<ol>
<li>如何高效的在old中寻找尽可能多的可用于构建new的数据流。</li>
<li>如何尽可能缩减描述old → new所需要的字节数。</li>
</ol>
<p>新老版本切分成定长的数据库，计算各块的hash，通过比对hash来寻找新旧之间相同的数据块。</p>
<p>通过后缀排序算法预处理新旧文件，将预处理的结果以后缀数组和名次数组的形式存为字典目录，基于该字典目录能能够快速查找字典数据集和待编码数据集之间的相同数据段。</p>
<p>HdiffPatch 的差异性比较主要通过以下步骤实现：</p>
<ol>
<li><p>使用<code>滑动窗口</code>在旧文件中查找新文件中的数据块。这个过程使用了<code>后缀数组</code>和<code>最长公共前缀数组</code>来加速查找。</p>
</li>
<li><p>对于在旧文件中找到的数据块，生成一个指向旧文件中位置的<code>引用</code>。</p>
</li>
<li><p>对于在旧文件中找不到的数据块，直接将这些数据包含在差分文件中。</p>
</li>
<li><p>将所有的引用和数据块按照在新文件中的顺序组合起来，生成差分文件。</p>
</li>
</ol>
<p>在 HdiffPatch 的源代码中，以下是一些核心的函数和方法：</p>
<ol>
<li><p>create_compressed_diff：这是创建差分文件的主要函数。它首先调用 search_cover 函数来查找在旧文件中的数据块，然后将找到的数据块和新文件中的其他数据一起压缩，生成差分文件。</p>
</li>
<li><p>search_cover：这个函数使用<code>滑动窗口</code>和<code>后缀数组</code>来在旧文件中查找新文件中的数据块。</p>
</li>
<li><p>hdiff_private::getChecksum：这个函数用于计算数据块的校验和，用于快速比较数据块。</p>
</li>
<li><p>hdiff_private::save_compress：这个函数用于将数据块压缩并保存到差分文件中。</p>
</li>
</ol>
<ul>
<li><p><code>使用后缀数组和最长公共前缀数组加速查找</code>：后缀数组是一个数据结构，它包含了一个字符串所有后缀的排序列表。最长公共前缀数组则存储了排序后的相邻后缀之间的最长公共前缀的长度。通过这两个数据结构，HdiffPatch 可以快速找到新文件中的数据块在旧文件中的位置。</p>
</li>
<li><p><code>使用滑动窗口查找数据块</code>：为了减小差分文件的大小，HdiffPatch 使用一个滑动窗口在旧文件中查找数据块。这个窗口的大小是可配置的，通过调整窗口大小，可以在查找速度和差分文件大小之间找到一个平衡。</p>
</li>
<li><p><code>使用压缩算法减小差分文件的大小</code>：HdiffPatch 支持多种压缩算法，包括 zlib，bzip2，lzma 等。通过压缩，可以进一步减小差分文件的大小。</p>
</li>
<li><p><code>使用校验和快速比较数据块</code>：为了加速数据块的比较，HdiffPatch 使用校验和算法计算数据块的校验和。通过比较校验和，可以快速判断两个数据块是否相同。</p>
</li>
</ul>
<p>BSDiff: APK差分升级</p>
<ol>
<li><p>将旧文件二进制使用后缀排序或哈希算法形成一个字符串索引。</p>
</li>
<li><p>使用该字符串索引对比新文件，生成差异文件(difference file)和新增文件(extra file)。</p>
</li>
<li><p>将差异文件和新增文件及必要的索引控制信息压缩为差异更新包。</p>
</li>
</ol>
<p>1）控制文件，包含需要添加和插入二进制段的指引信息（”添加指令”指定旧文件中的偏移量和长度，从旧文件读取适当的字节数，并将其添加到差异文件中的相同字节数；”插入指令”只是指定一个长度，指定的字节数是从额外的文件中读取的）；</p>
<p>2）差异文件，包含近似匹配字段的字节差异；</p>
<p>3）新增文件，包含无法近似匹配的完全不同的字段。</p>
<p>这三个文件加一起会比新文件略大，但其中控制文件和差异文件是高度结构化的，意味着其均可被高效压缩，所以可以使用类似bzip2等压缩工具将更新包总文件进行非常有效的压缩。</p>
</details>


<h3 id="Binder通讯原理解析"><a href="#Binder通讯原理解析" class="headerlink" title="Binder通讯原理解析"></a>Binder通讯原理解析</h3><details>
    <summary>
        点击展开
    </summary>

<ul>
<li>Binder 就是用来Client 端和 Server 端通信的。</li>
<li>Binder借助了内存映射（mmap）的方法，在内核空间和接收方用户空间的数据缓存区之间做了一层内存映射。从发送方用户空间拷贝到内核空间缓存区的数据，就相当于直接拷贝到了接收方用户空间的数据缓存区，从而减少了一次数据拷贝。</li>
<li>内存映射能减少数据拷贝次数，实现用户空间和内核空间的高效互动。两个空间各自的修改能直接反映在映射的内存区域，从而被对方空间及时感知。也正因为如此，内存映射能够提供对进程间通信的支持。</li>
<li>一次完整的 Binder IPC 通信过程通常是这样：<ul>
<li>1、首先 Binder 驱动在内核空间创建一个 数据接收缓存区 ；</li>
<li>2、接着在内核空间开辟一块内核缓存区，建立 内核缓存区 和 内核中数据接收缓存区 之间的映射关系，以及 内核中数据接收缓存区 和 接收进程用户空间地址 的映射关系；</li>
<li>3、发送方进程通过系统调用 copyfromuser() 将数据 copy 到内核中的内核缓存区，由于内核缓存区和接收进程的用户空间存在内存映射，因此也就相当于把数据发送到了接收进程的用户空间，这样便完成了一次进程间的通信。</li>
</ul>
</li>
</ul>
</details>


<h3 id="Android-添加自定义-native-服务"><a href="#Android-添加自定义-native-服务" class="headerlink" title="Android 添加自定义 native 服务"></a>Android 添加自定义 native 服务</h3><details>
    <summary>
        点击展开
    </summary>

<p>Native服务就是用C++写的系统服务，通过init进程启动，可以实现binder接口供client调用。</p>
<ol>
<li><p>编写服务代码：首先，你需要用C++编写你的服务代码。这通常包括实现一个或多个Binder接口，这些接口将被其他进程（客户端）调用。</p>
</li>
<li><p>编写.rc文件：.rc文件是Android的init语言脚本，用于描述应该如何启动你的服务。你需要在这个文件中指定你的服务的名称、执行路径、所需的权限等信息。</p>
</li>
<li><p>编写Android.bp文件：Android.bp文件是Android构建系统的一部分，用于描述如何构建你的服务。你需要在这个文件中指定你的源代码文件、依赖库等信息。</p>
</li>
<li><p>编译和安装：使用Android构建系统（如mm或mmm命令）编译你的服务。编译成功后，.rc文件会被安装到&#x2F;system&#x2F;etc&#x2F;init&#x2F;目录下，你的服务的可执行文件会被安装到&#x2F;system&#x2F;bin&#x2F;目录下（或其他你在.rc文件中指定的位置）。</p>
</li>
<li><p>配置SELinux策略：为了让你的服务在启动时能够获得必要的权限，你可能需要修改或添加SELinux策略。这通常涉及到编写.te文件和可能的.fc文件。</p>
</li>
<li><p>测试你的服务：重启你的设备，你的服务应该会在启动时自动运行。你可以使用ps命令检查你的服务是否正在运行，使用logcat命令查看你的服务的日志输出。</p>
</li>
</ol>
</details>]]></content>
      <categories>
        <category>Offer</category>
      </categories>
  </entry>
  <entry>
    <title>华为OD机试 C卷 三道题目思路汇总</title>
    <url>/blog/recruitment-huawei-od-2024-03-30/</url>
    <content><![CDATA[<div class="note info">

<ul>
<li>第一题<code>吃货馋嘴分披萨</code>，考察深度优先遍历和动态规划处理环形数组问题，在一个环形数组（比萨）中，每次可以选择左边或右边的元素，并且每次选择的元素必须是当前可选元素中的最大值，求能够选择的元素的最大和。</li>
<li>第二题<code>字符串变换最小字符串</code>，考察对字符串的处理，从后面向前面查找，把倒数第一个字典序最小字符的与第一个字符替换，保证最小。</li>
<li>第三题<code>满足要求的最长子串</code>，考察滑动窗口+字符串的处理，使用滑动窗口来找出只包含一个字母和任意数量数字的最长子串。</li>
</ul>
</div>

<span id="more"></span>

<h4 id="第一题-吃货馋嘴分披萨（100）"><a href="#第一题-吃货馋嘴分披萨（100）" class="headerlink" title="第一题 吃货馋嘴分披萨（100）"></a>第一题 吃货馋嘴分披萨（100）</h4><p>“吃货”和”馋嘴”两人到披萨店点了一份铁盘圆形披萨，并嘱咐店员将披萨按放射状切成大小相同的偶数个小块。但是粗心的服务员将披萨切成了每块大小都完全不同奇数块，且肉眼能分辨出大小。</p>
<p>由于两人都想吃到最多的披萨，他们商量了一个他们认为公平的分法：从”吃货”开始，轮流取被萨。除了第一块破产可以任意选取外，其他都必须从缺口开始选。</p>
<p>他俩选披萨的思路不同。”馋嘴”每次都会选最大块的披萨，而且”吃货”知道”馋嘴”的想法。</p>
<p>已知披萨小块的数量以及每块的大小，求”吃货”能分得的最大的披萨大小的总和。</p>
<p>输入描述：</p>
<blockquote>
<p>1.第1行为一个正整数奇数 N，表示披萨小块数量。<br>2.接下来的第 2 行到第 N + 1行(共 N 行)，每行为一个正整数，表示第 i 块披萨的大小。</p>
<p>说明：<br>3 &lt;&#x3D; N &lt;&#x3D; 500<br>1 &lt;&#x3D; i &lt;&#x3D; N<br>每块披萨的大小范围为[1, 2147483647]</p>
</blockquote>
<p>输出描述：</p>
<blockquote>
<p>“吃货”能分到的最大的披萨大小的总和。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Input:</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">8</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">7</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Output:</span></span><br><span class="line"><span class="comment">19</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Description:</span></span><br><span class="line"><span class="comment">此例子中，有5块披萨，每块大小分别为8、2、10、5、7</span></span><br><span class="line"><span class="comment">按照如下顺序拿披萨，可以使&quot;吃货&quot;拿到最多的披萨:</span></span><br><span class="line"><span class="comment">&quot;吃货&quot;拿大小为10的披萨</span></span><br><span class="line"><span class="comment">&quot;馋嘴&quot;拿大小为5的披萨</span></span><br><span class="line"><span class="comment">&quot;吃货&quot;拿大小为7的披萨</span></span><br><span class="line"><span class="comment">&quot;馋嘴&quot;拿大小为8的披萨</span></span><br><span class="line"><span class="comment">&quot;吃货&quot;拿大小为2的披萨</span></span><br><span class="line"><span class="comment">至披萨瓜分完毕，&quot;吃货&quot;拿到的披萨总大小为10 + 7 + 2 = 19</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">注：可能存在多种拿法，以上只身其中一种拿法。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="type">long</span>&gt;&gt; memory; <span class="comment">// 用于存储已经计算过的子问题的结果</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用DFS和DP的方法来解决问题</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">backtrace</span><span class="params">(vector&lt;<span class="type">long</span>&gt; nums, <span class="type">int</span> n, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调整left和right的值，使其始终在数组的范围内</span></span><br><span class="line">    <span class="keyword">if</span>(nums[left] &gt; nums[right]) &#123;</span><br><span class="line">        left = left &lt; <span class="number">0</span> ? left : (left + n + <span class="number">1</span>) % n;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[left] &lt; nums[right]) &#123;</span><br><span class="line">        right = right &lt; <span class="number">0</span> ? right : (right + n - <span class="number">1</span>) % n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前子问题的结果已经计算过，直接返回结果</span></span><br><span class="line">    <span class="keyword">if</span>(memory[left][right] &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果left和right相等，说明只有一个元素可以选择，直接返回这个元素的值</span></span><br><span class="line">        <span class="keyword">if</span>(left == right) &#123;</span><br><span class="line">            memory[left][right] = nums[left];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则，计算选择左边元素和选择右边元素两种情况的最大值</span></span><br><span class="line">            <span class="type">int</span> newLeft = (left + <span class="number">1</span>) % n;</span><br><span class="line">            <span class="type">int</span> newRight = (right + n - <span class="number">1</span>) % n;</span><br><span class="line">            memory[left][right] = nums[left] + <span class="built_in">backtrace</span>(nums, n, newLeft, right);</span><br><span class="line">            <span class="keyword">if</span>(nums[right] + <span class="built_in">backtrace</span>(nums, n, left, newRight) &gt; memory[left][right]) &#123;</span><br><span class="line">                memory[left][right] = nums[right] + <span class="built_in">backtrace</span>(nums, n, left, newRight);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memory[left][right];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> memory[left][right];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n) &#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">long</span>&gt; <span class="title">nums</span><span class="params">(n)</span></span>;    <span class="comment">// 披萨大小</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            cin &gt;&gt; nums[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化memory数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            vector&lt;<span class="type">long</span>&gt; tmp;</span><br><span class="line">            memory.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                memory[i].<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;  <span class="comment">// 遍历数组</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; n - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> left = (i + n + <span class="number">1</span>) % n;</span><br><span class="line">                <span class="type">int</span> right = (i + n - <span class="number">1</span>) % n;</span><br><span class="line">                <span class="type">long</span> target = <span class="built_in">backtrace</span>(nums, n, left, right);</span><br><span class="line">                <span class="keyword">if</span>(target + nums[i] &gt; res) &#123;</span><br><span class="line">                    res = target + nums[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第二题-字符串变换最小字符串（100）"><a href="#第二题-字符串变换最小字符串（100）" class="headerlink" title="第二题 字符串变换最小字符串（100）"></a>第二题 字符串变换最小字符串（100）</h4><p>给定一个字符串s，最多只能进行一次变换，返回变换后能得到的最小字符串（按照字典序进行比较）。<br>变换规则：交换字符串中任意两个不同位置的字符。</p>
<p>输入描述：</p>
<blockquote>
<p>一串小写字母组成的字符串s。</p>
<p>说明:<br>s是都是小写字符组成<br>1 &lt;&#x3D; s.length &lt;&#x3D; 1000</p>
</blockquote>
<p>输出描述：</p>
<blockquote>
<p>按照要求进行变换得到的最小字符串。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Input:</span></span><br><span class="line"><span class="comment">abcdef</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Output:</span></span><br><span class="line"><span class="comment">abcdef</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Description:</span></span><br><span class="line"><span class="comment">abcdef已经是最小字符串，不需要交换</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Input:</span></span><br><span class="line"><span class="comment">bcdefa</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Output:</span></span><br><span class="line"><span class="comment">acdefb</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Description:</span></span><br><span class="line"><span class="comment">a和b进行位置交换，可以等到最小字符串</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string str;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; str) &#123;</span><br><span class="line">        <span class="type">char</span> minChar = <span class="string">&#x27;z&#x27;</span>;</span><br><span class="line">        <span class="type">int</span> minCharIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = str.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123; <span class="comment">// 注意遍历顺序！！！</span></span><br><span class="line">            <span class="keyword">if</span>(str[i] &lt;= minChar) &#123; <span class="comment">// 确保如果有多个最小字符，总是选择最后一个</span></span><br><span class="line">                minChar = str[i];</span><br><span class="line">                minCharIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> tmp = str[<span class="number">0</span>];</span><br><span class="line">        str[<span class="number">0</span>] = minChar;</span><br><span class="line">        str[minCharIndex] = tmp;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第三道-满足要求的最长子串（200）"><a href="#第三道-满足要求的最长子串（200）" class="headerlink" title="第三道 满足要求的最长子串（200）"></a>第三道 满足要求的最长子串（200）</h4><p>给定一个字符串，只包含字母和数字，按要求找出字符串中的最长（连续）子串的长度，字符串本身是其最长的子串，子串要求：</p>
<ol>
<li>只包含1个字母(a ~ z, A ~ Z)，其余必须是数字。</li>
<li>字母可以在子串中的任意位置。</li>
</ol>
<p>如果找不到满足要求的子串，如全是字母或全是数字，则返回-1。</p>
<p>输入描述：</p>
<blockquote>
<p>字符串(只包含字母和数字)</p>
</blockquote>
<p>输出描述：</p>
<blockquote>
<p>子串的长度，没有满足要求的子串，返回-1</p>
</blockquote>
<p>解题思路：</p>
<blockquote>
<p>什么时候右边界滑动：每次滑动一个<br>什么时候形成滑动窗口：当charCount &#x3D; 1 &amp;&amp; numCount &gt;&#x3D;1<br>什么时候左边界滑动：当charCount &gt; 1时，当charCount &#x3D;&#x3D; 1时停止</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Input:</span></span><br><span class="line"><span class="comment">abC124ACb</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Output:</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Description:</span></span><br><span class="line"><span class="comment">满足条件的最长子串是C124或者124A，长度都是4</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Input:</span></span><br><span class="line"><span class="comment">a5</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Output:</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Description:</span></span><br><span class="line"><span class="comment">字符串自身就是满足条件的子串，长度为2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Input:</span></span><br><span class="line"><span class="comment">aBB9</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Output:</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Description:</span></span><br><span class="line"><span class="comment">满足条件的子串为B9，长度为2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Input:</span></span><br><span class="line"><span class="comment">abcdef</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Output:</span></span><br><span class="line"><span class="comment">-1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Description:</span></span><br><span class="line"><span class="comment">找不到满足要求的子串，返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只包含一个字母 + 字母可在任意位置</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxLength</span><span class="params">(string str)</span> </span>&#123;</span><br><span class="line">     <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>; <span class="comment">// 滑动窗口</span></span><br><span class="line">     <span class="type">int</span> charCount = <span class="number">0</span>, digitCount = <span class="number">0</span>, maxCount = <span class="number">-1</span>;</span><br><span class="line">     <span class="keyword">while</span>(right &lt; str.<span class="built_in">size</span>()) &#123;</span><br><span class="line">         <span class="keyword">if</span>(<span class="built_in">isdigit</span>(str[right])) &#123;</span><br><span class="line">             digitCount++;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             charCount++;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span>(charCount == <span class="number">1</span> &amp;&amp; digitCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">             maxCount = <span class="built_in">max</span>(maxCount, right + <span class="number">1</span> - left);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">while</span>(charCount &gt; <span class="number">1</span>) &#123;</span><br><span class="line">             <span class="keyword">if</span>(<span class="built_in">isdigit</span>((str[left]))) &#123;</span><br><span class="line">                 digitCount--;</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 charCount--;</span><br><span class="line">             &#125;</span><br><span class="line">             left++;</span><br><span class="line">         &#125;</span><br><span class="line">        right++;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> maxCount;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string str;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; str) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">maxLength</span>(str) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Offer</category>
      </categories>
  </entry>
  <entry>
    <title>SOME/IP协议介绍</title>
    <url>/blog/someip-tips/</url>
    <content><![CDATA[<div class="note info">

<ul>
<li><p><a href="http://some-ip.com/">SOME&#x2F;IP</a> 即 Scalable service-Oriented MiddlewarE over IP，是一种车载以太网通信协议，可用于<a href="https://www.autosar.org/standards/adaptive-platform">AP</a>、<a href="https://www.autosar.org/standards/classic-platform">CP</a>以及非AUTOSAR平台之间以服务为导向的交互通信。</p>
</li>
<li><p>本文主要介绍<a href="https://autosaracademy.com/autosar-some-ip-protocol/">SOME&#x2F;IP</a>的报文格式、服务接口、服务发现、序列化等基础概念。</p>
</li>
</ul>
</div>

<span id="more"></span>

<center>
    <strong>
        <font size="6">
            Scalable service-Oriented MiddlewarE over IP
        </font>
    </strong>
</center>


<table>
<thead>
<tr>
<th align="center"><img src="/blog/images/someip/Scalable-service-Oriented-MiddlewarE-over-IP.png?" alt="SOME/IP"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">SOME&#x2F;IP Protocol Specification - AUTOSAR.org</td>
</tr>
</tbody></table>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li>Scalable 可拓展的，也叫可伸缩的<ul>
<li>指能够适应不同操作系统，以及不同大小的设备</li>
<li>不同大小的设备：小到摄像头，大到车机或通信设备</li>
<li>不同操作系统：AUTOSAR、OSEK、Linux等</li>
</ul>
</li>
<li>service-Oriented 面向服务的<ul>
<li>关注对象为服务起源于传统IT行业，行对于传统面向信号通信</li>
</ul>
</li>
<li>Middlewar 中间件<ul>
<li>处于操作系统&#x2F;硬件和应用之间的系统软件或服务程序</li>
<li>不受底层硬件和操作系统的复杂性影响</li>
<li>与应用程序之间使用标准的API接口</li>
</ul>
</li>
<li>IP 就是基于TCP&#x2F;IP协议的传输，用以太网传输</li>
</ul>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><ul>
<li>谁制定：<ul>
<li>由BMW设计并纳入AUTOSAR规范</li>
</ul>
</li>
<li>为什么：<ul>
<li>车载以太网和SOA技术应用的驱动，解决服务的提供方和服务消费方之间的网络通信问题</li>
<li>提供车内信息交互的中间件解决方案，用于汽车中间件的面向服务的可伸缩的协议</li>
<li>适配不同大小的车载设置及车载操作系统之间的控制消息传输</li>
</ul>
</li>
<li>特点：<ul>
<li>支持远程过程调用、事件通知、字段访问等功能，以及多种传输层协议（如TCP、UDP、CAN等）</li>
<li>消息头包含了消息ID、长度、请求ID等信息，用于标识和区分不同的服务和方法</li>
<li>支持服务发现机制，用于动态地发现和提供服务</li>
</ul>
</li>
</ul>
<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ul>
<li>序列化<ul>
<li>将数据结构或对象依据事先定义的规则转成二进制的过程，以便于数据在网络上传输</li>
</ul>
</li>
<li>远程过程调用（RPC）<ul>
<li>通过在网络传输信息实现一个节点对另一个节点的方法调用</li>
</ul>
</li>
<li>服务发现（SD）<ul>
<li>客户端可以“寻找”所需的服务，服务端可以“告诉”大家需要的服务</li>
<li>客户端和服务端动态建立通信连接</li>
</ul>
</li>
<li>订阅发布<ul>
<li>客户端可以想服务端订阅所需要的数据，服务端以周期或者事件触发的方式发布这些数据</li>
</ul>
</li>
<li>UDP报文分段（AUTOSAR 4.3）<ul>
<li>允许通过UDP传输大型SOMEIP报文，而无需在IP层分片</li>
</ul>
</li>
</ul>
<h2 id="服务接口"><a href="#服务接口" class="headerlink" title="服务接口"></a>服务接口</h2><p><a href="https://cdn.vector.com/cms/content/events/2019/vAES19/vAES19_03_Varas_Vector.pdf">服务接口(Service Interface)</a>包含以下三种<br><img src="/blog/images/someip/someip-service-interface.png"></p>
<ul>
<li><h3 id="Method-方法"><a href="#Method-方法" class="headerlink" title="Method - 方法"></a>Method - 方法</h3></li>
</ul>
<p><img src="/blog/images/someip/someip-method.png"></p>
<ul>
<li><h3 id="Event-事件"><a href="#Event-事件" class="headerlink" title="Event - 事件"></a>Event - 事件</h3></li>
</ul>
<p><img src="/blog/images/someip/someip-event.png"></p>
<ul>
<li><h3 id="Property-x2F-Field-属性-x2F-字段"><a href="#Property-x2F-Field-属性-x2F-字段" class="headerlink" title="Property&#x2F;Field - 属性&#x2F;字段"></a>Property&#x2F;Field - 属性&#x2F;字段</h3></li>
</ul>
<p><img src="/blog/images/someip/someip-field.png"></p>
<h2 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h2><blockquote>
<ul>
<li>报文格式是通信协议中定义的数据组织方式。</li>
<li>它规定了数据如何在网络中传输，包括数据的结构、顺序、类型等信息。</li>
<li>报文格式通常包括头部（包含元数据，如源地址、目标地址、长度等）、负载（实际的数据内容）和尾部（可能包含校验和或结束标记）。</li>
</ul>
</blockquote>
<details>
    <summary>
        Click for Deatils
    </summary>
    <ol>
        不同的通信协议有不同的报文格式，设计通信协议和报文格式需要对以下方面进行权衡：
        <li>目标和用途：不同的协议设计用于解决不同的问题，例如，HTTP协议用于Web通信，FTP协议用于文件传输，SOME/IP用于车载以太网通信，每个协议需要的数据和元数据都不同。</li>
        <li>效率和性能：不同的报文格式可能会影响传输效率和网络性能。例如，一些协议可能会选择更紧凑的报文格式以减少网络带宽的使用。</li>
        <li>可靠性和错误检测：一些协议可能包含额外的错误检测和恢复机制，这可能需要特定的报文格式。</li>
        <li>兼容性和扩展性：一些协议可能设计了特定的报文格式以便于向后兼容或者未来的扩展。</li>
    </ol>
</details>

<ul>
<li>报文封装<br><img src="/blog/images/someip/someip-packet.png"></li>
<li>报文格式<br><img src="/blog/images/someip/someip-message-structure.png"></li>
<li>Message ID: 报文的唯一标识符<br><img src="/blog/images/someip/someip-message-id.png"></li>
<li>Length: 占32bit，此值为length字段之后包括数据的长度</li>
<li>Request ID: 占32bit，区分每条请求，Server端将其复制到Response报文中<br><img src="/blog/images/someip/someip-request-id.png"></li>
<li>Protocol Version：占8bits，SOME&#x2F;IP协议版本</li>
<li>Interface Version：占8bits，Service Interface的主版本</li>
<li>Message Type：占8bits<br><img src="/blog/images/someip/someip-message-type.png"></li>
<li>Return Code：占8bits，标识请求是否被成功处理<br><img src="/blog/images/someip/someip-return-code.png"></li>
</ul>
<h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><blockquote>
<ul>
<li>Serialization - 序列化<ul>
<li>将对象的状态信息转化为可以存储或以二进制的形式在网络中传输</li>
</ul>
</li>
<li>Deserialization - 反序列化<ul>
<li>将在序列化过程中所生成的二进制串转换为数据结构或者对象的过程</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li>SOMEIP 序列化：接收方能够按照既定的格式（数据格式、传输顺序、编码格式）正确解析并存储重发送方发过来的数据</li>
<li><h3 id="基本数据类型的序列化"><a href="#基本数据类型的序列化" class="headerlink" title="基本数据类型的序列化"></a>基本数据类型的序列化</h3><ul>
<li>定义传输数据的字节序</li>
<li>Example: uint32(0x8A9D6F5R)<br>  <img src="/blog/images/someip/someip-data-type.png"></li>
</ul>
</li>
<li><h3 id="结构体的序列化-Struct"><a href="#结构体的序列化-Struct" class="headerlink" title="结构体的序列化 - Struct"></a>结构体的序列化 - Struct</h3><ul>
<li>将结构体的数据袁术顺序排列，然后将各元素依次进行序列化</li>
<li>可增加Length Field来指示结构体中数据元素的字节长度<br>  <img src="/blog/images/someip/someip-serialization-struct-1.png"><br>  <img src="/blog/images/someip/someip-serialization-struct-2.png"></li>
</ul>
</li>
<li><h3 id="字符串的序列化-String"><a href="#字符串的序列化-String" class="headerlink" title="字符串的序列化 - String"></a>字符串的序列化 - String</h3><ul>
<li>String由一系列的Unicode字符构成，并以“\0”（0x00）结束</li>
<li>String前增加BOM（Byte Order Mark） + 数据（UTF8&#x2F;UTF16）+ 结束符<br>  <img src="/blog/images/someip/someip-serialization-string-1.png"><br>  <img src="/blog/images/someip/someip-serialization-string-2.png"></li>
</ul>
</li>
<li><h3 id="数组的序列化-Array"><a href="#数组的序列化-Array" class="headerlink" title="数组的序列化 - Array"></a>数组的序列化 - Array</h3><ul>
<li>数组是相同类型数据的集合，依据数组元素的顺序排列进行序列化<br>  <img src="/blog/images/someip/someip-serialization-array.png"></li>
</ul>
</li>
</ul>
<h2 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h2><ul>
<li>SD是一种特殊的服务，实现<strong>服务寻址</strong>和<strong>事件订阅</strong>功能。</li>
<li><h3 id="服务寻址"><a href="#服务寻址" class="headerlink" title="服务寻址"></a>服务寻址</h3><ul>
<li>FindService</li>
<li>OfferService</li>
<li>StopOfferService</li>
</ul>
</li>
<li><h3 id="事件订阅"><a href="#事件订阅" class="headerlink" title="事件订阅"></a>事件订阅</h3><ul>
<li>SubscribeEventGroup</li>
<li>StopSubscribeEventGroup</li>
<li>SubscribeEventgroupAck</li>
<li>SubscribeEventgroutNAck<br><img src="/blog/images/someip/someip-sd.png"></li>
</ul>
</li>
<li><h3 id="SD报文格式"><a href="#SD报文格式" class="headerlink" title="SD报文格式"></a>SD报文格式</h3><ul>
<li>SD报文实际上是一种特殊的SOME&#x2F;IP报文，SD的区别在于payload是一种特殊的格式，且MessageID是固定的0xFFFF 8100<br>  <img src="/blog/images/someip/someip-sd-message.png"></li>
<li>Flages<br>  <img src="/blog/images/someip/someip-sd-flags.png"><ul>
<li>Reboot Flag<ul>
<li>重启时或上电时置1</li>
<li>当Session ID完成从1~0xFFFF的一个循环之后，Reboot置0</li>
<li>重启检测<ul>
<li>if old.reboot &#x3D;&#x3D; 0 and new.reboot &#x3D;&#x3D; 1 then Reboot detected</li>
<li>if old.reboot &#x3D;&#x3D; 1 and new.reboot &#x3D;&#x3D; 1 and old.session_id &gt;&#x3D; new.session_id then Reboot detected</li>
</ul>
</li>
</ul>
</li>
<li>Unicase Flag<ul>
<li>是否支持单播接收(&#x3D;1)</li>
</ul>
</li>
</ul>
</li>
<li>Entry<br>  <img src="/blog/images/someip/someip-sd-entry.png"></li>
<li>Option<ul>
<li>entry的附加信息<ul>
<li>IP地址</li>
<li>传输层协议</li>
<li>端口号</li>
</ul>
</li>
<li>类型<ul>
<li>Endpoint Option</li>
<li>Multicase Option</li>
<li>Configuration Option</li>
<li>Load Balancing Option</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><h3 id="SD启动时序"><a href="#SD启动时序" class="headerlink" title="SD启动时序"></a>SD启动时序</h3><ul>
<li>关闭阶段（Down）</li>
<li>可用阶段（Available）<ul>
<li>初始等待阶段（Initial Wait Phase）</li>
<li>重复阶段（Repetition Phase）</li>
<li>主阶段（Main Phase）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://www.bilibili.com/video/BV1dY4y1H7eZ">https://www.bilibili.com/video/BV1dY4y1H7eZ</a></li>
<li><a href="https://github.com/COVESA/vsomeip/wiki/vsomeip-in-10-minutes">https://github.com/COVESA/vsomeip/wiki/vsomeip-in-10-minutes</a></li>
<li><a href="https://autosaracademy.com/autosar-some-ip-protocol/">https://autosaracademy.com/autosar-some-ip-protocol/</a></li>
</ul>
]]></content>
      <categories>
        <category>Works</category>
      </categories>
  </entry>
  <entry>
    <title>Tmux 使用手册</title>
    <url>/blog/tmux-manual/</url>
    <content><![CDATA[<div class="note info">

<ul>
<li>Tmux 即 Terminal Multiplexer，是一个强大的终端复用器，可以在一个终端窗口中运行多个终端会话。</li>
<li>本文主要根据个人工作中常用的 Tmux 应用场景进行相关指令和快捷键的总结。</li>
</ul>
</div>

<span id="more"></span>

<h2 id="Tmux-基础"><a href="#Tmux-基础" class="headerlink" title="Tmux 基础"></a>Tmux 基础</h2><h3 id="Tmux与进程"><a href="#Tmux与进程" class="headerlink" title="Tmux与进程"></a>Tmux与进程</h3><ul>
<li>在 Tmux 中，一个<code>会话(session)</code>是一个独立的工作环境，包含一组窗口。</li>
<li><code>窗口(window)</code>是 Tmux 中的基本单位，每个窗口都可以包含一个或多个窗格。</li>
<li><code>窗格(pane)</code>是窗口中的一个区域，每个窗格都运行一个 shell 进程。</li>
</ul>
<p><img src="/blog/images/tmux/tmux-session-window-pane.png"></p>
<h3 id="Tmux的作用"><a href="#Tmux的作用" class="headerlink" title="Tmux的作用"></a>Tmux的作用</h3><ul>
<li><p><strong>多任务处理</strong>：Tmux 允许在一个终端窗口中打开多个会话，每个会话都可以包含多个窗口，每个窗口都可以包含多个窗格。这使得开发者可以在一个地方同时进行多个任务。</p>
</li>
<li><p><strong>持久会话</strong>：即使 SSH 连接断开，Tmux 会话仍然会保持运行，可以重新连接到 Tmux 会话，继续运行工作。</p>
</li>
<li><p><strong>窗口管理</strong>：Tmux 提供了许多窗口管理功能，如窗口分割、窗口切换、窗口重命名等。</p>
</li>
<li><p><strong>脚本自动化</strong>：可以使用 Tmux 脚本来自动化工作流程，例如，自动创建多个窗口和窗格，运行特定的命令等。</p>
</li>
<li><p><strong>团队协作</strong>：Tmux 支持会话共享，这意味着多个用户可以同时查看和操作同一个 Tmux 会话，这对于远程团队协作非常有用。</p>
</li>
</ul>
<h3 id="Tmux的安装"><a href="#Tmux的安装" class="headerlink" title="Tmux的安装"></a>Tmux的安装</h3><p>Tmux 可以在大多数的 Linux 发行版和 macOS 中通过包管理器安装。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Ubuntu 或 Debian</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt-get install tmux</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">CentOS 或 Fedora</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo yum install tmux</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Mac</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">brew install tmux</span></span><br></pre></td></tr></table></figure>

<h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><h3 id="启动与退出"><a href="#启动与退出" class="headerlink" title="启动与退出"></a>启动与退出</h3><!--rehype:wrap-class=row-span-2-->

<table>
<thead>
<tr>
<th align="left">Command</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>tmux</code></td>
<td>启动一个新的 Tmux 会话</td>
</tr>
<tr>
<td align="left"><code>exit</code></td>
<td>退出 Tmux 会话窗口</td>
</tr>
</tbody></table>
<!--rehype:className=left-align code-nowrap-->

<h3 id="会话管理"><a href="#会话管理" class="headerlink" title="会话管理"></a>会话管理</h3><!--rehype:wrap-class=row-span-3-->

<table>
<thead>
<tr>
<th align="left">Command</th>
<th>Description</th>
<th>Quick</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>tmux list-sessions</code></td>
<td>查看所有会话</td>
<td><code>Ctrl+b s</code></td>
</tr>
<tr>
<td align="left"><code>tmux rename-session -t old-session session-name</code></td>
<td>重命名会话</td>
<td><code>Ctrl+b $</code></td>
</tr>
<tr>
<td align="left"><code>tmux new -s session-name</code></td>
<td>新建会话</td>
<td></td>
</tr>
<tr>
<td align="left"><code>tmux attach -t session-name</code></td>
<td>接入会话</td>
<td></td>
</tr>
<tr>
<td align="left"><code>tmux switch -t session-name</code></td>
<td>切换会话</td>
<td><code>Ctrl+b l</code></td>
</tr>
<tr>
<td align="left"><code>tmux detach -t session-name</code></td>
<td>分离会话</td>
<td><code>Ctrl+b d</code></td>
</tr>
<tr>
<td align="left"><code>tmux kill-session -t session-name</code></td>
<td>结束会话</td>
<td><code>Ctrl+b &amp;</code></td>
</tr>
</tbody></table>
<!--rehype:className=left-align code-nowrap-->

<h3 id="窗格管理"><a href="#窗格管理" class="headerlink" title="窗格管理"></a>窗格管理</h3><!--rehype:wrap-class=row-span-3-->

<table>
<thead>
<tr>
<th align="left">Command</th>
<th>Description</th>
<th>Quick</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>tmux split-window</code></td>
<td>划分上下两个窗格</td>
<td><code>Ctrl+b &quot;</code></td>
</tr>
<tr>
<td align="left"><code>tmux split-window -h</code></td>
<td>划分左右两个窗格</td>
<td><code>Ctrl+b %</code></td>
</tr>
<tr>
<td align="left"><code>tmux swap-pane -U</code></td>
<td>当前窗格上移</td>
<td><code>Ctrl+b &#123;</code></td>
</tr>
<tr>
<td align="left"><code>tmux swap-pane -U</code></td>
<td>当前窗格下移</td>
<td><code>Ctrl+b &#125;</code></td>
</tr>
<tr>
<td align="left"><code>tmux select-pane -U</code></td>
<td>光标切换到上方窗格</td>
<td><code>Ctrl+b ↑</code></td>
</tr>
<tr>
<td align="left"><code>tmux select-pane -D</code></td>
<td>光标切换到下方窗格</td>
<td><code>Ctrl+b ↓</code></td>
</tr>
<tr>
<td align="left"><code>tmux select-pane -L</code></td>
<td>光标切换到左方窗格</td>
<td><code>Ctrl+b ←</code></td>
</tr>
<tr>
<td align="left"><code>tmux select-pane -R</code></td>
<td>光标切换到右方窗格</td>
<td><code>Ctrl+b →</code></td>
</tr>
<tr>
<td align="left"><code>tmux kill-pane</code></td>
<td>关闭当前窗格</td>
<td><code>Ctrl+b x</code></td>
</tr>
<tr>
<td align="left"><code>tmux break-pane</code></td>
<td>将当前窗格拆分为独立窗口</td>
<td><code>Ctrl+b !</code></td>
</tr>
<tr>
<td align="left"><code>tmux resize-pane -Z</code></td>
<td>当前窗格全屏显示</td>
<td><code>Ctrl+b z</code></td>
</tr>
<tr>
<td align="left"><code>tmux resize-pane -U</code></td>
<td>向上调整窗格大小</td>
<td><code>Ctrl+b Ctrl+↑</code></td>
</tr>
<tr>
<td align="left"><code>tmux resize-pane -D</code></td>
<td>向下调整窗格大小</td>
<td><code>Ctrl+b Ctrl+↓</code></td>
</tr>
<tr>
<td align="left"><code>tmux resize-pane -L</code></td>
<td>向左调整窗格大小</td>
<td><code>Ctrl+b Ctrl+←</code></td>
</tr>
<tr>
<td align="left"><code>tmux resize-pane -R</code></td>
<td>向右调整窗格大小</td>
<td><code>Ctrl+b Ctrl+→</code></td>
</tr>
<tr>
<td align="left"><code>tmux display-panes</code></td>
<td>显示窗格编号</td>
<td><code>Ctrl+b q</code></td>
</tr>
</tbody></table>
<!--rehype:className=left-align code-nowrap-->

<h3 id="窗口管理"><a href="#窗口管理" class="headerlink" title="窗口管理"></a>窗口管理</h3><!--rehype:wrap-class=row-span-3-->

<table>
<thead>
<tr>
<th align="left">Command</th>
<th>Description</th>
<th>Quick</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>tmux new-window -n window-name</code></td>
<td>创建一个新窗口</td>
<td><code>Ctrl+b c</code></td>
</tr>
<tr>
<td align="left"><code>tmux previous-window</code></td>
<td>切换到上一个窗口</td>
<td><code>Ctrl+b p</code></td>
</tr>
<tr>
<td align="left"><code>tmux next-window</code></td>
<td>切换到下一个窗口</td>
<td><code>Ctrl+b n</code></td>
</tr>
<tr>
<td align="left"><code>tmux select-window -t :0</code></td>
<td>切换到指定编号的窗口</td>
<td><code>Ctrl+b &lt;number&gt;</code></td>
</tr>
<tr>
<td align="left"><code>tmux choose-window</code></td>
<td>从列表中选择窗口</td>
<td><code>Ctrl+b w</code></td>
</tr>
<tr>
<td align="left"><code>tmux rename-window</code></td>
<td>窗口重命名</td>
<td><code>Ctrl+b ,</code></td>
</tr>
</tbody></table>
<!--rehype:className=left-align code-nowrap-->

<h3 id="自定义配置"><a href="#自定义配置" class="headerlink" title="自定义配置"></a>自定义配置</h3><h2 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h2><!--rehype:wrap-class=row-span-2-->

<table>
<thead>
<tr>
<th align="left">Command</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>tmux list-keys</code></td>
<td>列出所有快捷键及其对应的 Tmux 命令</td>
</tr>
<tr>
<td align="left"><code>tmux list-commands</code></td>
<td>列出所有 Tmux 命令及其参数</td>
</tr>
<tr>
<td align="left"><code>tmux info</code></td>
<td>列出当前所有 Tmux 会话的信息</td>
</tr>
<tr>
<td align="left"><code>tmux source-file ~/.tmux.conf</code></td>
<td>重新加载当前的 Tmux 配置</td>
</tr>
</tbody></table>
<!--rehype:className=left-align code-nowrap-->

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.ruanyifeng.com/blog/2019/10/tmux.html">Tmux 使用教程 - 阮一峰的网络日志</a><br><a href="https://www.hamvocke.com/blog/a-quick-and-easy-guide-to-tmux/">A Quick and Easy Guide to tmux - Ham Vocke</a></p>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
  </entry>
  <entry>
    <title>SQL面试经典50题</title>
    <url>/blog/sql-50/</url>
    <content><![CDATA[<div class="note info">

<ul>
<li>SQL 是一种专门用来与数据库沟通的语言，提供了一种从数据库中读写数据的简单有效的方法。</li>
<li>SQL 简单易学，它的语句全都是由有很强描述性的英语单词组成，而且这些单词的数目不多。</li>
<li>SQL 虽然看上去很简单，但实际上是一种强有力的语言，灵活使用其语言元素，可以进行非常复杂和高级的数据库操作。</li>
<li>与其他任何语言一样，学习 SQL 的最好方法是自己动手实践，本文整理了面试中常用到的50个高频MySQL实战例题。</li>
</ul>
</div>

<span id="more"></span>

<h2 id="建表语句"><a href="#建表语句" class="headerlink" title="建表语句"></a>建表语句</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Student(sid <span class="type">varchar</span>(<span class="number">10</span>),sname <span class="type">varchar</span>(<span class="number">10</span>),sage datetime,ssex nvarchar(<span class="number">10</span>));</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Student <span class="keyword">values</span>(<span class="string">&#x27;01&#x27;</span> , <span class="string">&#x27;赵雷&#x27;</span> , <span class="string">&#x27;1990-01-01&#x27;</span> , <span class="string">&#x27;男&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Student <span class="keyword">values</span>(<span class="string">&#x27;02&#x27;</span> , <span class="string">&#x27;钱电&#x27;</span> , <span class="string">&#x27;1990-12-21&#x27;</span> , <span class="string">&#x27;男&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Student <span class="keyword">values</span>(<span class="string">&#x27;03&#x27;</span> , <span class="string">&#x27;孙风&#x27;</span> , <span class="string">&#x27;1990-05-20&#x27;</span> , <span class="string">&#x27;男&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Student <span class="keyword">values</span>(<span class="string">&#x27;04&#x27;</span> , <span class="string">&#x27;李云&#x27;</span> , <span class="string">&#x27;1990-08-06&#x27;</span> , <span class="string">&#x27;男&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Student <span class="keyword">values</span>(<span class="string">&#x27;05&#x27;</span> , <span class="string">&#x27;周梅&#x27;</span> , <span class="string">&#x27;1991-12-01&#x27;</span> , <span class="string">&#x27;女&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Student <span class="keyword">values</span>(<span class="string">&#x27;06&#x27;</span> , <span class="string">&#x27;吴兰&#x27;</span> , <span class="string">&#x27;1992-03-01&#x27;</span> , <span class="string">&#x27;女&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Student <span class="keyword">values</span>(<span class="string">&#x27;07&#x27;</span> , <span class="string">&#x27;郑竹&#x27;</span> , <span class="string">&#x27;1989-07-01&#x27;</span> , <span class="string">&#x27;女&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Student <span class="keyword">values</span>(<span class="string">&#x27;08&#x27;</span> , <span class="string">&#x27;王菊&#x27;</span> , <span class="string">&#x27;1990-01-20&#x27;</span> , <span class="string">&#x27;女&#x27;</span>);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Course(cid <span class="type">varchar</span>(<span class="number">10</span>),cname <span class="type">varchar</span>(<span class="number">10</span>),tid <span class="type">varchar</span>(<span class="number">10</span>));</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Course <span class="keyword">values</span>(<span class="string">&#x27;01&#x27;</span> , <span class="string">&#x27;语文&#x27;</span> , <span class="string">&#x27;02&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Course <span class="keyword">values</span>(<span class="string">&#x27;02&#x27;</span> , <span class="string">&#x27;数学&#x27;</span> , <span class="string">&#x27;01&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Course <span class="keyword">values</span>(<span class="string">&#x27;03&#x27;</span> , <span class="string">&#x27;英语&#x27;</span> , <span class="string">&#x27;03&#x27;</span>);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Teacher(tid <span class="type">varchar</span>(<span class="number">10</span>),tname <span class="type">varchar</span>(<span class="number">10</span>));</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Teacher <span class="keyword">values</span>(<span class="string">&#x27;01&#x27;</span> , <span class="string">&#x27;张三&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Teacher <span class="keyword">values</span>(<span class="string">&#x27;02&#x27;</span> , <span class="string">&#x27;李四&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Teacher <span class="keyword">values</span>(<span class="string">&#x27;03&#x27;</span> , <span class="string">&#x27;王五&#x27;</span>);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> SC(sid <span class="type">varchar</span>(<span class="number">10</span>),cid <span class="type">varchar</span>(<span class="number">10</span>),score <span class="type">decimal</span>(<span class="number">18</span>,<span class="number">1</span>));</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> SC <span class="keyword">values</span>(<span class="string">&#x27;01&#x27;</span> , <span class="string">&#x27;01&#x27;</span> , <span class="number">80</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> SC <span class="keyword">values</span>(<span class="string">&#x27;01&#x27;</span> , <span class="string">&#x27;02&#x27;</span> , <span class="number">90</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> SC <span class="keyword">values</span>(<span class="string">&#x27;01&#x27;</span> , <span class="string">&#x27;03&#x27;</span> , <span class="number">99</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> SC <span class="keyword">values</span>(<span class="string">&#x27;02&#x27;</span> , <span class="string">&#x27;01&#x27;</span> , <span class="number">70</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> SC <span class="keyword">values</span>(<span class="string">&#x27;02&#x27;</span> , <span class="string">&#x27;02&#x27;</span> , <span class="number">60</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> SC <span class="keyword">values</span>(<span class="string">&#x27;02&#x27;</span> , <span class="string">&#x27;03&#x27;</span> , <span class="number">80</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> SC <span class="keyword">values</span>(<span class="string">&#x27;03&#x27;</span> , <span class="string">&#x27;01&#x27;</span> , <span class="number">80</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> SC <span class="keyword">values</span>(<span class="string">&#x27;03&#x27;</span> , <span class="string">&#x27;02&#x27;</span> , <span class="number">80</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> SC <span class="keyword">values</span>(<span class="string">&#x27;03&#x27;</span> , <span class="string">&#x27;03&#x27;</span> , <span class="number">80</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> SC <span class="keyword">values</span>(<span class="string">&#x27;04&#x27;</span> , <span class="string">&#x27;01&#x27;</span> , <span class="number">50</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> SC <span class="keyword">values</span>(<span class="string">&#x27;04&#x27;</span> , <span class="string">&#x27;02&#x27;</span> , <span class="number">30</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> SC <span class="keyword">values</span>(<span class="string">&#x27;04&#x27;</span> , <span class="string">&#x27;03&#x27;</span> , <span class="number">20</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> SC <span class="keyword">values</span>(<span class="string">&#x27;05&#x27;</span> , <span class="string">&#x27;01&#x27;</span> , <span class="number">76</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> SC <span class="keyword">values</span>(<span class="string">&#x27;05&#x27;</span> , <span class="string">&#x27;02&#x27;</span> , <span class="number">87</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> SC <span class="keyword">values</span>(<span class="string">&#x27;06&#x27;</span> , <span class="string">&#x27;01&#x27;</span> , <span class="number">31</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> SC <span class="keyword">values</span>(<span class="string">&#x27;06&#x27;</span> , <span class="string">&#x27;03&#x27;</span> , <span class="number">34</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> SC <span class="keyword">values</span>(<span class="string">&#x27;07&#x27;</span> , <span class="string">&#x27;02&#x27;</span> , <span class="number">89</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> SC <span class="keyword">values</span>(<span class="string">&#x27;07&#x27;</span> , <span class="string">&#x27;03&#x27;</span> , <span class="number">98</span>);</span><br></pre></td></tr></table></figure>

<h2 id="表结构"><a href="#表结构" class="headerlink" title="表结构"></a>表结构</h2><ul>
<li><p>学生表 Student</p>
<pre><code>  SId 学生编号
  Sname 学生姓名		
  Sage 出生年月		
  Ssex 学生性别
</code></pre>
</li>
<li><p>课程表 Course</p>
<pre><code>  CId 课程编号
  Cname 课程名称		
  TId 教师编号
</code></pre>
</li>
<li><p>教师表 Teacher</p>
<pre><code>  TId 教师编号
  Tname 教师姓名
</code></pre>
</li>
<li><p>成绩表 SC</p>
<pre><code>  SId 学生编号
  CId 课程编号
  score 分数
</code></pre>
</li>
</ul>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="1、查询“01”课程比“02”课程成绩高的所有学生的学号："><a href="#1、查询“01”课程比“02”课程成绩高的所有学生的学号：" class="headerlink" title="1、查询“01”课程比“02”课程成绩高的所有学生的学号："></a>1、查询“01”课程比“02”课程成绩高的所有学生的学号：</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s1.sid </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	( <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> SC <span class="keyword">WHERE</span> cid <span class="operator">=</span> <span class="number">01</span> ) s1</span><br><span class="line">	<span class="keyword">LEFT</span> <span class="keyword">JOIN</span> ( <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> SC <span class="keyword">WHERE</span> cid <span class="operator">=</span> <span class="number">02</span> ) s2 <span class="keyword">ON</span> s1.sid <span class="operator">=</span> s2.sid </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	s1.score <span class="operator">&gt;</span> s2.score;</span><br></pre></td></tr></table></figure>

<h3 id="2、查询平均成绩大于60分的同学的学号和平均成绩；"><a href="#2、查询平均成绩大于60分的同学的学号和平均成绩；" class="headerlink" title="2、查询平均成绩大于60分的同学的学号和平均成绩；"></a>2、查询平均成绩大于60分的同学的学号和平均成绩；</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> sid,<span class="built_in">AVG</span>( score ) </span><br><span class="line"><span class="keyword">FROM</span> SC </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> sid </span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">AVG</span>( score ) <span class="operator">&gt;</span> <span class="number">60</span>;</span><br></pre></td></tr></table></figure>

<h3 id="3、查询所有同学的学号、姓名、选课数、总成绩"><a href="#3、查询所有同学的学号、姓名、选课数、总成绩" class="headerlink" title="3、查询所有同学的学号、姓名、选课数、总成绩"></a>3、查询所有同学的学号、姓名、选课数、总成绩</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Student.sid,Student.sname,<span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> cid),<span class="built_in">SUM</span>(<span class="keyword">DISTINCT</span> score)</span><br><span class="line"><span class="keyword">FROM</span> Student <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> SC</span><br><span class="line"><span class="keyword">ON</span> Student.sid <span class="operator">=</span> SC.sid</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> Student.sid,Student.sid</span><br></pre></td></tr></table></figure>

<h3 id="4、查询姓“李”的老师的个数；"><a href="#4、查询姓“李”的老师的个数；" class="headerlink" title="4、查询姓“李”的老师的个数；"></a>4、查询姓“李”的老师的个数；</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> tid) <span class="keyword">AS</span> teacher_cnt</span><br><span class="line"><span class="keyword">FROM</span> Teacher</span><br><span class="line"><span class="keyword">WHERE</span> tname <span class="keyword">LIKE</span> &quot;李%&quot;</span><br></pre></td></tr></table></figure>

<h3 id="5、查询没学过“张三”老师课的同学的学号、姓名；"><a href="#5、查询没学过“张三”老师课的同学的学号、姓名；" class="headerlink" title="5、查询没学过“张三”老师课的同学的学号、姓名；"></a>5、查询没学过“张三”老师课的同学的学号、姓名；</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> Student.sid,Student.sname </span><br><span class="line"><span class="keyword">FROM</span> Student <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> SC </span><br><span class="line"><span class="keyword">ON</span> Student.sid <span class="operator">=</span> SC.sid</span><br><span class="line"><span class="keyword">WHERE</span> SC.cid <span class="keyword">NOT</span> <span class="keyword">IN</span></span><br><span class="line">	(<span class="keyword">SELECT</span> cid </span><br><span class="line">	<span class="keyword">FROM</span> 	Course <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> Teacher <span class="keyword">ON</span> Course.tid <span class="operator">=</span> Teacher.tid </span><br><span class="line">	<span class="keyword">WHERE</span> tname <span class="operator">=</span> &quot;张三&quot;)</span><br></pre></td></tr></table></figure>

<h3 id="6、查询学过编号“01”并且也学过编号“02”课程的同学的学号、姓名；"><a href="#6、查询学过编号“01”并且也学过编号“02”课程的同学的学号、姓名；" class="headerlink" title="6、查询学过编号“01”并且也学过编号“02”课程的同学的学号、姓名；"></a>6、查询学过编号“01”并且也学过编号“02”课程的同学的学号、姓名；</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> t.sid <span class="keyword">AS</span> sid,Student.sname</span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">	(<span class="keyword">SELECT</span> sid </span><br><span class="line">	<span class="keyword">FROM</span> SC</span><br><span class="line">	<span class="keyword">GROUP</span> <span class="keyword">BY</span> sid</span><br><span class="line">	<span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(IF(cid <span class="operator">=</span> &quot;01&quot;,score,<span class="keyword">NULL</span>)) <span class="operator">&gt;</span> <span class="number">0</span> </span><br><span class="line">	<span class="keyword">AND</span></span><br><span class="line">	<span class="built_in">COUNT</span>(IF(cid <span class="operator">=</span> &quot;02&quot;,score,<span class="keyword">NULL</span>)) <span class="operator">&gt;</span> <span class="number">0</span>) <span class="keyword">AS</span> t</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> Student</span><br><span class="line"><span class="keyword">ON</span> t.sid <span class="operator">=</span> Student.sid;</span><br></pre></td></tr></table></figure>

<h3 id="7、查询学过“张三”老师所教的课的同学的学号、姓名；"><a href="#7、查询学过“张三”老师所教的课的同学的学号、姓名；" class="headerlink" title="7、查询学过“张三”老师所教的课的同学的学号、姓名；"></a>7、查询学过“张三”老师所教的课的同学的学号、姓名；</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s.sid,Student.sname </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	(<span class="keyword">SELECT</span> SC.sid</span><br><span class="line">	<span class="keyword">FROM</span></span><br><span class="line">		(<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> cid</span><br><span class="line">		<span class="keyword">FROM</span> Course <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> Teacher</span><br><span class="line">		<span class="keyword">ON</span> Course.tid <span class="operator">=</span> Teacher.tid</span><br><span class="line">		<span class="keyword">WHERE</span> Teacher.tname <span class="operator">=</span> &quot;张三&quot;) c</span><br><span class="line">		<span class="keyword">LEFT</span> <span class="keyword">JOIN</span> SC <span class="keyword">ON</span> c.cid <span class="operator">=</span> SC.cid) s</span><br><span class="line">		<span class="keyword">LEFT</span> <span class="keyword">JOIN</span> Student <span class="keyword">ON</span> s.sid <span class="operator">=</span> Student.sid</span><br></pre></td></tr></table></figure>

<h3 id="8、查询课程编号“01”的成绩比课程编号“02”课程低的所有同学的学号、姓名；"><a href="#8、查询课程编号“01”的成绩比课程编号“02”课程低的所有同学的学号、姓名；" class="headerlink" title="8、查询课程编号“01”的成绩比课程编号“02”课程低的所有同学的学号、姓名；"></a>8、查询课程编号“01”的成绩比课程编号“02”课程低的所有同学的学号、姓名；</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> t.sid,Student.sname</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	(<span class="keyword">SELECT</span> s1.sid</span><br><span class="line">	<span class="keyword">FROM</span></span><br><span class="line">		(<span class="keyword">SELECT</span> sid,score</span><br><span class="line">		<span class="keyword">FROM</span> SC</span><br><span class="line">		<span class="keyword">WHERE</span> cid <span class="operator">=</span> &quot;01&quot; <span class="keyword">AND</span> score <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>) s1</span><br><span class="line">		<span class="keyword">LEFT</span> <span class="keyword">JOIN</span></span><br><span class="line">		(<span class="keyword">SELECT</span> sid,score</span><br><span class="line">		<span class="keyword">FROM</span> SC</span><br><span class="line">		<span class="keyword">WHERE</span> cid <span class="operator">=</span> &quot;02&quot; <span class="keyword">AND</span> score <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>) s2</span><br><span class="line">		<span class="keyword">ON</span> s1.sid <span class="operator">=</span> s2.sid</span><br><span class="line">	<span class="keyword">WHERE</span> s1.score <span class="operator">&lt;</span> s2.score) t</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> Student</span><br><span class="line"><span class="keyword">ON</span> t.sid <span class="operator">=</span> Student.sid</span><br></pre></td></tr></table></figure>

<h3 id="9、查询所有课程成绩小于60分的同学的学号、姓名；"><a href="#9、查询所有课程成绩小于60分的同学的学号、姓名；" class="headerlink" title="9、查询所有课程成绩小于60分的同学的学号、姓名；"></a>9、查询所有课程成绩小于60分的同学的学号、姓名；</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> t.sid,Student.sname</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	(<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> sid</span><br><span class="line">	<span class="keyword">FROM</span> SC</span><br><span class="line">	<span class="keyword">GROUP</span> <span class="keyword">BY</span> sid</span><br><span class="line">	<span class="keyword">HAVING</span> <span class="built_in">MAX</span>(score) <span class="operator">&lt;</span> <span class="number">60</span>) t</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> Student</span><br><span class="line"><span class="keyword">ON</span> t.sid <span class="operator">=</span> Student.sid</span><br></pre></td></tr></table></figure>

<h3 id="10、查询没有学全所有课的同学的学号、姓名；"><a href="#10、查询没有学全所有课的同学的学号、姓名；" class="headerlink" title="10、查询没有学全所有课的同学的学号、姓名；"></a>10、查询没有学全所有课的同学的学号、姓名；</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> t.sid,Student.sname</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	(<span class="keyword">SELECT</span> sid</span><br><span class="line">	<span class="keyword">FROM</span> SC</span><br><span class="line">	<span class="keyword">GROUP</span> <span class="keyword">BY</span> sid</span><br><span class="line">	<span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> cid) <span class="operator">&lt;</span> </span><br><span class="line">	(<span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> cid)</span><br><span class="line">	<span class="keyword">FROM</span> Course)) t</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> Student</span><br><span class="line"><span class="keyword">ON</span> t.sid <span class="operator">=</span> Student.sid</span><br></pre></td></tr></table></figure>

<h3 id="11、查询至少有一门课与学号为“01”的同学所学相同的同学的学号和姓名；"><a href="#11、查询至少有一门课与学号为“01”的同学所学相同的同学的学号和姓名；" class="headerlink" title="11、查询至少有一门课与学号为“01”的同学所学相同的同学的学号和姓名；"></a>11、查询至少有一门课与学号为“01”的同学所学相同的同学的学号和姓名；</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> t.sid,Student.sname</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	(<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> co.sid</span><br><span class="line">	<span class="keyword">FROM</span></span><br><span class="line">		(<span class="keyword">SELECT</span> cid</span><br><span class="line">		<span class="keyword">FROM</span> SC </span><br><span class="line">		<span class="keyword">WHERE</span> sid <span class="operator">=</span> &quot;01&quot;) c1</span><br><span class="line">	<span class="keyword">LEFT</span> <span class="keyword">JOIN</span> </span><br><span class="line">		(<span class="keyword">SELECT</span> sid,cid</span><br><span class="line">		<span class="keyword">FROM</span> SC</span><br><span class="line">		<span class="keyword">WHERE</span> sid <span class="operator">!=</span> &quot;01&quot;) co</span><br><span class="line">	<span class="keyword">ON</span> c1.cid <span class="operator">=</span> co.cid) t</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> Student</span><br><span class="line"><span class="keyword">ON</span> t.sid <span class="operator">=</span> Student.sid</span><br></pre></td></tr></table></figure>

<h3 id="12、查询和”01”号的同学学习的课程完全相同的其他同学的学号和姓名"><a href="#12、查询和”01”号的同学学习的课程完全相同的其他同学的学号和姓名" class="headerlink" title="12、查询和”01”号的同学学习的课程完全相同的其他同学的学号和姓名"></a>12、查询和”01”号的同学学习的课程完全相同的其他同学的学号和姓名</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> t.sid,Student.sname</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	(<span class="keyword">SELECT</span> co.sid</span><br><span class="line">		<span class="keyword">FROM</span></span><br><span class="line">			(<span class="keyword">SELECT</span> cid</span><br><span class="line">			<span class="keyword">FROM</span> SC </span><br><span class="line">			<span class="keyword">WHERE</span> sid <span class="operator">=</span> &quot;01&quot;) c1</span><br><span class="line">		<span class="keyword">LEFT</span> <span class="keyword">JOIN</span> </span><br><span class="line">			(<span class="keyword">SELECT</span> sid,cid</span><br><span class="line">			<span class="keyword">FROM</span> SC</span><br><span class="line">			<span class="keyword">WHERE</span> sid <span class="operator">!=</span> &quot;01&quot;) co</span><br><span class="line">		<span class="keyword">ON</span> c1.cid <span class="operator">=</span> co.cid </span><br><span class="line">		<span class="keyword">GROUP</span> <span class="keyword">BY</span> co.sid</span><br><span class="line">		<span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(co.cid) <span class="operator">=</span> </span><br><span class="line">		(<span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> cid)</span><br><span class="line">		<span class="keyword">FROM</span> SC</span><br><span class="line">		<span class="keyword">WHERE</span> sid <span class="operator">=</span> &quot;01&quot;)) t</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> Student</span><br><span class="line"><span class="keyword">ON</span> t.sid <span class="operator">=</span> Student.sid</span><br></pre></td></tr></table></figure>

<h3 id="13、把“SC”表中“张三”老师教的课的成绩都更改为此课程的平均成绩；"><a href="#13、把“SC”表中“张三”老师教的课的成绩都更改为此课程的平均成绩；" class="headerlink" title="13、把“SC”表中“张三”老师教的课的成绩都更改为此课程的平均成绩；"></a>13、把“SC”表中“张三”老师教的课的成绩都更改为此课程的平均成绩；</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#暂跳过<span class="keyword">update</span>题目</span><br></pre></td></tr></table></figure>

<h3 id="14、查询没学过”张三”老师讲授的任一门课程的学生姓名"><a href="#14、查询没学过”张三”老师讲授的任一门课程的学生姓名" class="headerlink" title="14、查询没学过”张三”老师讲授的任一门课程的学生姓名"></a>14、查询没学过”张三”老师讲授的任一门课程的学生姓名</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> sid,sname</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> sid <span class="keyword">NOT</span> <span class="keyword">IN</span></span><br><span class="line">	(<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> sid</span><br><span class="line">	<span class="keyword">FROM</span> SC</span><br><span class="line">	<span class="keyword">LEFT</span> <span class="keyword">JOIN</span> Course</span><br><span class="line">	<span class="keyword">ON</span> SC.cid <span class="operator">=</span> Course.cid</span><br><span class="line">	<span class="keyword">LEFT</span> <span class="keyword">JOIN</span> Teacher</span><br><span class="line">	<span class="keyword">ON</span> Course.tid <span class="operator">=</span> Teacher.tid</span><br><span class="line">	<span class="keyword">WHERE</span> Teacher.tname <span class="operator">=</span> &quot;张三&quot;)</span><br></pre></td></tr></table></figure>

<h3 id="15、查询两门及其以上不及格课程的同学的学号，姓名及其平均成绩"><a href="#15、查询两门及其以上不及格课程的同学的学号，姓名及其平均成绩" class="headerlink" title="15、查询两门及其以上不及格课程的同学的学号，姓名及其平均成绩"></a>15、查询两门及其以上不及格课程的同学的学号，姓名及其平均成绩</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> t.sid,Student.sname,t.avgScore</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	(<span class="keyword">SELECT</span> sid,<span class="built_in">AVG</span>(score) avgScore</span><br><span class="line">	<span class="keyword">FROM</span> SC</span><br><span class="line">	<span class="keyword">GROUP</span> <span class="keyword">BY</span> sid</span><br><span class="line">	<span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(IF(score <span class="operator">&lt;</span> <span class="number">60</span>,cid,<span class="keyword">NULL</span>)) <span class="operator">&gt;=</span> <span class="number">2</span>) t</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> Student</span><br><span class="line"><span class="keyword">ON</span> t.sid <span class="operator">=</span> Student.sid</span><br></pre></td></tr></table></figure>

<h3 id="16、检索”01”课程分数小于60，按分数降序排列的学生信息"><a href="#16、检索”01”课程分数小于60，按分数降序排列的学生信息" class="headerlink" title="16、检索”01”课程分数小于60，按分数降序排列的学生信息"></a>16、检索”01”课程分数小于60，按分数降序排列的学生信息</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Student.<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	(<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> sid</span><br><span class="line">	<span class="keyword">FROM</span> SC</span><br><span class="line">	<span class="keyword">WHERE</span> cid <span class="operator">=</span> &quot;01&quot; <span class="keyword">AND</span> score <span class="operator">&lt;</span> <span class="number">60</span> </span><br><span class="line">	<span class="keyword">ORDER</span> <span class="keyword">BY</span> score <span class="keyword">DESC</span>) t</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> Student</span><br><span class="line"><span class="keyword">ON</span> t.sid <span class="operator">=</span> Student.sid</span><br></pre></td></tr></table></figure>

<h3 id="17、按平均成绩从高到低显示所有学生的平均成绩"><a href="#17、按平均成绩从高到低显示所有学生的平均成绩" class="headerlink" title="17、按平均成绩从高到低显示所有学生的平均成绩"></a>17、按平均成绩从高到低显示所有学生的平均成绩</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> sid,<span class="built_in">AVG</span>(score) </span><br><span class="line"><span class="keyword">FROM</span> SC</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> sid</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="built_in">AVG</span>(score) <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure>

<h3 id="18、查询各科成绩最高分、最低分和平均分：以如下形式显示：课程ID，课程name，最高分，最低分，平均分，及格率"><a href="#18、查询各科成绩最高分、最低分和平均分：以如下形式显示：课程ID，课程name，最高分，最低分，平均分，及格率" class="headerlink" title="18、查询各科成绩最高分、最低分和平均分：以如下形式显示：课程ID，课程name，最高分，最低分，平均分，及格率"></a>18、查询各科成绩最高分、最低分和平均分：以如下形式显示：课程ID，课程name，最高分，最低分，平均分，及格率</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> SC.cid, Course.cname ,<span class="built_in">MAX</span>(score) maxScore,<span class="built_in">MIN</span>(score) minScore,<span class="built_in">AVG</span>(score) avgScore,</span><br><span class="line"><span class="built_in">COUNT</span>(IF(score <span class="operator">&gt;</span> <span class="number">60</span>,sid,<span class="keyword">NULL</span>)) <span class="operator">/</span> <span class="built_in">COUNT</span>(sid) passRate</span><br><span class="line"><span class="keyword">FROM</span> SC</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> Course</span><br><span class="line"><span class="keyword">ON</span> SC.cid <span class="operator">=</span> Course.cid</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> SC.cid</span><br></pre></td></tr></table></figure>

<h3 id="19、按各科平均成绩从低到高和及格率的百分数从高到低顺序"><a href="#19、按各科平均成绩从低到高和及格率的百分数从高到低顺序" class="headerlink" title="19、按各科平均成绩从低到高和及格率的百分数从高到低顺序"></a>19、按各科平均成绩从低到高和及格率的百分数从高到低顺序</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> SC.cid,<span class="built_in">AVG</span>(score) avgScore,</span><br><span class="line"><span class="built_in">COUNT</span>(IF(score <span class="operator">&gt;</span> <span class="number">60</span>,sid,<span class="keyword">NULL</span>)) <span class="operator">/</span> <span class="built_in">COUNT</span>(sid) passRate</span><br><span class="line"><span class="keyword">FROM</span> SC</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> Course</span><br><span class="line"><span class="keyword">ON</span> SC.cid <span class="operator">=</span> Course.cid</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> SC.cid</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> avgScore <span class="keyword">ASC</span>,</span><br><span class="line">passRate <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure>

<h3 id="20、查询学生的总成绩并进行排名"><a href="#20、查询学生的总成绩并进行排名" class="headerlink" title="20、查询学生的总成绩并进行排名"></a>20、查询学生的总成绩并进行排名</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> sid,<span class="built_in">SUM</span>(score) sumScore</span><br><span class="line"><span class="keyword">FROM</span> SC</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> sid</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> sumScore <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure>

<h3 id="21、查询不同老师所教不同课程平均分从高到低显示"><a href="#21、查询不同老师所教不同课程平均分从高到低显示" class="headerlink" title="21、查询不同老师所教不同课程平均分从高到低显示"></a>21、查询不同老师所教不同课程平均分从高到低显示</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Course.tid,Course.cid,Course.cname,<span class="built_in">AVG</span>(score) avgScore</span><br><span class="line"><span class="keyword">FROM</span> SC</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> Course</span><br><span class="line"><span class="keyword">ON</span> SC.cid <span class="operator">=</span> Course.cid</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> Course.tid,SC.cid</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> avgScore <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure>

<h3 id="22、查询所有课程的成绩第2名到第3名的学生信息及该课程成绩"><a href="#22、查询所有课程的成绩第2名到第3名的学生信息及该课程成绩" class="headerlink" title="22、查询所有课程的成绩第2名到第3名的学生信息及该课程成绩"></a>22、查询所有课程的成绩第2名到第3名的学生信息及该课程成绩</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">## oracle写法</span><br><span class="line"><span class="keyword">select</span></span><br><span class="line"> sid,rank_num,score,cid</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line"> (</span><br><span class="line"> <span class="keyword">select</span></span><br><span class="line"> <span class="built_in">rank</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> cid <span class="keyword">order</span> <span class="keyword">by</span> score <span class="keyword">desc</span>) <span class="keyword">as</span> rank_num,sid,score,cid</span><br><span class="line"> <span class="keyword">from</span> sc</span><br><span class="line"> )t</span><br><span class="line"><span class="keyword">where</span> rank_num <span class="keyword">in</span> (<span class="number">2</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<h3 id="23、统计各科成绩各分数段人数：课程编号-课程名称-100-85-85-70-70-60-0-60-及所占百分比"><a href="#23、统计各科成绩各分数段人数：课程编号-课程名称-100-85-85-70-70-60-0-60-及所占百分比" class="headerlink" title="23、统计各科成绩各分数段人数：课程编号,课程名称,[100-85],[85-70],[70-60],[0-60]及所占百分比"></a>23、统计各科成绩各分数段人数：课程编号,课程名称,[100-85],[85-70],[70-60],[0-60]及所占百分比</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line"> sc.cid,</span><br><span class="line"> cname,</span><br><span class="line"> <span class="built_in">count</span>(if(score <span class="keyword">between</span> <span class="number">85</span> <span class="keyword">and</span> <span class="number">100</span>,sid,<span class="keyword">null</span>))<span class="operator">/</span><span class="built_in">count</span>(sid),</span><br><span class="line"> <span class="built_in">count</span>(if(score <span class="keyword">between</span> <span class="number">70</span> <span class="keyword">and</span> <span class="number">85</span>,sid,<span class="keyword">null</span>))<span class="operator">/</span><span class="built_in">count</span>(sid),</span><br><span class="line"> <span class="built_in">count</span>(if(score <span class="keyword">between</span> <span class="number">60</span> <span class="keyword">and</span> <span class="number">70</span>,sid,<span class="keyword">null</span>))<span class="operator">/</span><span class="built_in">count</span>(sid),</span><br><span class="line"> <span class="built_in">count</span>(if(score <span class="keyword">between</span> <span class="number">0</span> <span class="keyword">and</span> <span class="number">60</span>,sid,<span class="keyword">null</span>))<span class="operator">/</span><span class="built_in">count</span>(sid)</span><br><span class="line"><span class="keyword">from</span> sc</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> course</span><br><span class="line"> <span class="keyword">on</span> sc.cid<span class="operator">=</span>course.cid</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> sc.cid,cname</span><br></pre></td></tr></table></figure>

<h3 id="24、查询学生平均成绩及其名次"><a href="#24、查询学生平均成绩及其名次" class="headerlink" title="24、查询学生平均成绩及其名次"></a>24、查询学生平均成绩及其名次</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">## oracle写法</span><br><span class="line"><span class="keyword">select</span> sid,avg_score,<span class="built_in">rank</span>() <span class="keyword">over</span> (<span class="keyword">order</span> <span class="keyword">by</span> avg_score <span class="keyword">desc</span>)</span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line"> (</span><br><span class="line"> <span class="keyword">select</span> sid,<span class="built_in">avg</span>(score) <span class="keyword">as</span> avg_score</span><br><span class="line"> <span class="keyword">from</span> sc</span><br><span class="line"> <span class="keyword">group</span> <span class="keyword">by</span> sid</span><br><span class="line"> )t</span><br></pre></td></tr></table></figure>

<h3 id="25、查询各科成绩前三名的记录"><a href="#25、查询各科成绩前三名的记录" class="headerlink" title="25、查询各科成绩前三名的记录"></a>25、查询各科成绩前三名的记录</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">## oracle写法</span><br><span class="line"><span class="keyword">select</span></span><br><span class="line"> sid,cid,rank1</span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line"> (</span><br><span class="line"> <span class="keyword">select</span> cid,sid,<span class="built_in">rank</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> cid <span class="keyword">order</span> <span class="keyword">by</span> score <span class="keyword">desc</span>) <span class="keyword">as</span> rank1</span><br><span class="line"> <span class="keyword">from</span> sc</span><br><span class="line"> )t</span><br><span class="line"><span class="keyword">where</span> rank1<span class="operator">&lt;=</span><span class="number">3</span></span><br></pre></td></tr></table></figure>

<h3 id="26、查询每门课程被选修的学生数"><a href="#26、查询每门课程被选修的学生数" class="headerlink" title="26、查询每门课程被选修的学生数"></a>26、查询每门课程被选修的学生数</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(sid),cid</span><br><span class="line"><span class="keyword">from</span> sc</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> cid</span><br></pre></td></tr></table></figure>

<h3 id="27、查询出只选修了一门课程的全部学生的学号和姓名"><a href="#27、查询出只选修了一门课程的全部学生的学号和姓名" class="headerlink" title="27、查询出只选修了一门课程的全部学生的学号和姓名"></a>27、查询出只选修了一门课程的全部学生的学号和姓名</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> s.<span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> sc</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> student s</span><br><span class="line"><span class="keyword">on</span> s.sid <span class="operator">=</span> sc.sid</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> sid</span><br><span class="line"><span class="keyword">having</span> <span class="built_in">count</span>(cid) <span class="operator">=</span><span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="28、查询男生、女生人数"><a href="#28、查询男生、女生人数" class="headerlink" title="28、查询男生、女生人数"></a>28、查询男生、女生人数</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> ssex,<span class="built_in">count</span>(<span class="keyword">distinct</span> sid)</span><br><span class="line"><span class="keyword">from</span> student</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> ssex</span><br></pre></td></tr></table></figure>

<h3 id="29、查询名字中含有”风”字的学生信息"><a href="#29、查询名字中含有”风”字的学生信息" class="headerlink" title="29、查询名字中含有”风”字的学生信息"></a>29、查询名字中含有”风”字的学生信息</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> sid,sname</span><br><span class="line"><span class="keyword">from</span> student</span><br><span class="line"><span class="keyword">where</span> sname <span class="keyword">like</span> <span class="string">&#x27;%风%&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="30、查询同名同性学生名单，并统计同名人数"><a href="#30、查询同名同性学生名单，并统计同名人数" class="headerlink" title="30、查询同名同性学生名单，并统计同名人数"></a>30、查询同名同性学生名单，并统计同名人数</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> ssex,sname,<span class="built_in">count</span>(sid)</span><br><span class="line"><span class="keyword">from</span> student</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> ssex,sname</span><br><span class="line"><span class="keyword">having</span> <span class="built_in">count</span>(sid)<span class="operator">&gt;=</span><span class="number">2</span></span><br></pre></td></tr></table></figure>

<h3 id="31、查询1990年出生的学生名单-注：Student表中Sage列的类型是datetime"><a href="#31、查询1990年出生的学生名单-注：Student表中Sage列的类型是datetime" class="headerlink" title="31、查询1990年出生的学生名单(注：Student表中Sage列的类型是datetime)"></a>31、查询1990年出生的学生名单(注：Student表中Sage列的类型是datetime)</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> student s</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">year</span>(s.sage) <span class="operator">=</span> <span class="number">1990</span></span><br></pre></td></tr></table></figure>

<h3 id="32、查询每门课程的平均成绩，结果按平均成绩升序排列，平均成绩相同时，按课程号降序排列"><a href="#32、查询每门课程的平均成绩，结果按平均成绩升序排列，平均成绩相同时，按课程号降序排列" class="headerlink" title="32、查询每门课程的平均成绩，结果按平均成绩升序排列，平均成绩相同时，按课程号降序排列"></a>32、查询每门课程的平均成绩，结果按平均成绩升序排列，平均成绩相同时，按课程号降序排列</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> sc.cid, <span class="built_in">avg</span>(sc.score)</span><br><span class="line"><span class="keyword">from</span> sc</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> sc.cid</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> <span class="built_in">avg</span>(sc.score), cid <span class="keyword">desc</span></span><br></pre></td></tr></table></figure>

<h3 id="37、查询不及格的课程，并按课程号从大到小排列"><a href="#37、查询不及格的课程，并按课程号从大到小排列" class="headerlink" title="37、查询不及格的课程，并按课程号从大到小排列"></a>37、查询不及格的课程，并按课程号从大到小排列</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> c.cid, c.cname</span><br><span class="line"><span class="keyword">from</span> sc</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> course c</span><br><span class="line"><span class="keyword">on</span> c.cid <span class="operator">=</span> sc.cid</span><br><span class="line"><span class="keyword">where</span> sc.score <span class="operator">&lt;</span> <span class="number">60</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> sc.cid <span class="keyword">desc</span></span><br></pre></td></tr></table></figure>

<h3 id="38、查询课程编号为”01”且课程成绩在60分以上的学生的学号和姓名；"><a href="#38、查询课程编号为”01”且课程成绩在60分以上的学生的学号和姓名；" class="headerlink" title="38、查询课程编号为”01”且课程成绩在60分以上的学生的学号和姓名；"></a>38、查询课程编号为”01”且课程成绩在60分以上的学生的学号和姓名；</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> s.sid, s.sname</span><br><span class="line"><span class="keyword">from</span> sc</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> course c</span><br><span class="line"><span class="keyword">on</span> c.cid <span class="operator">=</span> sc.cid</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> student s</span><br><span class="line"><span class="keyword">on</span> s.sid <span class="operator">=</span> sc.sid</span><br><span class="line"><span class="keyword">where</span> <span class="number">1</span><span class="operator">=</span><span class="number">1</span></span><br><span class="line"><span class="keyword">and</span> c.cid <span class="operator">=</span> <span class="string">&#x27;01&#x27;</span></span><br><span class="line"><span class="keyword">and</span> sc.score <span class="operator">&gt;</span> <span class="number">60</span></span><br></pre></td></tr></table></figure>

<h3 id="40、查询选修“张三”老师所授课程的学生中，成绩最高的学生姓名及其成绩"><a href="#40、查询选修“张三”老师所授课程的学生中，成绩最高的学生姓名及其成绩" class="headerlink" title="40、查询选修“张三”老师所授课程的学生中，成绩最高的学生姓名及其成绩"></a>40、查询选修“张三”老师所授课程的学生中，成绩最高的学生姓名及其成绩</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> s.sname, sc.score</span><br><span class="line"><span class="keyword">from</span> sc</span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span> course c</span><br><span class="line"><span class="keyword">on</span> c.cid <span class="operator">=</span> sc.cid</span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span> teacher t</span><br><span class="line"><span class="keyword">on</span> t.tid <span class="operator">=</span> c.tid</span><br><span class="line"><span class="keyword">and</span> t.tname <span class="operator">=</span> <span class="string">&#x27;张三&#x27;</span></span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> student s</span><br><span class="line"><span class="keyword">on</span> s.sid <span class="operator">=</span> sc.sid</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> sc.score <span class="keyword">desc</span></span><br><span class="line">limit <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="42、查询每门功课成绩最好的前两名"><a href="#42、查询每门功课成绩最好的前两名" class="headerlink" title="42、查询每门功课成绩最好的前两名"></a>42、查询每门功课成绩最好的前两名</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">## Oracle写法</span><br><span class="line"><span class="keyword">select</span> cid,sid,rank1</span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line"> (</span><br><span class="line"> <span class="keyword">select</span> cid,sid,<span class="built_in">rank</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> cid <span class="keyword">order</span> <span class="keyword">by</span> scor <span class="keyword">desc</span>) <span class="keyword">as</span> rank1</span><br><span class="line"> <span class="keyword">from</span> sc </span><br><span class="line"> )t</span><br><span class="line"><span class="keyword">where</span> rank1 <span class="operator">&lt;=</span><span class="number">2</span></span><br></pre></td></tr></table></figure>

<h3 id="43、统计每门课程的学生选修人数（超过5人的课程才统计）。要求输出课程号和选修人数，查询结果按人数降序排列，若人数相同，按课程号升序排列"><a href="#43、统计每门课程的学生选修人数（超过5人的课程才统计）。要求输出课程号和选修人数，查询结果按人数降序排列，若人数相同，按课程号升序排列" class="headerlink" title="43、统计每门课程的学生选修人数（超过5人的课程才统计）。要求输出课程号和选修人数，查询结果按人数降序排列，若人数相同，按课程号升序排列"></a>43、统计每门课程的学生选修人数（超过5人的课程才统计）。要求输出课程号和选修人数，查询结果按人数降序排列，若人数相同，按课程号升序排列</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> c.cid, c.cname, <span class="built_in">count</span>(sc.cid)</span><br><span class="line"><span class="keyword">from</span> sc</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> course c</span><br><span class="line"><span class="keyword">on</span> c.cid <span class="operator">=</span> sc.cid</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> sc.cid</span><br><span class="line"><span class="keyword">having</span> <span class="built_in">count</span>(sc.cid) <span class="operator">&gt;</span> <span class="number">5</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> <span class="built_in">count</span>(sc.cid) <span class="keyword">desc</span>, sc.cid <span class="keyword">asc</span></span><br></pre></td></tr></table></figure>

<h3 id="44、检索至少选修两门课程的学生学号"><a href="#44、检索至少选修两门课程的学生学号" class="headerlink" title="44、检索至少选修两门课程的学生学号"></a>44、检索至少选修两门课程的学生学号</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> s.<span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> student s</span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span> sc </span><br><span class="line"><span class="keyword">on</span> sc.sid <span class="operator">=</span> s.sid</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> sc.sid</span><br><span class="line"><span class="keyword">having</span> <span class="built_in">count</span>(sc.cid) <span class="operator">&gt;=</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>

<h3 id="45、查询选修了全部课程的学生信息"><a href="#45、查询选修了全部课程的学生信息" class="headerlink" title="45、查询选修了全部课程的学生信息"></a>45、查询选修了全部课程的学生信息</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> s.<span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> student s</span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span> sc </span><br><span class="line"><span class="keyword">on</span> sc.sid <span class="operator">=</span> s.sid</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> sc.sid</span><br><span class="line"><span class="keyword">having</span> <span class="built_in">count</span>(sc.cid) <span class="operator">=</span> (</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> c.cid)</span><br><span class="line"><span class="keyword">from</span> course c</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="46、查询各学生的年龄"><a href="#46、查询各学生的年龄" class="headerlink" title="46、查询各学生的年龄"></a>46、查询各学生的年龄</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line"> sid,sname,<span class="keyword">year</span>(curdate())<span class="operator">-</span><span class="keyword">year</span>(sage) <span class="operator">+</span>  <span class="number">1</span> <span class="keyword">as</span> sage</span><br><span class="line"><span class="keyword">from</span> student</span><br></pre></td></tr></table></figure>

<h3 id="47、查询本周过生日的学生"><a href="#47、查询本周过生日的学生" class="headerlink" title="47、查询本周过生日的学生"></a>47、查询本周过生日的学生</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line"> s.sid,s.sname,s.sage</span><br><span class="line"><span class="keyword">from</span> student s</span><br><span class="line"><span class="keyword">where</span> weekofyear(s.sage) <span class="operator">=</span> weekofyear(curdate())</span><br></pre></td></tr></table></figure>

<h3 id="48、查询下周过生日的学生"><a href="#48、查询下周过生日的学生" class="headerlink" title="48、查询下周过生日的学生"></a>48、查询下周过生日的学生</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line"> s.sid,s.sname,s.sage</span><br><span class="line"><span class="keyword">from</span> student s</span><br><span class="line"><span class="keyword">where</span> weekofyear(s.sage) <span class="operator">=</span> weekofyear(date_add(curdate(),<span class="type">interval</span> <span class="number">1</span> week))</span><br></pre></td></tr></table></figure>

<h3 id="49、查询本月过生日的学生"><a href="#49、查询本月过生日的学生" class="headerlink" title="49、查询本月过生日的学生"></a>49、查询本月过生日的学生</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line"> s.sid,s.sname,s.sage</span><br><span class="line"><span class="keyword">from</span> student s</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">month</span>(s.sage) <span class="operator">=</span> <span class="keyword">month</span>(curdate())</span><br></pre></td></tr></table></figure>

<h3 id="50、查询下月过生日的学生"><a href="#50、查询下月过生日的学生" class="headerlink" title="50、查询下月过生日的学生"></a>50、查询下月过生日的学生</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line"> s.sid,s.sname,s.sage</span><br><span class="line"><span class="keyword">from</span> student s</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">month</span>(date_sub(s.sage,<span class="type">interval</span> <span class="number">1</span> <span class="keyword">month</span>)) <span class="operator">=</span> <span class="keyword">month</span>(curdate())</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Database</category>
      </categories>
  </entry>
</search>
